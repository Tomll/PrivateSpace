diff --git a/Android.mk b/Android.mk
index 874e3b1..122da74 100755
--- a/Android.mk
+++ b/Android.mk
@@ -7,7 +7,8 @@ LOCAL_STATIC_JAVA_LIBRARIES := \
     android-support-v4 \
     android-support-v7-recyclerview \
     android-support-v7-appcompat \
-    android-support-design
+    android-support-design \
+    commons-codec-1.4
 
 LOCAL_RESOURCE_DIR = $(LOCAL_PATH)/res \
     frameworks/support/v7/recyclerview/res \
@@ -30,6 +31,7 @@ include $(CLEAR_VARS)
 ###LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=supportv7appcompat:libs/android-support-v7-appcompat.jar
 ###LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=supportv7recyclerview:libs/android-support-v7-recyclerview.jar
 ###LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=supportdesign:libs/android-support-design.jar
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :=libs/commons-codec-1.4.jar
 include $(BUILD_MULTI_PREBUILT)
 include $(call all-makefiles-under,$(LOCAL_PATH))
 
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 81d1409..907d753 100755
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -14,6 +14,7 @@
     <uses-permission android:name="android.permission.WRITE_CONTACTS"/>
     <uses-permission android:name="android.permission.CALL_PHONE"/>
     <uses-permission android:name="android.permission.READ_CALL_LOG"/>
+    <uses-permission android:name="android.permission.WRITE_CALL_LOG"/>
     <uses-permission android:name="android.permission.SEND_SMS"/>
     <uses-permission android:name="android.permission.READ_SMS"/>
 
@@ -56,6 +57,9 @@
         <activity
             android:name=".activity.AddPeople"
             android:screenOrientation="portrait"/>
+        <activity
+            android:name=".activity.PrivateContactsActivity"
+            android:screenOrientation="portrait"/>
     </application>
 
 </manifest>
\ No newline at end of file
diff --git a/libs/commons-codec-1.4.jar b/libs/commons-codec-1.4.jar
new file mode 100755
index 0000000..458d432
Binary files /dev/null and b/libs/commons-codec-1.4.jar differ
diff --git a/src/com/transage/featureoption/FeatureOption.java b/src/com/transage/featureoption/FeatureOption.java
deleted file mode 100755
index 830fce9..0000000
--- a/src/com/transage/featureoption/FeatureOption.java
+++ /dev/null
@@ -1,7 +0,0 @@
-/* generated by mediatek */
-
-package com.transage.featureoption;
-
-public final class FeatureOption
-{
-}
diff --git a/src/com/transage/privatespace/activity/AddPeople.java b/src/com/transage/privatespace/activity/AddPeople.java
index 088931b..a811686 100755
--- a/src/com/transage/privatespace/activity/AddPeople.java
+++ b/src/com/transage/privatespace/activity/AddPeople.java
@@ -72,7 +72,7 @@ public class AddPeople extends Activity implements AdapterView.OnItemClickListen
                 list_selectedPeople.add(next.getValue());
             }
             //将peopleList中的联系人加为私密
-            PrivateSpaceUtils.setPrivateContacts(list_selectedPeople, 1, this);
+            PrivateSpaceUtils.executePrivateContacts(list_selectedPeople, 1, this);
 //            setPrivateContacts(list_selectedPeople, 1, getContentResolver());
             finish();
         }
@@ -140,7 +140,7 @@ public class AddPeople extends Activity implements AdapterView.OnItemClickListen
                     }
                     //添加一条数据到peopleList
                     People people = new People();
-                    people.setName(contactName);
+                    people.setDisplayName(contactName);
                     people.setRawContactId(contactId);
                     people.setPhoneNum(contactNumber);
                     peopleList.add(people);
@@ -192,7 +192,7 @@ public class AddPeople extends Activity implements AdapterView.OnItemClickListen
         }
         //将peopleList中的联系人加为私密
 //        setPrivateContacts(list_selectedPeople, 1, getContentResolver());
-        PrivateSpaceUtils.setPrivateContacts(list_selectedPeople, 1, this);
+        PrivateSpaceUtils.executePrivateContacts(list_selectedPeople, 1, this);
         finish();
     }
 
diff --git a/src/com/transage/privatespace/activity/PrivateContactsActivity.java b/src/com/transage/privatespace/activity/PrivateContactsActivity.java
new file mode 100755
index 0000000..5fa0ef3
--- /dev/null
+++ b/src/com/transage/privatespace/activity/PrivateContactsActivity.java
@@ -0,0 +1,58 @@
+package com.transage.privatespace.activity;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.Button;
+import android.widget.LinearLayout;
+
+import com.transage.privatespace.R;
+import com.transage.privatespace.bean.ContactInfo;
+import com.transage.privatespace.utils.ImportExportUtils;
+
+import java.util.List;
+
+/**
+ * Created by yanjie.xu on 2017/7/19.
+ */
+
+public class PrivateContactsActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        LinearLayout layout = new LinearLayout(this);
+        Button button1 = new Button(this);
+        button1.setText("写入文件");
+        Button button2 = new Button(this);
+        button2.setText("读取文件");
+        layout.addView(button1);
+        layout.addView(button2);
+        setContentView(layout);
+
+        button1.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                try{
+//                    ImportExportUtils.writeData();
+                    List<ContactInfo> contactInfo = ContactInfo.ContactHandler.getInstance().getContactInfo(PrivateContactsActivity.this);
+                    ContactInfo.ContactHandler.getInstance().backupContacts(PrivateContactsActivity.this, contactInfo);
+                }catch (Exception e){
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        button2.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                try{
+//                    ImportExportUtils.readData();
+                    ContactInfo.ContactHandler.getInstance().restoreContacts();
+                }catch (Exception e){
+                    e.printStackTrace();
+                }
+            }
+        });
+    }
+}
diff --git a/src/com/transage/privatespace/adapter/AddPeopleListViewAdapter.java b/src/com/transage/privatespace/adapter/AddPeopleListViewAdapter.java
index e5e4c66..46de672 100755
--- a/src/com/transage/privatespace/adapter/AddPeopleListViewAdapter.java
+++ b/src/com/transage/privatespace/adapter/AddPeopleListViewAdapter.java
@@ -63,7 +63,7 @@ public class AddPeopleListViewAdapter extends BaseAdapter {
 		}
 		// 数据适配
 		viewHolder.checkBox.setChecked(map_allCheckBoxSelectedStatus.get(position));
-		viewHolder.name.setText(peopleList.get(position).getName());
+		viewHolder.name.setText(peopleList.get(position).getDisplayName());
 		viewHolder.phoneNum.setText(peopleList.get(position).getPhoneNum());
 		return convertView;
 	}
diff --git a/src/com/transage/privatespace/adapter/CallRecordListViewAdapter.java b/src/com/transage/privatespace/adapter/CallRecordListViewAdapter.java
index faf7224..f54cd3d 100755
--- a/src/com/transage/privatespace/adapter/CallRecordListViewAdapter.java
+++ b/src/com/transage/privatespace/adapter/CallRecordListViewAdapter.java
@@ -11,30 +11,32 @@ import android.widget.TextView;
 
 import com.transage.privatespace.R;
 import com.transage.privatespace.bean.CallRecord;
+import com.transage.privatespace.utils.PrivateSpaceUtils;
 
 import java.util.ArrayList;
+import java.util.List;
 
 /**
  * Created by dongrp on 2016/9/7.
  */
 public class CallRecordListViewAdapter extends BaseAdapter {
     private Context context;
-    private ArrayList<ArrayList<CallRecord>> listCallRecordList;
+    private List<CallRecord> mCallRecordList;
 
 
-    public CallRecordListViewAdapter(Context context, ArrayList<ArrayList<CallRecord>> listCallRecordList) {
+    public CallRecordListViewAdapter(Context context, List<CallRecord> callRecordList) {
         this.context = context;
-        this.listCallRecordList = listCallRecordList;
+        this.mCallRecordList = callRecordList;
     }
 
     @Override
     public int getCount() {
-        return listCallRecordList.size();
+        return mCallRecordList.size();
     }
 
     @Override
     public Object getItem(int position) {
-        return listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1);
+        return mCallRecordList.get(position);
     }
 
     @Override
@@ -58,16 +60,17 @@ public class CallRecordListViewAdapter extends BaseAdapter {
         }
         //数据适配
         //最新的通话记录是list的最后一项
-        if (listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1).getType() == CallLog.Calls.INCOMING_TYPE) { //呼入
+        CallRecord callRecord = mCallRecordList.get(position);
+        if (callRecord.getType() == CallLog.Calls.INCOMING_TYPE) { //呼入
             viewHolder.ivCallType.setImageResource(R.mipmap.dial_in);
-        } else if (listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1).getType() == CallLog.Calls.OUTGOING_TYPE) { //呼出
+        } else if (callRecord.getType() == CallLog.Calls.OUTGOING_TYPE) { //呼出
             viewHolder.ivCallType.setImageResource(R.mipmap.dial_out);
-        } else if (listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1).getType() == CallLog.Calls.MISSED_TYPE) { //未接
+        } else if (callRecord.getType() == CallLog.Calls.MISSED_TYPE) { //未接
             viewHolder.ivCallType.setImageResource(R.mipmap.missed_call);
         }
-        viewHolder.tvName.setText(listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1).getName());
-        viewHolder.tvPhoneNum.setText(listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1).getPhoneNum());
-        viewHolder.tvDate.setText(listCallRecordList.get(position).get(listCallRecordList.get(position).size()-1).getDate());
+        viewHolder.tvName.setText(callRecord.getName());
+        viewHolder.tvPhoneNum.setText(callRecord.getPhoneNum());
+        viewHolder.tvDate.setText(PrivateSpaceUtils.formartDate(callRecord.getDate()));
         return convertView;
     }
 
diff --git a/src/com/transage/privatespace/adapter/PeopleListViewAdapter.java b/src/com/transage/privatespace/adapter/PeopleListViewAdapter.java
index 9d038a3..772dcbe 100755
--- a/src/com/transage/privatespace/adapter/PeopleListViewAdapter.java
+++ b/src/com/transage/privatespace/adapter/PeopleListViewAdapter.java
@@ -92,7 +92,7 @@ public class PeopleListViewAdapter extends BaseAdapter {
 			viewHolder.checkBox.setVisibility(View.GONE);
 		}
 		viewHolder.checkBox.setChecked(map_allCheckBoxSelectedStatus.get(position));
-		viewHolder.tvName.setText(listPrivatePeople.get(position).getName());
+		viewHolder.tvName.setText(listPrivatePeople.get(position).getDisplayName());
 		viewHolder.tvPhoneNum.setText(listPrivatePeople.get(position).getPhoneNum());
 		viewHolder.phoneButton.setOnClickListener(new View.OnClickListener() {
 			@Override
diff --git a/src/com/transage/privatespace/bean/CallRecord.java b/src/com/transage/privatespace/bean/CallRecord.java
index 8bc9344..efc032c 100755
--- a/src/com/transage/privatespace/bean/CallRecord.java
+++ b/src/com/transage/privatespace/bean/CallRecord.java
@@ -5,17 +5,26 @@ package com.transage.privatespace.bean;
  * 通话记录实体类
  */
 public class CallRecord {
-    String date;
-    String phoneNum;
-    String name;
-    int type;
-    int duration;
+    private int id;
+    private long date;
+    private String phoneNum;
+    private String name;
+    private int type;
+    private int duration;
 
-    public String getDate() {
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public long getDate() {
         return date;
     }
 
-    public void setDate(String date) {
+    public void setDate(long date) {
         this.date = date;
     }
 
@@ -50,4 +59,16 @@ public class CallRecord {
     public void setDuration(int duration) {
         this.duration = duration;
     }
+
+    @Override
+    public String toString() {
+        return "CallRecord{" +
+                "id=" + id +
+                ", date=" + date +
+                ", phoneNum='" + phoneNum + '\'' +
+                ", name='" + name + '\'' +
+                ", type=" + type +
+                ", duration=" + duration +
+                '}';
+    }
 }
diff --git a/src/com/transage/privatespace/bean/ContactInfo.java b/src/com/transage/privatespace/bean/ContactInfo.java
new file mode 100755
index 0000000..338085e
--- /dev/null
+++ b/src/com/transage/privatespace/bean/ContactInfo.java
@@ -0,0 +1,378 @@
+package com.transage.privatespace.bean;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.transage.privatespace.vcard.provider.Contacts;
+import com.transage.privatespace.vcard.pim.VDataBuilder;
+import com.transage.privatespace.vcard.pim.VNode;
+import com.transage.privatespace.vcard.pim.vcard.ContactStruct;
+import com.transage.privatespace.vcard.pim.vcard.ContactStruct.ContactMethod;
+import com.transage.privatespace.vcard.pim.vcard.ContactStruct.PhoneData;
+import com.transage.privatespace.vcard.pim.vcard.VCardComposer;
+import com.transage.privatespace.vcard.pim.vcard.VCardException;
+import com.transage.privatespace.vcard.pim.vcard.VCardParser;
+
+import android.app.Activity;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Environment;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.CommonDataKinds.Email;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredName;
+import android.provider.ContactsContract.RawContacts;
+import android.provider.ContactsContract.RawContacts.Data;
+import android.widget.Toast;
+
+/**
+ * 联系人信息包装类
+ * <p>
+ * Created by yanjie.xu on 2017/7/19.
+ */
+public class ContactInfo {
+
+    /**
+     * MUST exist
+     */
+    private String name; // 姓名
+
+    /**
+     * 联系人电话信息
+     */
+    public static class PhoneInfo {
+        /**
+         * 联系电话类型
+         */
+        public int type;
+        /**
+         * 联系电话
+         */
+        public String number;
+    }
+
+    /**
+     * 联系人邮箱信息
+     */
+    public static class EmailInfo {
+        /**
+         * 邮箱类型
+         */
+        public int type;
+        /**
+         * 邮箱
+         */
+        public String email;
+    }
+
+    private List<PhoneInfo> phoneList = new ArrayList<PhoneInfo>(); // 联系号码
+
+    private List<EmailInfo> email = new ArrayList<EmailInfo>(); // Email
+
+    /**
+     * 构造联系人信息
+     *
+     * @param name 联系人姓名
+     */
+    public ContactInfo(String name) {
+        this.name = name;
+    }
+
+    /**
+     * 姓名
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * 姓名
+     */
+    public ContactInfo setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    /**
+     * 联系电话信息
+     */
+    public List<PhoneInfo> getPhoneList() {
+        return phoneList;
+    }
+
+    /**
+     * 联系电话信息
+     */
+    public ContactInfo setPhoneList(List<PhoneInfo> phoneList) {
+        this.phoneList = phoneList;
+        return this;
+    }
+
+    /**
+     * 邮箱信息
+     */
+    public List<EmailInfo> getEmail() {
+        return email;
+    }
+
+    /**
+     * 邮箱信息
+     */
+    public ContactInfo setEmail(List<EmailInfo> email) {
+        this.email = email;
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "{name: " + name + ", number: " + phoneList + ", email: " + email + "}";
+    }
+
+
+    /**
+     * 联系人
+     * 备份/还原操作
+     *
+     * @author LW
+     */
+    public static class ContactHandler {
+        private static ContactHandler instance_ = new ContactHandler();
+
+        /**
+         * 获取实例
+         */
+        public static ContactHandler getInstance() {
+            return instance_;
+        }
+
+        /**
+         * 获取联系人指定信息
+         *
+         * @param projection 指定要获取的列数组, 获取全部列则设置为null
+         * @return
+         * @throws Exception
+         */
+
+        public Cursor queryContact(Activity context, String[] projection) {
+            // 获取联系人的所需信息
+            Cursor cur = context.getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, projection, null, null, null);
+            return cur;
+        }
+
+
+        /**
+         * 获取联系人信息
+         *
+         * @param context
+         * @return
+         */
+        public List<ContactInfo> getContactInfo(Activity context) {
+            List<ContactInfo> infoList = new ArrayList<ContactInfo>();
+            Cursor cur = queryContact(context, null);
+            if (cur.moveToFirst()) {
+                do {
+                    // 获取联系人id号
+                    String id = cur.getString(cur.getColumnIndex(ContactsContract.Contacts._ID));
+                    // 获取联系人姓名
+                    String displayName = cur.getString(cur.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
+                    ContactInfo info = new ContactInfo(displayName);// 初始化联系人信息
+                    // 查看联系人有多少电话号码, 如果没有返回0
+                    int phoneCount = cur.getInt(cur.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER));
+                    if (phoneCount > 0) {
+                        Cursor phonesCursor = context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + "=" + id, null, null);
+                        if (phonesCursor.moveToFirst()) {
+                            List<ContactInfo.PhoneInfo> phoneNumberList = new ArrayList<ContactInfo.PhoneInfo>();
+                            do {
+                                // 遍历所有电话号码
+                                String phoneNumber = phonesCursor.getString(phonesCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
+                                // 对应的联系人类型
+                                int type = phonesCursor.getInt(phonesCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE));
+                                // 初始化联系人电话信息
+                                ContactInfo.PhoneInfo phoneInfo = new ContactInfo.PhoneInfo();
+                                phoneInfo.type = type;
+                                phoneInfo.number = phoneNumber;
+                                phoneNumberList.add(phoneInfo);
+                            } while (phonesCursor.moveToNext());
+                            // 设置联系人电话信息
+                            info.setPhoneList(phoneNumberList);
+                        }
+                    }
+
+                    // 获得联系人的EMAIL
+                    Cursor emailCur = context.getContentResolver().query(ContactsContract.CommonDataKinds.Email.CONTENT_URI,
+                            null, ContactsContract.CommonDataKinds.Email.CONTACT_ID + "=" + id, null, null);
+                    if (emailCur.moveToFirst()) {
+                        List<ContactInfo.EmailInfo> emailList = new ArrayList<ContactInfo.EmailInfo>();
+                        do {
+                            // 遍历所有的email
+                            String email = emailCur.getString(emailCur.getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA1));
+                            int type = emailCur.getInt(emailCur.getColumnIndex(ContactsContract.CommonDataKinds.Email.TYPE));
+                            // 初始化联系人邮箱信息
+                            ContactInfo.EmailInfo emailInfo = new ContactInfo.EmailInfo();
+                            emailInfo.type = type;    // 设置邮箱类型
+                            emailInfo.email = email;    // 设置邮箱地址
+                            emailList.add(emailInfo);
+                        } while (emailCur.moveToNext());
+                        info.setEmail(emailList);
+                    }
+
+                    //Cursor postalCursor = getContentResolver().query(ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_URI, null, ContactsContract.CommonDataKinds.StructuredPostal.CONTACT_ID + "=" + id, null, null);
+                    infoList.add(info);
+
+                } while (cur.moveToNext());
+            }
+            return infoList;
+        }
+
+        /**
+         * 备份联系人
+         */
+        public void backupContacts(Activity context, List<ContactInfo> infos) {
+
+            try {
+                String path = Environment.getExternalStorageDirectory() + "/contacts.vcf";
+                OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(path), "UTF-8");
+                VCardComposer composer = new VCardComposer();
+                for (ContactInfo info : infos) {
+                    ContactStruct contact = new ContactStruct();
+                    contact.name = info.getName();
+                    // 获取联系人电话信息, 添加至 ContactStruct
+                    List<ContactInfo.PhoneInfo> numberList = info
+                            .getPhoneList();
+                    for (ContactInfo.PhoneInfo phoneInfo : numberList) {
+                        contact.addPhone(phoneInfo.type, phoneInfo.number, null, true);
+                    }
+                    // 获取联系人Email信息, 添加至 ContactStruct
+                    List<ContactInfo.EmailInfo> emailList = info.getEmail();
+                    for (ContactInfo.EmailInfo emailInfo : emailList) {
+                        contact.addContactmethod(Contacts.KIND_EMAIL, emailInfo.type, emailInfo.email, null, true);
+                    }
+                    String vcardString = composer.createVCard(contact, VCardComposer.VERSION_VCARD30_INT);
+                    writer.write(vcardString);
+                    writer.write("\n");
+                    writer.flush();
+                }
+                writer.close();
+            } catch (UnsupportedEncodingException e) {
+                e.printStackTrace();
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            } catch (VCardException e) {
+                e.printStackTrace();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            Toast.makeText(context, "备份成功！", Toast.LENGTH_SHORT).show();
+        }
+
+        /**
+         * 获取vCard文件中的联系人信息
+         *
+         * @return
+         */
+        public List<ContactInfo> restoreContacts() throws Exception {
+            List<ContactInfo> contactInfoList = new ArrayList<ContactInfo>();
+
+            VCardParser parse = new VCardParser();
+            VDataBuilder builder = new VDataBuilder();
+            String file = Environment.getExternalStorageDirectory() + "/contacts.vcf";
+            BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
+            String vcardString = "";
+            String line;
+            while ((line = reader.readLine()) != null) {
+                vcardString += line + "\n";
+            }
+            reader.close();
+            boolean parsed = parse.parse(vcardString, "UTF-8", builder);
+            if (!parsed) {
+                throw new VCardException("Could not parse vCard file: " + file);
+            }
+            List<VNode> pimContacts = builder.vNodeList;
+            for (VNode contact : pimContacts) {
+                ContactStruct contactStruct = ContactStruct.constructContactFromVNode(contact, 1);
+                // 获取备份文件中的联系人电话信息
+                List<PhoneData> phoneDataList = contactStruct.phoneList;
+                List<ContactInfo.PhoneInfo> phoneInfoList = new ArrayList<ContactInfo.PhoneInfo>();
+                for (PhoneData phoneData : phoneDataList) {
+                    ContactInfo.PhoneInfo phoneInfo = new ContactInfo.PhoneInfo();
+                    phoneInfo.number = phoneData.data;
+                    phoneInfo.type = phoneData.type;
+                    phoneInfoList.add(phoneInfo);
+                }
+                // 获取备份文件中的联系人邮箱信息
+                List<ContactMethod> emailList = contactStruct.contactmethodList;
+                List<ContactInfo.EmailInfo> emailInfoList = new ArrayList<ContactInfo.EmailInfo>();
+                // 存在 Email 信息
+                if (null != emailList) {
+                    for (ContactMethod contactMethod : emailList) {
+                        if (Contacts.KIND_EMAIL == contactMethod.kind) {
+                            ContactInfo.EmailInfo emailInfo = new ContactInfo.EmailInfo();
+                            emailInfo.email = contactMethod.data;
+                            emailInfo.type = contactMethod.type;
+                            emailInfoList.add(emailInfo);
+                        }
+                    }
+                }
+                ContactInfo info = new ContactInfo(contactStruct.name).setPhoneList(phoneInfoList).setEmail(emailInfoList);
+                contactInfoList.add(info);
+            }
+            return contactInfoList;
+        }
+
+        /**
+         * 向手机中录入联系人信息
+         *
+         * @param info 要录入的联系人信息
+         */
+        public void addContacts(Activity context, ContactInfo info) {
+            ContentValues values = new ContentValues();
+            //首先向RawContacts.CONTENT_URI执行一个空值插入，目的是获取系统返回的rawContactId
+            Uri rawContactUri = context.getContentResolver().insert(RawContacts.CONTENT_URI, values);
+            long rawContactId = ContentUris.parseId(rawContactUri);
+            //往data表入姓名数据
+            values.clear();
+            values.put(Data.RAW_CONTACT_ID, rawContactId);
+            values.put(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
+            values.put(StructuredName.GIVEN_NAME, info.getName());
+            context.getContentResolver().insert(android.provider.ContactsContract.Data.CONTENT_URI, values);
+            // 获取联系人电话信息
+            List<ContactInfo.PhoneInfo> phoneList = info.getPhoneList();
+            /** 录入联系电话 */
+            for (ContactInfo.PhoneInfo phoneInfo : phoneList) {
+                values.clear();
+                values.put(android.provider.ContactsContract.Contacts.Data.RAW_CONTACT_ID, rawContactId);
+                values.put(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);
+                // 设置录入联系人电话信息
+                values.put(Phone.NUMBER, phoneInfo.number);
+                values.put(Phone.TYPE, phoneInfo.type);
+                // 往data表入电话数据
+                context.getContentResolver().insert(android.provider.ContactsContract.Data.CONTENT_URI, values);
+
+            }
+            // 获取联系人邮箱信息
+            List<ContactInfo.EmailInfo> emailList = info.getEmail();
+            /** 录入联系人邮箱信息 */
+            for (ContactInfo.EmailInfo email : emailList) {
+                values.clear();
+                values.put(android.provider.ContactsContract.Contacts.Data.RAW_CONTACT_ID, rawContactId);
+                values.put(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE);
+                // 设置录入的邮箱信息
+                values.put(Email.DATA, email.email);
+                values.put(Email.TYPE, email.type);
+                // 往data表入Email数据
+                context.getContentResolver().insert(android.provider.ContactsContract.Data.CONTENT_URI, values);
+
+            }
+        }
+    }
+}
diff --git a/src/com/transage/privatespace/bean/People.java b/src/com/transage/privatespace/bean/People.java
index 721022e..e349647 100755
--- a/src/com/transage/privatespace/bean/People.java
+++ b/src/com/transage/privatespace/bean/People.java
@@ -6,7 +6,7 @@ package com.transage.privatespace.bean;
  */
 public class People {
     private int id;
-    private String name;
+    private String displayName;
     private String phoneNum;
     private int rawContactId;
 
@@ -18,12 +18,12 @@ public class People {
         this.id = id;
     }
 
-    public String getName() {
-        return name;
+    public String getDisplayName() {
+        return displayName;
     }
 
-    public void setName(String name) {
-        this.name = name;
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
     }
 
     public String getPhoneNum() {
@@ -41,4 +41,14 @@ public class People {
     public void setRawContactId(int rawContactId) {
         this.rawContactId = rawContactId;
     }
+
+    @Override
+    public String toString() {
+        return "People{" +
+                "id=" + id +
+                ", displayName='" + displayName + '\'' +
+                ", phoneNum='" + phoneNum + '\'' +
+                ", rawContactId=" + rawContactId +
+                '}';
+    }
 }
diff --git a/src/com/transage/privatespace/database/DatabaseAdapter.java b/src/com/transage/privatespace/database/DatabaseAdapter.java
index 4963660..4f0c939 100755
--- a/src/com/transage/privatespace/database/DatabaseAdapter.java
+++ b/src/com/transage/privatespace/database/DatabaseAdapter.java
@@ -7,11 +7,13 @@ import android.content.pm.PackageManager;
 import android.database.Cursor;
 
 import com.transage.privatespace.bean.AppInfo;
+import com.transage.privatespace.bean.CallRecord;
 import com.transage.privatespace.bean.People;
 import com.transage.privatespace.bean.Sms;
 
 import java.util.ArrayList;
 import java.util.List;
+
 import android.util.Log;
 
 /**
@@ -30,15 +32,17 @@ public class DatabaseAdapter {
         mDbHelper = PsDatabaseHelper.getInstance(context);
     }
 
-    /** App操作 */
-    public void addApp(AppInfo appInfo){
+    /**
+     * App操作
+     */
+    public void addApp(AppInfo appInfo) {
         ContentValues values = new ContentValues();
         values.put(PsDatabaseHelper.AppsColumns.APP_NAME, appInfo.getAppName());
         values.put(PsDatabaseHelper.AppsColumns.PACKAGE_NAME, appInfo.getPackageName());
         insert(PsDatabaseHelper.Tables.APPS, null, values);
     }
 
-    public List<AppInfo> getApps(PackageManager packageManager){
+    public List<AppInfo> getApps(PackageManager packageManager) {
         String sql = "SELECT " +
                 PsDatabaseHelper.AppsColumns._ID + "," +
                 PsDatabaseHelper.AppsColumns.APP_NAME + "," +
@@ -48,7 +52,7 @@ public class DatabaseAdapter {
         List<AppInfo> list = new ArrayList<>();
         Cursor cursor = query(sql, null);
         try {
-            while (cursor.moveToNext()){
+            while (cursor.moveToNext()) {
                 AppInfo appInfo = new AppInfo();
                 appInfo.setId(cursor.getInt(0));
                 appInfo.setAppName(cursor.getString(1));
@@ -64,7 +68,7 @@ public class DatabaseAdapter {
                 }
                 list.add(appInfo);
             }
-        } catch (Exception e){
+        } catch (Exception e) {
             e.printStackTrace();
         } finally {
             cursor.close();
@@ -79,7 +83,7 @@ public class DatabaseAdapter {
         delete(PsDatabaseHelper.Tables.APPS, whereClause, whereArgs);// 执行删除
     }
 
-    public boolean isExistsApp(ActivityInfo activityInfo){
+    public boolean isExistsApp(ActivityInfo activityInfo) {
         boolean isExitsts;
         String sql = "select * from " + PsDatabaseHelper.Tables.APPS +
                 " where " + PsDatabaseHelper.AppsColumns.PACKAGE_NAME + "=?";
@@ -89,20 +93,22 @@ public class DatabaseAdapter {
         return isExitsts;
     }
 
-    /** Contact操作 */
-    public void addContact(People people){
+    /**
+     * Contact操作
+     */
+    public void addContact(People people) {
         ContentValues values = new ContentValues();
         values.put(PsDatabaseHelper.ContactsColumns.RAWCONTACT_ID, people.getRawContactId());
-        values.put(PsDatabaseHelper.ContactsColumns.CONTACT_NAME, people.getName());
+        values.put(PsDatabaseHelper.ContactsColumns.CONTACT_NAME, people.getDisplayName());
         values.put(PsDatabaseHelper.ContactsColumns.CONTACT_NUMBER, people.getPhoneNum());
         insert(PsDatabaseHelper.Tables.CONTACTS, null, values);
     }
 
-    public void deleteContactsById(int id){
+    public void deleteContactsById(int id) {
         delete(PsDatabaseHelper.Tables.CONTACTS, PsDatabaseHelper.ContactsColumns._ID + "=?", new String[]{String.valueOf(id)});
     }
 
-    public List<People> getContacts(){
+    public List<People> getContacts() {
         String sql = "SELECT " +
                 PsDatabaseHelper.ContactsColumns._ID + "," +
                 PsDatabaseHelper.ContactsColumns.RAWCONTACT_ID + "," +
@@ -113,23 +119,26 @@ public class DatabaseAdapter {
         List<People> list = new ArrayList<>();
         Cursor cursor = query(sql, null);
         try {
-            while (cursor.moveToNext()){
+            while (cursor.moveToNext()) {
                 People people = new People();
                 people.setId(cursor.getInt(0));
                 people.setRawContactId(cursor.getInt(1));
-                people.setName(cursor.getString(2));
+                people.setDisplayName(cursor.getString(2));
                 people.setPhoneNum(cursor.getString(3));
                 list.add(people);
             }
-        } catch (Exception e){
+        } catch (Exception e) {
             e.printStackTrace();
         } finally {
             cursor.close();
         }
         return list;
     }
-    /** sms操作 20170707 add by wangmeng */
-    public void addSms(Sms sms){
+
+    /**
+     * sms操作 20170707 add by wangmeng
+     */
+    public void addSms(Sms sms) {
         ContentValues values = new ContentValues();
         values.put(PsDatabaseHelper.SmsColumns.THREAD_ID, sms.getThread_id());
         values.put(PsDatabaseHelper.SmsColumns.SMS_ADDRESS, sms.getAddress());
@@ -143,12 +152,13 @@ public class DatabaseAdapter {
         Log.e("wangmeng","===add===date: "+sms.getDate());
         Log.e("wangmeng","===add===type: "+sms.getType());*/
         insert(PsDatabaseHelper.Tables.SMS, null, values);
-
     }
-    public void deleteSmsByAddress(String  address){
+
+    public void deleteSmsByAddress(String address) {
         delete(PsDatabaseHelper.Tables.SMS, PsDatabaseHelper.SmsColumns.SMS_ADDRESS + "=?", new String[]{address});
     }
-    public List<Sms> getSms(){
+
+    public List<Sms> getSms() {
         String sql = "SELECT " +
                 PsDatabaseHelper.SmsColumns._ID + "," +
                 PsDatabaseHelper.SmsColumns.THREAD_ID + "," +
@@ -162,7 +172,7 @@ public class DatabaseAdapter {
         List<Sms> list = new ArrayList<>();
         Cursor cursor = query(sql, null);
         try {
-            while (cursor.moveToNext()){
+            while (cursor.moveToNext()) {
                 Sms sms = new Sms();
                 sms.setId(cursor.getInt(0));
                 sms.setThread_id(cursor.getInt(1));
@@ -173,28 +183,110 @@ public class DatabaseAdapter {
                 sms.setType(cursor.getInt(6));
                 list.add(sms);
             }
-        } catch (Exception e){
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            cursor.close();
+        }
+        return list;
+    }
+
+    /**
+     * CallRecord操作
+     */
+    public void addCallRecord(CallRecord callRecord) {
+        ContentValues values = new ContentValues();
+        values.put(PsDatabaseHelper.CallRecordClumns.DATE, Long.valueOf(callRecord.getDate()));
+        values.put(PsDatabaseHelper.CallRecordClumns.DURATION, Long.valueOf(callRecord.getDuration()));
+        values.put(PsDatabaseHelper.CallRecordClumns.NAME, callRecord.getName());
+        values.put(PsDatabaseHelper.CallRecordClumns.NUMBER, callRecord.getPhoneNum());
+        values.put(PsDatabaseHelper.CallRecordClumns.TYPE, Long.valueOf(callRecord.getType()));
+        insert(PsDatabaseHelper.Tables.CALLRECORD, null, values);
+    }
+
+    public void deleteCallRecordByNum(String number) {
+        delete(PsDatabaseHelper.Tables.CALLRECORD, PsDatabaseHelper.CallRecordClumns.NUMBER + "=?", new String[]{number.replaceAll(" ", "").trim()});
+    }
+
+    public List<CallRecord> getCallRecordsByNum(String phone) {
+        String sql = "SELECT " +
+                PsDatabaseHelper.CallRecordClumns._ID + "," +
+                PsDatabaseHelper.CallRecordClumns.NAME + "," +
+                PsDatabaseHelper.CallRecordClumns.NUMBER + "," +
+                PsDatabaseHelper.CallRecordClumns.DATE + "," +
+                PsDatabaseHelper.CallRecordClumns.DURATION + "," +
+                PsDatabaseHelper.CallRecordClumns.TYPE + " FROM " +
+                PsDatabaseHelper.Tables.CALLRECORD + " WHERE " +
+                PsDatabaseHelper.CallRecordClumns.NUMBER + "=?";
+        Log.i(TAG, "sql = " + sql);
+        List<CallRecord> list = new ArrayList<>();
+        Cursor cursor = query(sql, new String[]{phone});
+        try {
+            while (cursor.moveToNext()) {
+                CallRecord callRecord = new CallRecord();
+                callRecord.setId(cursor.getInt(0));
+                callRecord.setName(cursor.getString(1));
+                callRecord.setPhoneNum(cursor.getString(2));
+                callRecord.setDate(cursor.getLong(3));
+                callRecord.setDuration(cursor.getInt(4));
+                callRecord.setType(cursor.getInt(5));
+                list.add(callRecord);
+            }
+        } catch (Exception e) {
             e.printStackTrace();
         } finally {
             cursor.close();
         }
         return list;
     }
-    
-    /** 统一封装数据库接口 */
-    private long insert(String table, String nullColumnHack, ContentValues values){
+
+    public List<CallRecord> getCallRecords() {
+        String sql = "SELECT " +
+                PsDatabaseHelper.CallRecordClumns._ID + "," +
+                PsDatabaseHelper.CallRecordClumns.NAME + "," +
+                PsDatabaseHelper.CallRecordClumns.NUMBER + "," +
+                PsDatabaseHelper.CallRecordClumns.DATE + "," +
+                PsDatabaseHelper.CallRecordClumns.DURATION + "," +
+                PsDatabaseHelper.CallRecordClumns.TYPE +
+                " FROM " + PsDatabaseHelper.Tables.CALLRECORD;
+        Log.i(TAG, "sql = " + sql);
+        List<CallRecord> list = new ArrayList<>();
+        Cursor cursor = query(sql, null);
+        try {
+            while (cursor.moveToNext()) {
+                CallRecord callRecord = new CallRecord();
+                callRecord.setId(cursor.getInt(0));
+                callRecord.setName(cursor.getString(1));
+                callRecord.setPhoneNum(cursor.getString(2));
+                callRecord.setDate(cursor.getLong(3));
+                callRecord.setDuration(cursor.getInt(4));
+                callRecord.setType(cursor.getInt(5));
+                list.add(callRecord);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            cursor.close();
+        }
+        return list;
+    }
+
+    /**
+     * 统一封装数据库接口
+     */
+    private long insert(String table, String nullColumnHack, ContentValues values) {
         return PsDatabaseHelper.getInstance(mContext).getDatabase(true).insert(table, nullColumnHack, values);
     }
 
-    private Cursor query(String sql, String[] selectionArgs){
+    private Cursor query(String sql, String[] selectionArgs) {
         return PsDatabaseHelper.getInstance(mContext).getDatabase(true).rawQuery(sql, selectionArgs);
     }
 
-    private int update(String table, ContentValues values, String whereClause, String[] whereArgs){
+    private int update(String table, ContentValues values, String whereClause, String[] whereArgs) {
         return PsDatabaseHelper.getInstance(mContext).getDatabase(true).update(table, values, whereClause, whereArgs);
     }
 
-    private int delete(String table, String whereClause, String[] whereArgs){
+    private int delete(String table, String whereClause, String[] whereArgs) {
         return PsDatabaseHelper.getInstance(mContext).getDatabase(true).delete(table, whereClause, whereArgs);
     }
 }
diff --git a/src/com/transage/privatespace/database/PsDatabaseHelper.java b/src/com/transage/privatespace/database/PsDatabaseHelper.java
index bda022c..8cb00ca 100755
--- a/src/com/transage/privatespace/database/PsDatabaseHelper.java
+++ b/src/com/transage/privatespace/database/PsDatabaseHelper.java
@@ -10,7 +10,7 @@ import android.util.Log;
  * 本地数据库维护类
  */
 
-public class PsDatabaseHelper extends SQLiteOpenHelper{
+public class PsDatabaseHelper extends SQLiteOpenHelper {
     private static final String TAG = "PsDatabaseHelper";
     private final static int VERSION = 1;
     private final static String DB_NAME = "privatespace.db";
@@ -21,6 +21,7 @@ public class PsDatabaseHelper extends SQLiteOpenHelper{
         public static final String APPS = "apps";
         public static final String CONTACTS = "contacts";
         public static final String SMS = "sms";//wangmeng 20170707 add mms
+        public static final String CALLRECORD = "call_record";
     }
 
     public interface AppsColumns {
@@ -29,14 +30,15 @@ public class PsDatabaseHelper extends SQLiteOpenHelper{
         public static final String APP_NAME = "app_name";
     }
 
-    public interface ContactsColumns{
+    public interface ContactsColumns {
         public static final String _ID = "id";
         public static final String RAWCONTACT_ID = "rawcontact_id";
-        public static final String CONTACT_NAME = "contact_name";
+        public static final String CONTACT_NAME = "display_name";
         public static final String CONTACT_NUMBER = "contact_number";
     }
+
     //wangmeng 20170707 add mms
-    public interface SmsColumns{
+    public interface SmsColumns {
         public static final String _ID = "id";
         public static final String THREAD_ID = "thread_id";
         public static final String SMS_DATE = "sms_date";
@@ -46,6 +48,15 @@ public class PsDatabaseHelper extends SQLiteOpenHelper{
         public static final String SMS_BODY = "sms_body";
     }
 
+    public interface CallRecordClumns {
+        public static final String _ID = "id";
+        public static final String DATE = "date";
+        public static final String NUMBER = "number";
+        public static final String NAME = "name";
+        public static final String TYPE = "type";
+        public static final String DURATION = "duration";
+    }
+
     public PsDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
         super(context, name, factory, version);
         this.mContext = context;
@@ -67,6 +78,7 @@ public class PsDatabaseHelper extends SQLiteOpenHelper{
 
     /**
      * 创建数据表
+     *
      * @param sqLiteDatabase
      */
     private void createTable(SQLiteDatabase sqLiteDatabase) {
@@ -101,6 +113,18 @@ public class PsDatabaseHelper extends SQLiteOpenHelper{
                 ");";
         Log.i(TAG, "sql = " + sqlCreateSmsTable);
         sqLiteDatabase.execSQL(sqlCreateSmsTable);
+
+        //执行创建私密通话记录表
+        String sqlCreateCallRecordTable = "CREATE TABLE IF NOT EXISTS " + Tables.CALLRECORD + " (" +
+                CallRecordClumns._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
+                CallRecordClumns.DATE + " INTEGER, " +
+                CallRecordClumns.NUMBER + " TEXT, " +
+                CallRecordClumns.NAME + " TEXT, " +
+                CallRecordClumns.TYPE + " INTEGER, " +
+                CallRecordClumns.DURATION + " INTEGER " +
+                ");";
+        Log.i(TAG, "sql = " + sqlCreateCallRecordTable);
+        sqLiteDatabase.execSQL(sqlCreateCallRecordTable);
     }
 
     @Override
diff --git a/src/com/transage/privatespace/fragment/FG_PrivateCallRecords.java b/src/com/transage/privatespace/fragment/FG_PrivateCallRecords.java
index f266683..09e8b67 100755
--- a/src/com/transage/privatespace/fragment/FG_PrivateCallRecords.java
+++ b/src/com/transage/privatespace/fragment/FG_PrivateCallRecords.java
@@ -9,6 +9,7 @@ import android.provider.CallLog;
 import android.support.annotation.Nullable;
 import android.support.v4.app.ActivityCompat;
 import android.support.v4.app.Fragment;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -26,22 +27,23 @@ import com.transage.privatespace.utils.PrivateSpaceUtils;
 import java.sql.Date;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.List;
 import java.util.Locale;
 
 /**
  * Created by dongrp on 2016/9/1.
  */
 public class FG_PrivateCallRecords extends Fragment {
+    private static final String TAG = "FG_PrivateCallRecords";
     private View view;
     private CallRecordListViewAdapter callRecordListViewAdapter;
-    private ArrayList<ArrayList<CallRecord>> listCallRecordList = new ArrayList<ArrayList<CallRecord>>(); // 该list存放每个私密联系人的通话记录
-
+//    private ArrayList<ArrayList<CallRecord>> listCallRecordList = new ArrayList<ArrayList<CallRecord>>(); // 该list存放每个私密联系人的通话记录
+    private List<CallRecord> list_callRecord = new ArrayList<>();
     @Nullable
     @Override
     public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
         view = inflater.inflate(R.layout.fragment_call_records, null);
         return view;
-
     }
 
     @Override
@@ -56,13 +58,12 @@ public class FG_PrivateCallRecords extends Fragment {
      */
     private void initViewAndAdapter() {
         ListView listView = (ListView) view.findViewById(R.id.listViewCallRecord);
-        callRecordListViewAdapter = new CallRecordListViewAdapter(getActivity(), listCallRecordList);
+        callRecordListViewAdapter = new CallRecordListViewAdapter(getActivity(), list_callRecord);
         listView.setAdapter(callRecordListViewAdapter);
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
             public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-                PeopleListViewAdapter.callPhoneOrSendSms(getActivity(), 1, listCallRecordList.get(position).get(0)
-                        .getPhoneNum());
+                PeopleListViewAdapter.callPhoneOrSendSms(getActivity(), 1, list_callRecord.get(position).getPhoneNum());
             }
         });
     }
@@ -71,49 +72,64 @@ public class FG_PrivateCallRecords extends Fragment {
      * 初始化数据
      */
     public void initData() {
-        // 1.先获取到所有私密联系人
-        ArrayList<People> listPrivatePeople = new ArrayList<People>();
-        listPrivatePeople.addAll(new DatabaseAdapter(getContext()).getContacts());
-        // 2.根据私密联系人获取通话记录
-        listCallRecordList.clear();
-        // 检查并申请 READ_CALL_LOG 权限
-        if (ActivityCompat.checkSelfPermission(getActivity(), Manifest.permission.READ_CALL_LOG) != PackageManager.PERMISSION_GRANTED) {
-            ActivityCompat.requestPermissions(getActivity(), new String[] { Manifest.permission.READ_CALL_LOG }, 1);
-            return;
-        }
-
-        ContentResolver resolver = getActivity().getContentResolver();
-        String projection[] = new String[] { CallLog.Calls.DATE, CallLog.Calls.NUMBER, CallLog.Calls.TYPE,
-                CallLog.Calls.DURATION };
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm", Locale.getDefault());
-
-        for (int i = 0; i < listPrivatePeople.size(); i++) {
-            String phone = listPrivatePeople.get(i).getPhoneNum();
-            if (phone != null){
-                Cursor recordCursor = resolver.query(CallLog.Calls.CONTENT_URI, projection, "number=?",
-                        new String[] { listPrivatePeople.get(i).getPhoneNum() }, CallLog.Calls.DATE);
-                if (recordCursor != null && recordCursor.moveToFirst()) {
-                    ArrayList<CallRecord> callRecordsList = new ArrayList<CallRecord>();
-                    do {
-                        String date = simpleDateFormat.format(new Date(recordCursor.getLong(recordCursor
-                                .getColumnIndex(CallLog.Calls.DATE))));
-                        String phoneNum = recordCursor.getString(recordCursor.getColumnIndex(CallLog.Calls.NUMBER));
-                        int type = recordCursor.getInt(recordCursor.getColumnIndex(CallLog.Calls.TYPE));
-                        int duration = recordCursor.getInt(recordCursor.getColumnIndex(CallLog.Calls.DURATION));
-                        // 添加数据到list
-                        CallRecord callRecord = new CallRecord();
-                        callRecord.setDate(date);
-                        callRecord.setPhoneNum(phoneNum);
-                        callRecord.setName(listPrivatePeople.get(i).getName());
-                        callRecord.setType(type);
-                        callRecord.setDuration(duration);
-                        callRecordsList.add(callRecord);
-                    } while (recordCursor.moveToNext());
-                    listCallRecordList.add(callRecordsList);
-                    recordCursor.close();
-                }
-            }
-        }
+        list_callRecord.clear();
+        list_callRecord.addAll(new DatabaseAdapter(getActivity()).getCallRecords());
+//        // 1.先获取到所有私密联系人
+//        ArrayList<People> listPrivatePeople = new ArrayList<People>();
+//        listPrivatePeople.addAll(new DatabaseAdapter(getContext()).getContacts());
+//        // 2.根据私密联系人获取通话记录
+//        listCallRecordList.clear();
+//        // 检查并申请 READ_CALL_LOG 权限
+//        if (ActivityCompat.checkSelfPermission(getActivity(), Manifest.permission.READ_CALL_LOG) != PackageManager.PERMISSION_GRANTED) {
+//            ActivityCompat.requestPermissions(getActivity(), new String[] { Manifest.permission.READ_CALL_LOG }, 1);
+//            return;
+//        }
+//
+//        ContentResolver resolver = getActivity().getContentResolver();
+//
+//        for (int i = 0; i < listPrivatePeople.size(); i++) {
+//            String phone = listPrivatePeople.get(i).getPhoneNum();
+//            Log.i(TAG, listPrivatePeople.get(i).toString());
+//            if (phone != null){
+//                *
+//                 * @param uri 需要查询的URI，（这个URI是ContentProvider提供的）努力了
+//                 * @param projection 需要查询的字段
+//                 * @param selection sql语句where之后的语句
+//                 * @param selectionArgs ?占位符代表的数据
+//                 * @param sortOrder 排序方式
+//
+//                Cursor recordCursor = resolver.query(CallLog.Calls.CONTENT_URI, // 查询通话记录的URI
+//                        new String[] { CallLog.Calls.CACHED_NAME// 通话记录的联系人
+//                                , CallLog.Calls.NUMBER// 通话记录的电话号码
+//                                , CallLog.Calls.DATE// 通话记录的日期
+//                                , CallLog.Calls.DURATION// 通话时长
+//                                , CallLog.Calls.TYPE }// 通话类型
+//                        , CallLog.Calls.CACHED_FORMATTED_NUMBER + "= ?", new String[]{phone}, CallLog.Calls.DEFAULT_SORT_ORDER// 按照时间逆序排列，最近打的最先显示
+//                );
+//                if (recordCursor != null && recordCursor.moveToFirst()) {
+//                    ArrayList<CallRecord> callRecordsList = new ArrayList<CallRecord>();
+//                    while (recordCursor.moveToNext()) {
+//                        String name = recordCursor.getString(0);
+//                        String phoneNum = recordCursor.getString(1);
+//                        long date = recordCursor.getLong(2);
+//                        int duration = recordCursor.getInt(3);
+//                        int type = recordCursor.getInt(4);
+//
+//                        // 添加数据到list
+//                        CallRecord callRecord = new CallRecord();
+//                        callRecord.setDate(date);
+//                        callRecord.setPhoneNum(phoneNum);
+//                        callRecord.setName(name);
+//                        callRecord.setType(type);
+//                        callRecord.setDuration(duration);
+//                        Log.i(TAG, callRecord.toString());
+//                        callRecordsList.add(callRecord);
+//                    }
+//                    listCallRecordList.add(callRecordsList);
+//                    recordCursor.close();
+//                }
+//            }
+//        }
 
     }
 
diff --git a/src/com/transage/privatespace/fragment/FG_PrivatePeople.java b/src/com/transage/privatespace/fragment/FG_PrivatePeople.java
index d36b27f..e1326f0 100755
--- a/src/com/transage/privatespace/fragment/FG_PrivatePeople.java
+++ b/src/com/transage/privatespace/fragment/FG_PrivatePeople.java
@@ -172,7 +172,7 @@ public class FG_PrivatePeople extends Fragment implements AdapterView.OnItemClic
                     }
                     //将listSelectedPeople中的联系人解除私密
 //                    AddPeople.setPrivateContacts(listSelectedPeople, 0, getActivity().getContentResolver());
-                    PrivateSpaceUtils.setPrivateContacts(listSelectedPeople, 0, getActivity());
+                    PrivateSpaceUtils.executePrivateContacts(listSelectedPeople, 0, getActivity());
                     isShowCheckBox = false;
                     // 给floatActionButton添加属性翻转动画
                     ObjectAnimator.ofFloat(floatActionButton, "rotationY", 0.0F, -180.0F).setDuration(500).start();
diff --git a/src/com/transage/privatespace/fragment/FG_PrivateSms.java b/src/com/transage/privatespace/fragment/FG_PrivateSms.java
index 361e657..19e4df5 100755
--- a/src/com/transage/privatespace/fragment/FG_PrivateSms.java
+++ b/src/com/transage/privatespace/fragment/FG_PrivateSms.java
@@ -2,8 +2,6 @@ package com.transage.privatespace.fragment;
 
 import android.Manifest;
 import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.net.Uri;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -14,15 +12,13 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
+
 import com.transage.privatespace.R;
 import com.transage.privatespace.adapter.SmsListViewAdapter;
-import com.transage.privatespace.bean.People;
 import com.transage.privatespace.bean.Sms;
 import com.transage.privatespace.database.DatabaseAdapter;
-import java.sql.Date;
-import java.text.SimpleDateFormat;
+
 import java.util.ArrayList;
-import java.util.Locale;
 
 /**
  * Created by dongrp on 2016/9/1.
@@ -31,6 +27,7 @@ public class FG_PrivateSms extends Fragment {
     private View view;
     private ArrayList<Sms> listSmslist = new ArrayList<Sms>();
     private SmsListViewAdapter smsListViewAdapter;
+
     //private DatabaseAdapter mDb;
     @Nullable
     @Override
@@ -56,7 +53,7 @@ public class FG_PrivateSms extends Fragment {
     //READ_SMS权限申请结果的回调方法
     @Override
     public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-        if (requestCode == 1 && grantResults.length > 0 && grantResults[0]==PackageManager.PERMISSION_GRANTED){
+        if (requestCode == 1 && grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
             initData();
             initViewAndAdapter();
         }
@@ -78,6 +75,39 @@ public class FG_PrivateSms extends Fragment {
     public void initData() {
         listSmslist.clear();
         listSmslist.addAll(new DatabaseAdapter(getActivity()).getSms());
+//        // 1.先获取到所有私密联系人
+//        ArrayList<People> listPrivatePeople = new ArrayList<People>();
+//        listPrivatePeople.addAll(new DatabaseAdapter(getContext()).getContacts());
+//
+//        // 2.获取私密联系人的短信记录
+//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm", Locale.getDefault());
+//        String[] projection = new String[]{"_id", "address", "person", "body", "date", "type"};
+//        for (int i = 0; i < listPrivatePeople.size(); i++) {
+//            String phone = listPrivatePeople.get(i).getPhoneNum();
+//            if (phone != null){
+//                Cursor cursor2 = getActivity().getContentResolver().query(Uri.parse("content://sms/"), projection,
+//                        "address=?", new String[]{phone}, "date desc");
+//                if (cursor2 != null && cursor2.moveToFirst()) {
+//                    ArrayList<Sms> listSms = new ArrayList<Sms>();
+//                    do {
+//                        String address = cursor2.getString(cursor2.getColumnIndex("address"));// 手机号码
+//                        String body = cursor2.getString(cursor2.getColumnIndex("body"));// 短信内容
+//                        String date = simpleDateFormat.format(new Date(cursor2.getLong(cursor2.getColumnIndex("date"))));// 收发时间
+//                        int type = cursor2.getInt(cursor2.getColumnIndex("type"));// 收发类型
+//                        // 添加一条短息数据到listSms
+//                        Sms sms = new Sms();
+//                        sms.setAddress(address);
+//                        sms.setPerson(listPrivatePeople.get(i).getDisplayName());
+//                        sms.setBody(body);
+//                        sms.setDate(date);
+//                        sms.setType(type);
+//                        listSms.add(sms);
+//                    } while (cursor2.moveToNext());
+//                    listSmslist.add(listSms);
+//                    cursor2.close();
+//                }
+//            }
+//        }
     }
 //    public void initData() {
 //        // 1.先获取到所有私密联系人
diff --git a/src/com/transage/privatespace/utils/ImportExportUtils.java b/src/com/transage/privatespace/utils/ImportExportUtils.java
new file mode 100755
index 0000000..05bc74f
--- /dev/null
+++ b/src/com/transage/privatespace/utils/ImportExportUtils.java
@@ -0,0 +1,125 @@
+package com.transage.privatespace.utils;
+
+import android.os.Environment;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.transage.privatespace.vcard.provider.Contacts;
+import com.transage.privatespace.vcard.pim.PropertyNode;
+import com.transage.privatespace.vcard.pim.VDataBuilder;
+import com.transage.privatespace.vcard.pim.VNode;
+import com.transage.privatespace.vcard.pim.vcard.ContactStruct;
+import com.transage.privatespace.vcard.pim.vcard.VCardComposer;
+import com.transage.privatespace.vcard.pim.vcard.VCardException;
+import com.transage.privatespace.vcard.pim.vcard.VCardParser;
+
+/**
+ * Created by yanjie.xu on 2017/7/19.
+ */
+
+public class ImportExportUtils {
+    //run the WriteExample first or provide your own "example.vcard"
+
+    public static void readData() throws Exception {
+
+        VCardParser parser = new VCardParser();
+        VDataBuilder builder = new VDataBuilder();
+
+        String file = "example.vcard";
+
+        //read whole file to string
+        BufferedReader reader = new BufferedReader(new InputStreamReader(
+                new FileInputStream(file), "UTF-8"));
+
+        String vcardString = "";
+        String line;
+        while ((line = reader.readLine()) != null) {
+            vcardString += line + "\n";
+        }
+        reader.close();
+
+        //parse the string
+        boolean parsed = parser.parse(vcardString, "UTF-8", builder);
+        if (!parsed) {
+            throw new VCardException("Could not parse vCard file: " + file);
+        }
+
+        //get all parsed contacts
+        List<VNode> pimContacts = builder.vNodeList;
+
+        //do something for all the contacts
+        for (VNode contact : pimContacts) {
+            ArrayList<PropertyNode> props = contact.propList;
+
+            //contact name - FN property
+            String name = null;
+            for (PropertyNode prop : props) {
+                if ("FN".equals(prop.propName)) {
+                    name = prop.propValue;
+                    //we have the name now
+                    break;
+                }
+            }
+
+            //similarly for other properties (N, ORG, TEL, etc)
+            //...
+
+            System.out.println("Found contact: " + name);
+        }
+
+    }
+
+    public static void writeData() throws Exception {
+        OutputStreamWriter writer;
+        File file = new File(Environment.getExternalStorageDirectory(), "xuyanjie.vcf");
+        //得到存储卡的根路径，将example.vcf写入到根目录下
+        writer = new OutputStreamWriter(new FileOutputStream(file), "UTF-8");
+
+        //create a contact
+        VCardComposer composer = new VCardComposer();
+        ContactStruct contact1 = new ContactStruct();
+        contact1.name = "John";
+        contact1.company = "The Company";
+        contact1.addPhone(Contacts.Phones.TYPE_MOBILE, "15651865008", null, true);
+        //create vCard representation
+        String vcardString;
+        vcardString = composer.createVCard(contact1, VCardComposer.VERSION_VCARD30_INT);
+        //write vCard to the output stream
+        writer.write(vcardString);
+
+        // writer.write("/n"); //add empty lines between contacts
+        // repeat for other contacts
+        // ...
+        writer.close();
+
+//            OutputStreamWriter writer = new OutputStreamWriter(
+//                new FileOutputStream("example.vcard"), "UTF-8");
+//
+//        VCardComposer composer = new VCardComposer();
+//
+//        //create a contact
+//        ContactStruct contact1 = new ContactStruct();
+//        contact1.name = "Neo";
+//        contact1.company = "The Company";
+//        contact1.addPhone(Contacts.Phones.TYPE_MOBILE, "+123456789", null, true);
+//
+//        //create vCard representation
+//        String vcardString = composer.createVCard(contact1, VCardComposer.VERSION_VCARD30_INT);
+//
+//        //write vCard to the output stream
+//        writer.write(vcardString);
+//        writer.write("\n"); //add empty lines between contacts
+//
+//        // repeat for other contacts
+//        // ...
+//
+//        writer.close();
+    }
+}
diff --git a/src/com/transage/privatespace/utils/PrivateSpaceUtils.java b/src/com/transage/privatespace/utils/PrivateSpaceUtils.java
index be823b0..31e52d4 100755
--- a/src/com/transage/privatespace/utils/PrivateSpaceUtils.java
+++ b/src/com/transage/privatespace/utils/PrivateSpaceUtils.java
@@ -1,27 +1,38 @@
 package com.transage.privatespace.utils;
 
+import android.Manifest;
 import android.app.Activity;
 import android.content.ContentProviderOperation;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.net.Uri;
+import android.provider.CallLog;
 import android.provider.ContactsContract;
 import android.util.Log;
+import android.support.v4.app.ActivityCompat;
+import android.content.ContentValues;
 
+import com.transage.privatespace.bean.CallRecord;
 import com.transage.privatespace.bean.People;
 import com.transage.privatespace.bean.Sms;
 import com.transage.privatespace.database.DatabaseAdapter;
 
-import java.sql.Date;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.Locale;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
 /**
  * Created by yanjie.xu on 2017/7/6.
  */
 
 public class PrivateSpaceUtils {
+    private static final String TAG = "PrivateSpaceUtils";
 
     /**
      * 设置私密联系人
@@ -30,94 +41,176 @@ public class PrivateSpaceUtils {
      * @param isPrivate           ：1表示加为私密 ，0表示解除私密
      * @param activity            ：内容解析者
      */
-    public static void setPrivateContacts(ArrayList<People> list_selectedPeople, int isPrivate, Activity activity) {
+    public static void executePrivateContacts(ArrayList<People> list_selectedPeople, int isPrivate, Activity activity) {
+        DatabaseAdapter databaseAdapter = new DatabaseAdapter(activity);
         for (People people : list_selectedPeople) {
             if (isPrivate == 0) {
+                //还原联系人到系统中
                 addContacts2Db(activity, people);
                 //删除私密联系人
                 new DatabaseAdapter(activity).deleteContactsById(people.getId());
                 //删除私密短信
                 new DatabaseAdapter(activity).deleteSmsByAddress(people.getPhoneNum());
+                databaseAdapter.deleteContactsById(people.getId());
+
+                //批量插入通话记录
+                batchAddCallLogs(activity, databaseAdapter.getCallRecordsByNum(people.getPhoneNum()));
+                //删除通话记录
+                databaseAdapter.deleteCallRecordByNum(people.getPhoneNum());
             }
 
             if (isPrivate == 1) {
                 //添加联系人到私密
-                new DatabaseAdapter(activity).addContact(people);
+                databaseAdapter.addContact(people);
                 //删除联系人元数据
                 activity.getContentResolver().delete(ContactsContract.RawContacts.CONTENT_URI,
                         ContactsContract.Data._ID + "=?",
                         new String[]{String.valueOf(people.getRawContactId())});
                 //添加短信到私密 add by wangmeng 20170707
-                addSmstoPrivate(activity,people);
+                addSmstoPrivate(activity, people);
+
+                optionPrivateCallLog(list_selectedPeople, activity);
+            }
+        }
+
+    }
+
+    public static void optionPrivateCallLog(ArrayList<People> list_selectedPeople, Activity activity) {
+        DatabaseAdapter databaseAdapter = new DatabaseAdapter(activity);
+        ArrayList<CallRecord> callRecords = getCallRecordsFromContectsProvider(list_selectedPeople, activity);
+        if (callRecords != null && !callRecords.isEmpty()) {
+            for (CallRecord callRecord : callRecords) {
+                Log.i(TAG, "add callLog" + callRecord.toString());
+                //添加通话记录到私密
+                databaseAdapter.addCallRecord(callRecord);
+                //删除通话记录到私密
+                activity.getContentResolver().delete(CallLog.Calls.CONTENT_URI, CallLog.Calls.NUMBER + "=?", new String[]{callRecord.getPhoneNum()});
+            }
+        }
+
+    }
+
+    private static ArrayList<CallRecord> getCallRecordsFromContectsProvider(ArrayList<People> list_selectedPeople, Activity activity) {
+        // 检查并申请 READ_CALL_LOG 权限
+        if (ActivityCompat.checkSelfPermission(activity, Manifest.permission.WRITE_CALL_LOG) != PackageManager.PERMISSION_GRANTED) {
+            ActivityCompat.requestPermissions(activity, new String[]{Manifest.permission.WRITE_CALL_LOG}, 1);
+            return null;
+        }
+        ArrayList<CallRecord> callRecordsList = new ArrayList<CallRecord>();
+        ContentResolver resolver = activity.getContentResolver();
 
+        for (int i = 0; i < list_selectedPeople.size(); i++) {
+            String phone = list_selectedPeople.get(i).getPhoneNum();
+            Log.i(TAG, list_selectedPeople.get(i).toString());
+            if (phone != null) {
+                /**
+                 * @param uri 需要查询的URI，（这个URI是ContentProvider提供的）努力了
+                 * @param projection 需要查询的字段
+                 * @param selection sql语句where之后的语句
+                 * @param selectionArgs ?占位符代表的数据
+                 * @param sortOrder 排序方式
+                 */
+                Cursor recordCursor = resolver.query(CallLog.Calls.CONTENT_URI, // 查询通话记录的URI
+                        new String[]{CallLog.Calls._ID,
+                                CallLog.Calls.CACHED_NAME,// 通话记录的联系人
+                                CallLog.Calls.NUMBER,// 通话记录的电话号码
+                                CallLog.Calls.DATE,// 通话记录的日期
+                                CallLog.Calls.DURATION,// 通话时长
+                                CallLog.Calls.TYPE}// 通话类型
+                        , CallLog.Calls.NUMBER + "= ?",
+                        new String[]{phone.replaceAll(" ", "").trim()},
+                        CallLog.Calls.DEFAULT_SORT_ORDER// 按照时间逆序排列，最近打的最先显示
+                );
+                if (recordCursor != null && recordCursor.moveToFirst()) {
+                    while (recordCursor.moveToNext()) {
+                        int callLogId = recordCursor.getInt(0);
+                        String name = recordCursor.getString(1);
+                        String phoneNum = recordCursor.getString(2);
+                        long date = recordCursor.getLong(3);
+                        int duration = recordCursor.getInt(4);
+                        int type = recordCursor.getInt(5);
+
+                        // 添加数据到list
+                        CallRecord callRecord = new CallRecord();
+                        callRecord.setDate(date);
+                        callRecord.setPhoneNum(phoneNum);
+                        callRecord.setName(name);
+                        callRecord.setType(type);
+                        callRecord.setDuration(duration);
+                        callRecordsList.add(callRecord);
+                    }
+                    recordCursor.close();
+                }
             }
         }
 
+        return callRecordsList;
     }
 
-//添加短信到私密 add by wangmeng 20170707
-public static void addSmstoPrivate(Activity activity, People phone) {
+    //添加短信到私密 add by wangmeng 20170707
+    public static void addSmstoPrivate(Activity activity, People phone) {
         // 1.先获取到所有私密联系人
 //        ArrayList<People> listPrivatePeople = new ArrayList<People>();
 //        listPrivatePeople.addAll(new DatabaseAdapter(activity).getContacts());
-    //Log.e("wangmeng","=====111111111========>");
+        //Log.e("wangmeng","=====111111111========>");
         // 2.获取私密联系人的短信记录
         SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm", Locale.getDefault());
-        String[] projection = new String[]{"_id","thread_id", "address", "person", "body", "date", "type"};
+        String[] projection = new String[]{"_id", "thread_id", "address", "person", "body", "date", "type"};
 //        for (int i = 0; i < listPrivatePeople.size(); i++) {
 //            String phone = listPrivatePeople.get(i).getPhoneNum();
-            if (phone != null){
-                //Log.e("wangmeng","=====222222222========>");
-                Cursor cursor2 = activity.getContentResolver().query(Uri.parse("content://sms/"), projection,
-                        "address=?", new String[]{phone.getPhoneNum()}, "date desc");
-                if (cursor2 != null && cursor2.moveToFirst()) {
-                   // ArrayList<Sms> listSms = new ArrayList<Sms>();
-                    do {
-                        //Log.e("wangmeng","=====333333========>");
-                        int id = cursor2.getInt(cursor2.getColumnIndex("_id"));
-                        long threadId = cursor2.getLong(cursor2.getColumnIndex("thread_id"));
-                        String address = cursor2.getString(cursor2.getColumnIndex("address"));// 手机号码
-                        String body = cursor2.getString(cursor2.getColumnIndex("body"));// 短信内容
-                        String date = simpleDateFormat.format(new Date(cursor2.getLong(cursor2.getColumnIndex("date"))));// 收发时间
-                        int type = cursor2.getInt(cursor2.getColumnIndex("type"));// 收发类型
+        if (phone != null) {
+            //Log.e("wangmeng","=====222222222========>");
+            Cursor cursor2 = activity.getContentResolver().query(Uri.parse("content://sms/"), projection,
+                    "address=?", new String[]{phone.getPhoneNum()}, "date desc");
+            if (cursor2 != null && cursor2.moveToFirst()) {
+                // ArrayList<Sms> listSms = new ArrayList<Sms>();
+                do {
+                    //Log.e("wangmeng","=====333333========>");
+                    int id = cursor2.getInt(cursor2.getColumnIndex("_id"));
+                    long threadId = cursor2.getLong(cursor2.getColumnIndex("thread_id"));
+                    String address = cursor2.getString(cursor2.getColumnIndex("address"));// 手机号码
+                    String body = cursor2.getString(cursor2.getColumnIndex("body"));// 短信内容
+                    String date = simpleDateFormat.format(new Date(cursor2.getLong(cursor2.getColumnIndex("date"))));// 收发时间
+                    int type = cursor2.getInt(cursor2.getColumnIndex("type"));// 收发类型
                         /*Log.e("wangmeng","======threadId: "+threadId);
                         Log.e("wangmeng","======address: "+address);
                         Log.e("wangmeng","======body: "+body);
                         Log.e("wangmeng","======date: "+date);
                         Log.e("wangmeng","======type: "+type);*/
-                        // 添加一条短息数据到listSms
-                        Sms sms = new Sms();
-                        sms.setId(id);
-                        sms.setThread_id(threadId);
-                        sms.setAddress(address);
-                        sms.setPerson(phone.getName());
-                        sms.setBody(body);
-                        sms.setDate(date);
-                        sms.setType(type);
-
-                        new DatabaseAdapter(activity).addSms(sms);
-                        //activity.getContentResolver().delete(Uri.parse("content://sms/"), "_id=" + id, null);
+                    // 添加一条短息数据到listSms
+                    Sms sms = new Sms();
+                    sms.setId(id);
+                    sms.setThread_id(threadId);
+                    sms.setAddress(address);
+                    sms.setPerson(phone.getDisplayName());
+                    sms.setBody(body);
+                    sms.setDate(date);
+                    sms.setType(type);
+
+                    new DatabaseAdapter(activity).addSms(sms);
+                    //activity.getContentResolver().delete(Uri.parse("content://sms/"), "_id=" + id, null);
                      /*   activity.getContentResolver().delete(Uri.parse("content://sms/"),
                                   "address =" + address,
                                 null);*/
-                           activity.getContentResolver().delete(Uri.parse("content://mms-sms/"), "address = ?",new String[]{address});
+                    activity.getContentResolver().delete(Uri.parse("content://mms-sms/"), "address = ?", new String[]{address});
 
-                       // Log.e("wangmeng","=============>");
-                       // listSms.add(sms);
-                    } while (cursor2.moveToNext());
-                    cursor2.close();
-                }
+                    // Log.e("wangmeng","=============>");
+                    // listSms.add(sms);
+                } while (cursor2.moveToNext());
+                cursor2.close();
             }
+        }
 //        }
 
 
-}
+    }
+
     /**
      * 添加联系人
      * 在同一个事务中完成联系人各项数据的添加
      * 使用ArrayList<ContentProviderOperation>，把每步操作放在它的对象中执行
-     * */
-    private static void addContacts2Db(Context context, People people){
+     */
+    private static void addContacts2Db(Context context, People people) {
         Uri uri = Uri.parse("content://com.android.contacts/raw_contacts");
         ContentResolver resolver = context.getContentResolver();
         // 第一个参数：内容提供者的主机名
@@ -136,7 +229,7 @@ public static void addSmstoPrivate(Activity activity, People phone) {
                 // 所以能够将上一个操作返回的raw_contact_id作为该方法的参数
                 .withValueBackReference("raw_contact_id", 0)
                 .withValue("mimetype", "vnd.android.cursor.item/name")
-                .withValue("data2", people.getName())
+                .withValue("data2", people.getDisplayName())
                 .build();
 
         // 操作3.添加data表中phone字段
@@ -167,4 +260,46 @@ public static void addSmstoPrivate(Activity activity, People phone) {
             e.printStackTrace();
         }
     }
+
+    /**
+     * 批量添加通话记录到联系人
+     *
+     * @param list
+     * @throws RemoteException
+     * @throws OperationApplicationException
+     */
+    private static void batchAddCallLogs(Context context, List<CallRecord> list) {
+        ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
+        ContentValues values = new ContentValues();
+        for (CallRecord callRecord : list) {
+            values.clear();
+            values.put(CallLog.Calls.CACHED_NAME, callRecord.getName());
+            values.put(CallLog.Calls.NUMBER, callRecord.getPhoneNum());
+            values.put(CallLog.Calls.TYPE, callRecord.getType());
+            values.put(CallLog.Calls.DATE, callRecord.getDate());
+            values.put(CallLog.Calls.DURATION, callRecord.getDuration());
+            values.put(CallLog.Calls.NEW, "0");// 0已看1未看 ,由于没有获取默认全为已读
+            ops.add(ContentProviderOperation
+                    .newInsert(CallLog.Calls.CONTENT_URI).withValues(values)
+                    .withYieldAllowed(true).build());
+        }
+        if (ops != null) {
+            try {
+                // 真正添加
+                /*ContentProviderResult[] results = */
+                context.getContentResolver().applyBatch(CallLog.AUTHORITY, ops);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static ExecutorService getThreadPool() {
+        return Executors.newCachedThreadPool();
+    }
+
+    public static String formartDate(long date) {
+        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm", Locale.getDefault());
+        return simpleDateFormat.format(new Date(date));
+    }
 }
diff --git a/src/com/transage/privatespace/vcard/content/ContentValues.java b/src/com/transage/privatespace/vcard/content/ContentValues.java
new file mode 100755
index 0000000..481f8a7
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/content/ContentValues.java
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.content;
+
+//import android.os.Parcel;
+//import android.os.Parcelable;
+import com.transage.privatespace.vcard.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * This class is used to store a set of values that the {@link ContentResolver}
+ * can process.
+ */
+public final class ContentValues { //implements Parcelable {
+    public static final String TAG = "ContentValues";
+
+    /** Holds the actual values */
+    private HashMap<String, Object> mValues;
+
+    /**
+     * Creates an empty set of values using the default initial size
+     */
+    public ContentValues() {
+        // Choosing a default size of 8 based on analysis of typical 
+        // consumption by applications.
+        mValues = new HashMap<String, Object>(8);
+    }
+
+    /**
+     * Creates an empty set of values using the given initial size
+     * 
+     * @param size the initial size of the set of values
+     */
+    public ContentValues(int size) {
+        mValues = new HashMap<String, Object>(size, 1.0f);
+    }
+
+    /**
+     * Creates a set of values copied from the given set
+     * 
+     * @param from the values to copy
+     */
+    public ContentValues(ContentValues from) {
+        mValues = new HashMap<String, Object>(from.mValues);
+    }
+
+    /**
+     * Creates a set of values copied from the given HashMap. This is used
+     * by the Parcel unmarshalling code.
+     * 
+     * @param from the values to start with
+     * {@hide}
+     */
+    private ContentValues(HashMap<String, Object> values) {
+        mValues = values;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (!(object instanceof ContentValues)) {
+            return false;
+        }
+        return mValues.equals(((ContentValues) object).mValues);
+    }
+
+    @Override
+    public int hashCode() {
+        return mValues.hashCode();
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, String value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds all values from the passed in ContentValues.
+     *
+     * @param other the ContentValues from which to copy
+     */
+    public void putAll(ContentValues other) {
+        mValues.putAll(other.mValues);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Byte value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Short value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Integer value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Long value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Float value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Double value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, Boolean value) {
+        mValues.put(key, value);
+    }
+    
+    /**
+     * Adds a value to the set.
+     *
+     * @param key the name of the value to put
+     * @param value the data for the value to put
+     */
+    public void put(String key, byte[] value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Adds a null value to the set.
+     * 
+     * @param key the name of the value to make null
+     */
+    public void putNull(String key) {
+        mValues.put(key, null);
+    }
+
+    /**
+     * Returns the number of values.
+     * 
+     * @return the number of values
+     */
+    public int size() {
+        return mValues.size();
+    }
+
+    /**
+     * Remove a single value.
+     *
+     * @param key the name of the value to remove
+     */
+    public void remove(String key) {
+        mValues.remove(key);
+    }
+
+    /**
+     * Removes all values.
+     */
+    public void clear() {
+        mValues.clear();
+    }
+
+    /**
+     * Returns true if this object has the named value.
+     *
+     * @param key the value to check for
+     * @return {@code true} if the value is present, {@code false} otherwise 
+     */
+    public boolean containsKey(String key) {
+        return mValues.containsKey(key);
+    }
+
+    /**
+     * Gets a value. Valid value types are {@link String}, {@link Boolean}, and
+     * {@link Number} implementations.
+     *
+     * @param key the value to get
+     * @return the data for the value
+     */
+    public Object get(String key) {
+        return mValues.get(key);
+    }
+
+    /**
+     * Gets a value and converts it to a String.
+     * 
+     * @param key the value to get
+     * @return the String for the value
+     */
+    public String getAsString(String key) {
+        Object value = mValues.get(key);
+        return value != null ? mValues.get(key).toString() : null;
+    }
+
+    /**
+     * Gets a value and converts it to a Long.
+     * 
+     * @param key the value to get
+     * @return the Long value, or null if the value is missing or cannot be converted
+     */
+    public Long getAsLong(String key) {
+        Object value = mValues.get(key);
+        try {
+            return value != null ? ((Number) value).longValue() : null;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                try {
+                    return Long.valueOf(value.toString());
+                } catch (NumberFormatException e2) {
+                    Log.e(TAG, "Cannot parse Long value for " + value + " at key " + key);
+                    return null;
+                }
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Long");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value and converts it to an Integer.
+     * 
+     * @param key the value to get
+     * @return the Integer value, or null if the value is missing or cannot be converted
+     */
+    public Integer getAsInteger(String key) {
+        Object value = mValues.get(key);
+        try {
+            return value != null ? ((Number) value).intValue() : null;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                try {
+                    return Integer.valueOf(value.toString());
+                } catch (NumberFormatException e2) {
+                    Log.e(TAG, "Cannot parse Integer value for " + value + " at key " + key);
+                    return null;
+                }
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Integer");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value and converts it to a Short.
+     * 
+     * @param key the value to get
+     * @return the Short value, or null if the value is missing or cannot be converted
+     */
+    public Short getAsShort(String key) {
+        Object value = mValues.get(key);
+        try {
+            return value != null ? ((Number) value).shortValue() : null;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                try {
+                    return Short.valueOf(value.toString());
+                } catch (NumberFormatException e2) {
+                    Log.e(TAG, "Cannot parse Short value for " + value + " at key " + key);
+                    return null;
+                }
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Short");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value and converts it to a Byte.
+     * 
+     * @param key the value to get
+     * @return the Byte value, or null if the value is missing or cannot be converted
+     */
+    public Byte getAsByte(String key) {
+        Object value = mValues.get(key);
+        try {
+            return value != null ? ((Number) value).byteValue() : null;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                try {
+                    return Byte.valueOf(value.toString());
+                } catch (NumberFormatException e2) {
+                    Log.e(TAG, "Cannot parse Byte value for " + value + " at key " + key);
+                    return null;
+                }
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Byte");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value and converts it to a Double.
+     * 
+     * @param key the value to get
+     * @return the Double value, or null if the value is missing or cannot be converted
+     */
+    public Double getAsDouble(String key) {
+        Object value = mValues.get(key);
+        try {
+            return value != null ? ((Number) value).doubleValue() : null;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                try {
+                    return Double.valueOf(value.toString());
+                } catch (NumberFormatException e2) {
+                    Log.e(TAG, "Cannot parse Double value for " + value + " at key " + key);
+                    return null;
+                }
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Double");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value and converts it to a Float.
+     * 
+     * @param key the value to get
+     * @return the Float value, or null if the value is missing or cannot be converted
+     */
+    public Float getAsFloat(String key) {
+        Object value = mValues.get(key);
+        try {
+            return value != null ? ((Number) value).floatValue() : null;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                try {
+                    return Float.valueOf(value.toString());
+                } catch (NumberFormatException e2) {
+                    Log.e(TAG, "Cannot parse Float value for " + value + " at key " + key);
+                    return null;
+                }
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Float");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value and converts it to a Boolean.
+     * 
+     * @param key the value to get
+     * @return the Boolean value, or null if the value is missing or cannot be converted
+     */
+    public Boolean getAsBoolean(String key) {
+        Object value = mValues.get(key);
+        try {
+            return (Boolean) value;
+        } catch (ClassCastException e) {
+            if (value instanceof CharSequence) {
+                return Boolean.valueOf(value.toString());
+            } else {
+                Log.e(TAG, "Cannot cast value for " + key + " to a Boolean");
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Gets a value that is a byte array. Note that this method will not convert
+     * any other types to byte arrays.
+     * 
+     * @param key the value to get
+     * @return the byte[] value, or null is the value is missing or not a byte[]
+     */
+    public byte[] getAsByteArray(String key) {
+        Object value = mValues.get(key);
+        if (value instanceof byte[]) {
+            return (byte[]) value;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns a set of all of the keys and values
+     * 
+     * @return a set of all of the keys and values
+     */
+    public Set<Map.Entry<String, Object>> valueSet() {
+        return mValues.entrySet();
+    }
+    
+//    public static final Parcelable.Creator<ContentValues> CREATOR =
+//            new Parcelable.Creator<ContentValues>() {
+//        @SuppressWarnings({"deprecation", "unchecked"})
+//        public ContentValues createFromParcel(Parcel in) {
+//            // TODO - what ClassLoader should be passed to readHashMap?
+//            HashMap<String, Object> values = in.readHashMap(null);
+//            return new ContentValues(values);
+//        }
+//
+//        public ContentValues[] newArray(int size) {
+//            return new ContentValues[size];
+//        }
+//    };
+
+    public int describeContents() {
+        return 0;
+    }
+
+//    @SuppressWarnings("deprecation")
+//    public void writeToParcel(Parcel parcel, int flags) {
+//        parcel.writeMap(mValues);
+//    }
+
+    /**
+     * Unsupported, here until we get proper bulk insert APIs.
+     * {@hide}
+     */
+    @Deprecated
+    public void putStringArrayList(String key, ArrayList<String> value) {
+        mValues.put(key, value);
+    }
+
+    /**
+     * Unsupported, here until we get proper bulk insert APIs.
+     * {@hide}
+     */
+    @SuppressWarnings("unchecked")
+    @Deprecated
+    public ArrayList<String> getStringArrayList(String key) {
+        return (ArrayList<String>) mValues.get(key);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        for (String name : mValues.keySet()) {
+            String value = getAsString(name);
+            if (sb.length() > 0) sb.append(" ");
+            sb.append(name + "=" + value);
+        }
+        return sb.toString();
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/PropertyNode.java b/src/com/transage/privatespace/vcard/pim/PropertyNode.java
new file mode 100755
index 0000000..02fdfda
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/PropertyNode.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim;
+
+import com.transage.privatespace.vcard.content.ContentValues;
+
+import org.apache.commons.codec.binary.Base64;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public class PropertyNode {
+
+    public String propName;
+
+    public String propValue;
+
+    public List<String> propValue_vector;
+
+    /** Store value as byte[],after decode.
+     * Used when propValue is encoded by something like BASE64, QUOTED-PRINTABLE, etc.
+     */
+    public byte[] propValue_bytes;
+
+    /** param store: key=paramType, value=paramValue
+     * Note that currently PropertyNode class does not support multiple param-values
+     * defined in vCard 3.0 (See also RFC 2426). multiple-values are stored as
+     * one String value like "A,B", not ["A", "B"]...
+     * TODO: fix this. 
+     */
+    public ContentValues paramMap;
+
+    /** Only for TYPE=??? param store. */
+    public Set<String> paramMap_TYPE;
+
+    /** Store group values. Used only in VCard. */
+    public Set<String> propGroupSet;
+    
+    public PropertyNode() {
+        propName = "";
+        propValue = "";
+        propValue_vector = new ArrayList<String>();
+        paramMap = new ContentValues();
+        paramMap_TYPE = new HashSet<String>();
+        propGroupSet = new HashSet<String>();
+    }
+    
+    public PropertyNode(
+            String propName, String propValue, List<String> propValue_vector,
+            byte[] propValue_bytes, ContentValues paramMap, Set<String> paramMap_TYPE,
+            Set<String> propGroupSet) {
+        if (propName != null) {
+            this.propName = propName;
+        } else {
+            this.propName = "";
+        }
+        if (propValue != null) {
+            this.propValue = propValue;
+        } else {
+            this.propValue = "";
+        }
+        if (propValue_vector != null) {
+            this.propValue_vector = propValue_vector;
+        } else {
+            this.propValue_vector = new ArrayList<String>();
+        }
+        this.propValue_bytes = propValue_bytes;
+        if (paramMap != null) {
+            this.paramMap = paramMap;
+        } else {
+            this.paramMap = new ContentValues();
+        }
+        if (paramMap_TYPE != null) {
+            this.paramMap_TYPE = paramMap_TYPE;
+        } else {
+            this.paramMap_TYPE = new HashSet<String>();
+        }
+        if (propGroupSet != null) {
+            this.propGroupSet = propGroupSet;
+        } else {
+            this.propGroupSet = new HashSet<String>();
+        }
+    }
+    
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof PropertyNode)) {
+            return false;
+        }
+        
+        PropertyNode node = (PropertyNode)obj;
+        
+        if (propName == null || !propName.equals(node.propName)) {
+            return false;
+        } else if (!paramMap.equals(node.paramMap)) {
+            return false;
+        } else if (!paramMap_TYPE.equals(node.paramMap_TYPE)) {
+            return false;
+        } else if (!propGroupSet.equals(node.propGroupSet)) {
+            return false;
+        }
+        
+        if (propValue_bytes != null && Arrays.equals(propValue_bytes, node.propValue_bytes)) {
+            return true;
+        } else {
+            // Log.d("@@@", propValue + ", " + node.propValue);
+            if (!propValue.equals(node.propValue)) {
+                return false;
+            }
+
+            // The value in propValue_vector is not decoded even if it should be
+            // decoded by BASE64 or QUOTED-PRINTABLE. When the size of propValue_vector
+            // is 1, the encoded value is stored in propValue, so we do not have to
+            // check it.
+            return (propValue_vector.equals(node.propValue_vector) ||
+                    propValue_vector.size() == 1 ||
+                    node.propValue_vector.size() == 1);
+        }
+    }
+    
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        builder.append("propName: ");
+        builder.append(propName);
+        builder.append(", paramMap: ");
+        builder.append(paramMap.toString());
+        builder.append(", propmMap_TYPE: ");
+        builder.append(paramMap_TYPE.toString());
+        builder.append(", propGroupSet: ");
+        builder.append(propGroupSet.toString());
+        if (propValue_vector != null && propValue_vector.size() > 1) {
+            builder.append(", propValue_vector size: ");
+            builder.append(propValue_vector.size());
+        }
+        if (propValue_bytes != null) {
+            builder.append(", propValue_bytes size: ");
+            builder.append(propValue_bytes.length);
+        }
+        builder.append(", propValue: ");
+        builder.append(propValue);
+        return builder.toString();
+    }
+    
+    /**
+     * Encode this object into a string which can be decoded. 
+     */
+    public String encode() {
+        // PropertyNode#toString() is for reading, not for parsing in the future.
+        // We construct appropriate String here.
+        StringBuilder builder = new StringBuilder();
+        if (propName.length() > 0) {
+            builder.append("propName:[");
+            builder.append(propName);
+            builder.append("],");
+        }
+        int size = propGroupSet.size();
+        if (size > 0) {
+            Set<String> set = propGroupSet;
+            builder.append("propGroup:[");
+            int i = 0;
+            for (String group : set) {
+                // We do not need to double quote groups.
+                // group        = 1*(ALPHA / DIGIT / "-")
+                builder.append(group);
+                if (i < size - 1) {
+                    builder.append(",");
+                }
+                i++;
+            }
+            builder.append("],");
+        }
+
+        if (paramMap.size() > 0 || paramMap_TYPE.size() > 0) {
+            ContentValues values = paramMap;
+            builder.append("paramMap:[");
+            size = paramMap.size(); 
+            int i = 0;
+            for (Entry<String, Object> entry : values.valueSet()) {
+                // Assuming param-key does not contain NON-ASCII nor symbols.
+                //
+                // According to vCard 3.0:
+                // param-name   = iana-token / x-name
+                builder.append(entry.getKey());
+
+                // param-value may contain any value including NON-ASCIIs.
+                // We use the following replacing rule.
+                // \ -> \\
+                // , -> \,
+                // In String#replaceAll(), "\\\\" means a single backslash.
+                builder.append("=");
+                builder.append(entry.getValue().toString()
+                        .replaceAll("\\\\", "\\\\\\\\")
+                        .replaceAll(",", "\\\\,"));
+                if (i < size -1) {
+                    builder.append(",");
+                }
+                i++;
+            }
+
+            Set<String> set = paramMap_TYPE;
+            size = paramMap_TYPE.size();
+            if (i > 0 && size > 0) {
+                builder.append(",");
+            }
+            i = 0;
+            for (String type : set) {
+                builder.append("TYPE=");
+                builder.append(type
+                        .replaceAll("\\\\", "\\\\\\\\")
+                        .replaceAll(",", "\\\\,"));
+                if (i < size - 1) {
+                    builder.append(",");
+                }
+                i++;
+            }
+            builder.append("],");
+        }
+
+        size = propValue_vector.size();
+        if (size > 0) {
+            builder.append("propValue:[");
+            List<String> list = propValue_vector;
+            for (int i = 0; i < size; i++) {
+                builder.append(list.get(i)
+                        .replaceAll("\\\\", "\\\\\\\\")
+                        .replaceAll(",", "\\\\,"));
+                if (i < size -1) {
+                    builder.append(",");
+                }
+            }
+            builder.append("],");
+        }
+
+        return builder.toString();
+    }
+
+    public static PropertyNode decode(String encodedString) {
+        PropertyNode propertyNode = new PropertyNode();
+        String trimed = encodedString.trim();
+        if (trimed.length() == 0) {
+            return propertyNode;
+        }
+        String[] elems = trimed.split("],");
+        
+        for (String elem : elems) {
+            int index = elem.indexOf('[');
+            String name = elem.substring(0, index - 1);
+            Pattern pattern = Pattern.compile("(?<!\\\\),");
+            String[] values = pattern.split(elem.substring(index + 1), -1);
+            if (name.equals("propName")) {
+                propertyNode.propName = values[0];
+            } else if (name.equals("propGroupSet")) {
+                for (String value : values) {
+                    propertyNode.propGroupSet.add(value);
+                }
+            } else if (name.equals("paramMap")) {
+                ContentValues paramMap = propertyNode.paramMap;
+                Set<String> paramMap_TYPE = propertyNode.paramMap_TYPE;
+                for (String value : values) {
+                    String[] tmp = value.split("=", 2);
+                    String mapKey = tmp[0];
+                    // \, -> ,
+                    // \\ -> \
+                    // In String#replaceAll(), "\\\\" means a single backslash.
+                    String mapValue =
+                        tmp[1].replaceAll("\\\\,", ",").replaceAll("\\\\\\\\", "\\\\");
+                    if (mapKey.equalsIgnoreCase("TYPE")) {
+                        paramMap_TYPE.add(mapValue);
+                    } else {
+                        paramMap.put(mapKey, mapValue);
+                    }
+                }
+            } else if (name.equals("propValue")) {
+                StringBuilder builder = new StringBuilder();
+                List<String> list = propertyNode.propValue_vector;
+                int length = values.length;
+                for (int i = 0; i < length; i++) {
+                    String normValue = values[i]
+                                              .replaceAll("\\\\,", ",")
+                                              .replaceAll("\\\\\\\\", "\\\\");
+                    list.add(normValue);
+                    builder.append(normValue);
+                    if (i < length - 1) {
+                        builder.append(";");
+                    }
+                }
+                propertyNode.propValue = builder.toString();
+            }
+        }
+        
+        // At this time, QUOTED-PRINTABLE is already decoded to Java String.
+        // We just need to decode BASE64 String to binary.
+        String encoding = propertyNode.paramMap.getAsString("ENCODING");
+        if (encoding != null &&
+                (encoding.equalsIgnoreCase("BASE64") ||
+                        encoding.equalsIgnoreCase("B"))) {
+            propertyNode.propValue_bytes =
+                Base64.decodeBase64(propertyNode.propValue_vector.get(0).getBytes());
+        }
+        
+        return propertyNode;
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/VBuilder.java b/src/com/transage/privatespace/vcard/pim/VBuilder.java
new file mode 100755
index 0000000..848948b
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/VBuilder.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim;
+
+import java.util.List;
+
+public interface VBuilder {
+    void start();
+
+    void end();
+
+    /**
+     * @param type
+     *            VXX <br>
+     *            BEGIN:VXX
+     */
+    void startRecord(String type);
+
+    /** END:VXX */
+    void endRecord();
+
+    void startProperty();
+
+    void endProperty();
+
+    /**
+     * @param group 
+     */
+    void propertyGroup(String group);
+    
+    /**
+     * @param name
+     *            N <br>
+     *            N
+     */
+    void propertyName(String name);
+
+    /**
+     * @param type
+     *            LANGUAGE \ ENCODING <br>
+     *            ;LANGUage= \ ;ENCODING=
+     */
+    void propertyParamType(String type);
+
+    /**
+     * @param value
+     *            FR-EN \ GBK <br>
+     *            FR-EN \ GBK
+     */
+    void propertyParamValue(String value);
+
+    void propertyValues(List<String> values);
+}
diff --git a/src/com/transage/privatespace/vcard/pim/VDataBuilder.java b/src/com/transage/privatespace/vcard/pim/VDataBuilder.java
new file mode 100755
index 0000000..89146bc
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/VDataBuilder.java
@@ -0,0 +1,313 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim;
+
+import com.transage.privatespace.vcard.content.ContentValues;
+//import android.util.CharsetUtils;
+import com.transage.privatespace.vcard.util.Log;
+
+import org.apache.commons.codec.DecoderException;
+import org.apache.commons.codec.binary.Base64;
+import org.apache.commons.codec.net.QuotedPrintableCodec;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Store the parse result to custom datastruct: VNode, PropertyNode
+ * Maybe several vcard instance, so use vNodeList to store.
+ * VNode: standy by a vcard instance.
+ * PropertyNode: standy by a property line of a card.
+ */
+public class VDataBuilder implements VBuilder {
+    static private String LOG_TAG = "VDATABuilder"; 
+    
+    /**
+     * If there's no other information available, this class uses this charset for encoding
+     * byte arrays.
+     */
+    static public String DEFAULT_CHARSET = "UTF-8"; 
+    
+    /** type=VNode */
+    public List<VNode> vNodeList = new ArrayList<VNode>();
+    private int mNodeListPos = 0;
+    private VNode mCurrentVNode;
+    private PropertyNode mCurrentPropNode;
+    private String mCurrentParamType;
+    
+    /**
+     * The charset using which VParser parses the text.
+     */
+    private String mSourceCharset;
+    
+    /**
+     * The charset with which byte array is encoded to String.
+     */
+    private String mTargetCharset;
+    
+    private boolean mStrictLineBreakParsing;
+    
+    public VDataBuilder() {
+//        this(VParser.DEFAULT_CHARSET, DEFAULT_CHARSET, false);
+        this(DEFAULT_CHARSET, DEFAULT_CHARSET, false);
+    }
+
+    public VDataBuilder(String charset, boolean strictLineBreakParsing) {
+        this(null, charset, strictLineBreakParsing);
+    }
+    
+    /**
+     * @hide sourceCharset is temporal. 
+     */
+    public VDataBuilder(String sourceCharset, String targetCharset,
+            boolean strictLineBreakParsing) {
+        if (sourceCharset != null) {
+            mSourceCharset = sourceCharset;
+        } else {
+//            mSourceCharset = VParser.DEFAULT_CHARSET;
+            mSourceCharset = DEFAULT_CHARSET;
+        }
+        if (targetCharset != null) {
+            mTargetCharset = targetCharset;
+        } else {
+            mTargetCharset = DEFAULT_CHARSET;
+        }
+        mStrictLineBreakParsing = strictLineBreakParsing;
+    }
+
+    public void start() {
+    }
+
+    public void end() {
+    }
+
+    // Note: I guess that this code assumes the Record may nest like this:
+    // START:VPOS
+    // ...
+    // START:VPOS2
+    // ...
+    // END:VPOS2
+    // ...
+    // END:VPOS
+    //
+    // However the following code has a bug.
+    // When error occurs after calling startRecord(), the entry which is probably
+    // the cause of the error remains to be in vNodeList, while endRecord() is not called.
+    //
+    // I leave this code as is since I'm not familiar with vcalendar specification.
+    // But I believe we should refactor this code in the future.
+    // Until this, the last entry has to be removed when some error occurs.
+    public void startRecord(String type) {
+        
+        VNode vnode = new VNode();
+        vnode.parseStatus = 1;
+        vnode.VName = type;
+        // I feel this should be done in endRecord(), but it cannot be done because of
+        // the reason above.
+        vNodeList.add(vnode);
+        mNodeListPos = vNodeList.size() - 1;
+        mCurrentVNode = vNodeList.get(mNodeListPos);
+    }
+
+    public void endRecord() {
+        VNode endNode = vNodeList.get(mNodeListPos);
+        endNode.parseStatus = 0;
+        while(mNodeListPos > 0){
+            mNodeListPos--;
+            if((vNodeList.get(mNodeListPos)).parseStatus == 1)
+                break;
+        }
+        mCurrentVNode = vNodeList.get(mNodeListPos);
+    }
+
+    public void startProperty() {
+        mCurrentPropNode = new PropertyNode();
+    }
+
+    public void endProperty() {
+        mCurrentVNode.propList.add(mCurrentPropNode);
+    }
+    
+    public void propertyName(String name) {
+        mCurrentPropNode.propName = name;
+    }
+
+    // Used only in VCard.
+    public void propertyGroup(String group) {
+        mCurrentPropNode.propGroupSet.add(group);
+    }
+    
+    public void propertyParamType(String type) {
+        mCurrentParamType = type;
+    }
+
+    public void propertyParamValue(String value) {
+        if (mCurrentParamType == null ||
+                mCurrentParamType.equalsIgnoreCase("TYPE")) {
+            mCurrentPropNode.paramMap_TYPE.add(value);
+        } else {
+            mCurrentPropNode.paramMap.put(mCurrentParamType, value);
+        }
+
+        mCurrentParamType = null;
+    }
+
+    private String encodeString(String originalString, String targetCharset) {
+        if (mSourceCharset.equalsIgnoreCase(targetCharset)) {
+            return originalString;
+        }
+        Charset charset = Charset.forName(mSourceCharset);
+        ByteBuffer byteBuffer = charset.encode(originalString);
+        // byteBuffer.array() "may" return byte array which is larger than
+        // byteBuffer.remaining(). Here, we keep on the safe side.
+        byte[] bytes = new byte[byteBuffer.remaining()];
+        byteBuffer.get(bytes);
+        try {
+            return new String(bytes, targetCharset);
+        } catch (UnsupportedEncodingException e) {
+            Log.e(LOG_TAG, "Failed to encode: charset=" + targetCharset);
+            return new String(bytes);
+        }
+    }
+    
+    private String handleOneValue(String value, String targetCharset, String encoding) {
+        if (encoding != null) {
+            if (encoding.equals("BASE64") || encoding.equals("B")) {
+                // Assume BASE64 is used only when the number of values is 1.
+                mCurrentPropNode.propValue_bytes =
+                    Base64.decodeBase64(value.getBytes());
+                return value;
+            } else if (encoding.equals("QUOTED-PRINTABLE")) {
+                String quotedPrintable = value
+                .replaceAll("= ", " ").replaceAll("=\t", "\t");
+                String[] lines;
+                if (mStrictLineBreakParsing) {
+                    lines = quotedPrintable.split("\r\n");
+                } else {
+                    StringBuilder builder = new StringBuilder();
+                    int length = quotedPrintable.length();
+                    ArrayList<String> list = new ArrayList<String>();
+                    for (int i = 0; i < length; i++) {
+                        char ch = quotedPrintable.charAt(i);
+                        if (ch == '\n') {
+                            list.add(builder.toString());
+                            builder = new StringBuilder();
+                        } else if (ch == '\r') {
+                            list.add(builder.toString());
+                            builder = new StringBuilder();
+                            if (i < length - 1) {
+                                char nextCh = quotedPrintable.charAt(i + 1);
+                                if (nextCh == '\n') {
+                                    i++;
+                                }
+                            }
+                        } else {
+                            builder.append(ch);
+                        }
+                    }
+                    String finalLine = builder.toString();
+                    if (finalLine.length() > 0) {
+                        list.add(finalLine);
+                    }
+                    lines = list.toArray(new String[0]);
+                }
+                StringBuilder builder = new StringBuilder();
+                for (String line : lines) {
+                    if (line.endsWith("=")) {
+                        line = line.substring(0, line.length() - 1);
+                    }
+                    builder.append(line);
+                }
+                byte[] bytes;
+                try {
+                    bytes = builder.toString().getBytes(mSourceCharset);
+                } catch (UnsupportedEncodingException e1) {
+                    Log.e(LOG_TAG, "Failed to encode: charset=" + mSourceCharset);
+                    bytes = builder.toString().getBytes();
+                }
+                
+                try {
+                    bytes = QuotedPrintableCodec.decodeQuotedPrintable(bytes);
+                } catch (DecoderException e) {
+                    Log.e(LOG_TAG, "Failed to decode quoted-printable: " + e);
+                    return "";
+                }
+
+                try {
+                    return new String(bytes, targetCharset);
+                } catch (UnsupportedEncodingException e) {
+                    Log.e(LOG_TAG, "Failed to encode: charset=" + targetCharset);
+                    return new String(bytes);
+                }
+            }
+            // Unknown encoding. Fall back to default.
+        }
+        return encodeString(value, targetCharset);
+    }
+    
+    public void propertyValues(List<String> values) {
+        if (values == null || values.size() == 0) {
+            mCurrentPropNode.propValue_bytes = null;
+            mCurrentPropNode.propValue_vector.clear();
+            mCurrentPropNode.propValue_vector.add("");
+            mCurrentPropNode.propValue = "";
+            return;
+        }
+        
+        ContentValues paramMap = mCurrentPropNode.paramMap;
+        
+        String targetCharset = DEFAULT_CHARSET; //CharsetUtils.nameForDefaultVendor(paramMap.getAsString("CHARSET"));
+        String encoding = paramMap.getAsString("ENCODING"); 
+        
+        if (targetCharset == null || targetCharset.length() == 0) {
+            targetCharset = mTargetCharset;
+        }
+        
+        for (String value : values) {
+            mCurrentPropNode.propValue_vector.add(
+                    handleOneValue(value, targetCharset, encoding));
+        }
+
+        mCurrentPropNode.propValue = listToString(mCurrentPropNode.propValue_vector);
+    }
+
+    private String listToString(List<String> list){
+        int size = list.size();
+        if (size > 1) {
+            StringBuilder typeListB = new StringBuilder();
+            for (String type : list) {
+                typeListB.append(type).append(";");
+            }
+            int len = typeListB.length();
+            if (len > 0 && typeListB.charAt(len - 1) == ';') {
+                return typeListB.substring(0, len - 1);
+            }
+            return typeListB.toString();
+        } else if (size == 1) {
+            return list.get(0);
+        } else {
+            return "";
+        }
+    }
+    
+    public String getResult(){
+        return null;
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/VNode.java b/src/com/transage/privatespace/vcard/pim/VNode.java
new file mode 100755
index 0000000..9dcb79f
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/VNode.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim;
+
+import java.util.ArrayList;
+
+public class VNode {
+
+    public String VName;
+
+    public ArrayList<PropertyNode> propList = new ArrayList<PropertyNode>();
+
+    /** 0:parse over. 1:parsing. */
+    public int parseStatus = 1;
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/ContactStruct.java b/src/com/transage/privatespace/vcard/pim/vcard/ContactStruct.java
new file mode 100755
index 0000000..9c45ab1
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/ContactStruct.java
@@ -0,0 +1,975 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+//import android.content.AbstractSyncableContentProvider;
+//import android.content.ContentResolver;
+//import android.content.ContentUris;
+//import android.content.ContentValues;
+//import android.net.Uri;
+import com.transage.privatespace.vcard.provider.Contacts;
+//import android.provider.Contacts.Extensions;
+//import android.provider.Contacts.GroupMembership;
+//import android.provider.Contacts.Organizations;
+//import android.provider.Contacts.People;
+//import android.provider.Contacts.Photos;
+import com.transage.privatespace.vcard.pim.PropertyNode;
+import com.transage.privatespace.vcard.pim.VNode;
+import com.transage.privatespace.vcard.telephony.PhoneNumberUtils;
+import com.transage.privatespace.vcard.text.TextUtils;
+import com.transage.privatespace.vcard.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * The parameter class of VCardComposer.
+ * This class standy by the person-contact in
+ * Android system, we must use this class instance as parameter to transmit to
+ * VCardComposer so that create vCard string.
+ */
+// TODO: rename the class name, next step
+public class ContactStruct {
+    private static final String LOG_TAG = "ContactStruct";
+    
+    // Note: phonetic name probably should be "LAST FIRST MIDDLE" for European languages, and
+    //       space should be added between each element while it should not be in Japanese.
+    //       But unfortunately, we currently do not have the data and are not sure whether we should
+    //       support European version of name ordering.
+    //
+    // TODO: Implement the logic described above if we really need European version of
+    //        phonetic name handling. Also, adding the appropriate test case of vCard would be
+    //        highly appreciated.
+    public static final int NAME_ORDER_TYPE_ENGLISH = 0;
+    public static final int NAME_ORDER_TYPE_JAPANESE = 1;
+
+    /** MUST exist */
+    public String name;
+    public String phoneticName;
+    /** maybe folding */
+    public List<String> notes = new ArrayList<String>();
+    /** maybe folding */
+    public String title;
+    /** binary bytes of pic. */
+    public byte[] photoBytes;
+    /** The type of Photo (e.g. JPEG, BMP, etc.) */
+    public String photoType;
+    /** Only for GET. Use addPhoneList() to PUT. */
+    public List<PhoneData> phoneList;
+    /** Only for GET. Use addContactmethodList() to PUT. */
+    public List<ContactMethod> contactmethodList;
+    /** Only for GET. Use addOrgList() to PUT. */
+    public List<OrganizationData> organizationList;
+    /** Only for GET. Use addExtension() to PUT */
+    public Map<String, List<String>> extensionMap;
+
+    // Use organizationList instead when handling ORG.
+    @Deprecated
+    public String company;
+    
+    public static class PhoneData {
+        public int type;
+        /** maybe folding */
+        public String data;
+        public String label;
+        public boolean isPrimary; 
+    }
+
+    public static class ContactMethod {
+        // Contacts.KIND_EMAIL, Contacts.KIND_POSTAL
+        public int kind;
+        // e.g. Contacts.ContactMethods.TYPE_HOME, Contacts.PhoneColumns.TYPE_HOME
+        // If type == Contacts.PhoneColumns.TYPE_CUSTOM, label is used.
+        public int type;
+        public String data;
+        // Used only when TYPE is TYPE_CUSTOM.
+        public String label;
+        public boolean isPrimary;
+    }
+    
+    public static class OrganizationData {
+        public int type;
+        public String companyName;
+        public String positionName;
+        public boolean isPrimary;
+    }
+
+    /**
+     * Add a phone info to phoneList.
+     * @param data phone number
+     * @param type type col of content://contacts/phones
+     * @param label lable col of content://contacts/phones
+     */
+    public void addPhone(int type, String data, String label, boolean isPrimary){
+        if (phoneList == null) {
+            phoneList = new ArrayList<PhoneData>();
+        }
+        PhoneData phoneData = new PhoneData();
+        phoneData.type = type;
+        
+        StringBuilder builder = new StringBuilder();
+        String trimed = data.trim();
+        int length = trimed.length();
+        for (int i = 0; i < length; i++) {
+            char ch = trimed.charAt(i);
+            if (('0' <= ch && ch <= '9') || (i == 0 && ch == '+')) {
+                builder.append(ch);
+            }
+        }
+        phoneData.data = PhoneNumberUtils.formatNumber(builder.toString());
+        phoneData.label = label;
+        phoneData.isPrimary = isPrimary;
+        phoneList.add(phoneData);
+    }
+
+    /**
+     * Add a contactmethod info to contactmethodList.
+     * @param kind integer value defined in Contacts.java
+     * (e.g. Contacts.KIND_EMAIL)
+     * @param type type col of content://contacts/contact_methods
+     * @param data contact data
+     * @param label extra string used only when kind is Contacts.KIND_CUSTOM.
+     */
+    public void addContactmethod(int kind, int type, String data,
+            String label, boolean isPrimary){
+        if (contactmethodList == null) {
+            contactmethodList = new ArrayList<ContactMethod>();
+        }
+        ContactMethod contactMethod = new ContactMethod();
+        contactMethod.kind = kind;
+        contactMethod.type = type;
+        contactMethod.data = data;
+        contactMethod.label = label;
+        contactMethod.isPrimary = isPrimary;
+        contactmethodList.add(contactMethod);
+    }
+    
+    /**
+     * Add a Organization info to organizationList.
+     */
+    public void addOrganization(int type, String companyName, String positionName,
+            boolean isPrimary) {
+        if (organizationList == null) {
+            organizationList = new ArrayList<OrganizationData>();
+        }
+        OrganizationData organizationData = new OrganizationData();
+        organizationData.type = type;
+        organizationData.companyName = companyName;
+        organizationData.positionName = positionName;
+        organizationData.isPrimary = isPrimary;
+        organizationList.add(organizationData);
+    }
+
+    /**
+     * Set "position" value to the appropriate data. If there's more than one
+     * OrganizationData objects, the value is set to the last one. If there's no
+     * OrganizationData object, a new OrganizationData is created, whose company name is
+     * empty.  
+     * 
+     * TODO: incomplete logic. fix this:
+     * 
+     * e.g. This assumes ORG comes earlier, but TITLE may come earlier like this, though we do not
+     * know how to handle it in general cases...
+     * ----
+     * TITLE:Software Engineer
+     * ORG:Google
+     * ----
+     */
+    public void setPosition(String positionValue) {
+        if (organizationList == null) {
+            organizationList = new ArrayList<OrganizationData>();
+        }
+        int size = organizationList.size();
+        if (size == 0) {
+            addOrganization(Contacts.OrganizationColumns.TYPE_OTHER, "", null, false);
+            size = 1;
+        }
+        OrganizationData lastData = organizationList.get(size - 1);
+        lastData.positionName = positionValue;
+    }
+    
+    public void addExtension(PropertyNode propertyNode) {
+        if (propertyNode.propValue.length() == 0) {
+            return;
+        }
+        // Now store the string into extensionMap.
+        List<String> list;
+        String name = propertyNode.propName;
+        if (extensionMap == null) {
+            extensionMap = new HashMap<String, List<String>>();
+        }
+        if (!extensionMap.containsKey(name)){
+            list = new ArrayList<String>();
+            extensionMap.put(name, list);
+        } else {
+            list = extensionMap.get(name);
+        }        
+        
+        list.add(propertyNode.encode());
+    }
+    
+    private static String getNameFromNProperty(List<String> elems, int nameOrderType) {
+        // Family, Given, Middle, Prefix, Suffix. (1 - 5)
+        int size = elems.size();
+        if (size > 1) {
+            StringBuilder builder = new StringBuilder();
+            boolean builderIsEmpty = true;
+            // Prefix
+            if (size > 3 && elems.get(3).length() > 0) {
+                builder.append(elems.get(3));
+                builderIsEmpty = false;
+            }
+            String first, second;
+            if (nameOrderType == NAME_ORDER_TYPE_JAPANESE) {
+                first = elems.get(0);
+                second = elems.get(1);
+            } else {
+                first = elems.get(1);
+                second = elems.get(0);
+            }
+            if (first.length() > 0) {
+                if (!builderIsEmpty) {
+                    builder.append(' ');
+                }
+                builder.append(first);
+                builderIsEmpty = false;
+            }
+            // Middle name
+            if (size > 2 && elems.get(2).length() > 0) {
+                if (!builderIsEmpty) {
+                    builder.append(' ');
+                }
+                builder.append(elems.get(2));
+                builderIsEmpty = false;
+            }
+            if (second.length() > 0) {
+                if (!builderIsEmpty) {
+                    builder.append(' ');
+                }
+                builder.append(second);
+                builderIsEmpty = false;
+            }
+            // Suffix
+            if (size > 4 && elems.get(4).length() > 0) {
+                if (!builderIsEmpty) {
+                    builder.append(' ');
+                }
+                builder.append(elems.get(4));
+                builderIsEmpty = false;
+            }
+            return builder.toString();
+        } else if (size == 1) {
+            return elems.get(0);
+        } else {
+            return "";
+        }
+    }
+    
+    public static ContactStruct constructContactFromVNode(VNode node,
+            int nameOrderType) {
+        if (!node.VName.equals("VCARD")) {
+            // Impossible in current implementation. Just for safety.
+            Log.e(LOG_TAG, "Non VCARD data is inserted.");
+            return null;
+        }
+
+        // For name, there are three fields in vCard: FN, N, NAME.
+        // We prefer FN, which is a required field in vCard 3.0 , but not in vCard 2.1.
+        // Next, we prefer NAME, which is defined only in vCard 3.0.
+        // Finally, we use N, which is a little difficult to parse.
+        String fullName = null;
+        String nameFromNProperty = null;
+
+        // Some vCard has "X-PHONETIC-FIRST-NAME", "X-PHONETIC-MIDDLE-NAME", and
+        // "X-PHONETIC-LAST-NAME"
+        String xPhoneticFirstName = null;
+        String xPhoneticMiddleName = null;
+        String xPhoneticLastName = null;
+        
+        ContactStruct contact = new ContactStruct();
+
+        // Each Column of four properties has ISPRIMARY field
+        // (See android.provider.Contacts)
+        // If false even after the following loop, we choose the first
+        // entry as a "primary" entry.
+        boolean prefIsSetAddress = false;
+        boolean prefIsSetPhone = false;
+        boolean prefIsSetEmail = false;
+        boolean prefIsSetOrganization = false;
+        
+        for (PropertyNode propertyNode: node.propList) {
+            String name = propertyNode.propName;
+
+            if (TextUtils.isEmpty(propertyNode.propValue)) {
+                continue;
+            }
+            
+            if (name.equals("VERSION")) {
+                // vCard version. Ignore this.
+            } else if (name.equals("FN")) {
+                fullName = propertyNode.propValue;
+            } else if (name.equals("NAME") && fullName == null) {
+                // Only in vCard 3.0. Use this if FN does not exist.
+                // Though, note that vCard 3.0 requires FN.
+                fullName = propertyNode.propValue;
+            } else if (name.equals("N")) {
+                nameFromNProperty = getNameFromNProperty(propertyNode.propValue_vector,
+                        nameOrderType);
+            } else if (name.equals("SORT-STRING")) {
+                contact.phoneticName = propertyNode.propValue;
+            } else if (name.equals("SOUND")) {
+                if (propertyNode.paramMap_TYPE.contains("X-IRMC-N") &&
+                        contact.phoneticName == null) {
+                    // Some Japanese mobile phones use this field for phonetic name,
+                    // since vCard 2.1 does not have "SORT-STRING" type.
+                    // Also, in some cases, the field has some ';' in it.
+                    // We remove them.
+                    StringBuilder builder = new StringBuilder();
+                    String value = propertyNode.propValue;
+                    int length = value.length();
+                    for (int i = 0; i < length; i++) {
+                        char ch = value.charAt(i);
+                        if (ch != ';') {
+                            builder.append(ch);
+                        }
+                    }
+                    contact.phoneticName = builder.toString();
+                } else {
+                    contact.addExtension(propertyNode);
+                }
+            } else if (name.equals("ADR")) {
+                List<String> values = propertyNode.propValue_vector;
+                boolean valuesAreAllEmpty = true;
+                for (String value : values) {
+                    if (value.length() > 0) {
+                        valuesAreAllEmpty = false;
+                        break;
+                    }
+                }
+                if (valuesAreAllEmpty) {
+                    continue;
+                }
+
+                int kind = Contacts.KIND_POSTAL;
+                int type = -1;
+                String label = "";
+                boolean isPrimary = false;
+                for (String typeString : propertyNode.paramMap_TYPE) {
+                    if (typeString.equals("PREF") && !prefIsSetAddress) {
+                        // Only first "PREF" is considered.
+                        prefIsSetAddress = true;
+                        isPrimary = true;
+                    } else if (typeString.equalsIgnoreCase("HOME")) {
+                        type = Contacts.ContactMethodsColumns.TYPE_HOME;
+                        label = "";
+                    } else if (typeString.equalsIgnoreCase("WORK") || 
+                            typeString.equalsIgnoreCase("COMPANY")) {
+                        // "COMPANY" seems emitted by Windows Mobile, which is not
+                        // specifically supported by vCard 2.1. We assume this is same
+                        // as "WORK".
+                        type = Contacts.ContactMethodsColumns.TYPE_WORK;
+                        label = "";
+                    } else if (typeString.equalsIgnoreCase("POSTAL")) {
+                        kind = Contacts.KIND_POSTAL;
+                    } else if (typeString.equalsIgnoreCase("PARCEL") || 
+                            typeString.equalsIgnoreCase("DOM") ||
+                            typeString.equalsIgnoreCase("INTL")) {
+                        // We do not have a kind or type matching these.
+                        // TODO: fix this. We may need to split entries into two.
+                        // (e.g. entries for KIND_POSTAL and KIND_PERCEL)
+                    } else if (typeString.toUpperCase().startsWith("X-") &&
+                            type < 0) {
+                        type = Contacts.ContactMethodsColumns.TYPE_CUSTOM;
+                        label = typeString.substring(2);
+                    } else if (type < 0) {
+                        // vCard 3.0 allows iana-token. Also some vCard 2.1 exporters
+                        // emit non-standard types. We do not handle their values now.
+                        type = Contacts.ContactMethodsColumns.TYPE_CUSTOM;
+                        label = typeString;
+                    }
+                }
+                // We use "HOME" as default
+                if (type < 0) {
+                    type = Contacts.ContactMethodsColumns.TYPE_HOME;
+                }
+                                
+                // adr-value    = 0*6(text-value ";") text-value
+                //              ; PO Box, Extended Address, Street, Locality, Region, Postal
+                //              ; Code, Country Name
+                String address;
+                List<String> list = propertyNode.propValue_vector;
+                int size = list.size();
+                if (size > 1) {
+                    StringBuilder builder = new StringBuilder();
+                    boolean builderIsEmpty = true;
+                    if (Locale.getDefault().getCountry().equals(Locale.JAPAN.getCountry())) {
+                        // In Japan, the order is reversed.
+                        for (int i = size - 1; i >= 0; i--) {
+                            String addressPart = list.get(i);
+                            if (addressPart.length() > 0) {
+                                if (!builderIsEmpty) {
+                                    builder.append(' ');
+                                }
+                                builder.append(addressPart);
+                                builderIsEmpty = false;
+                            }
+                        }
+                    } else {
+                        for (int i = 0; i < size; i++) {
+                            String addressPart = list.get(i);
+                            if (addressPart.length() > 0) {
+                                if (!builderIsEmpty) {
+                                    builder.append(' ');
+                                }
+                                builder.append(addressPart);
+                                builderIsEmpty = false;
+                            }
+                        }
+                    }
+                    address = builder.toString().trim();
+                } else {
+                    address = propertyNode.propValue; 
+                }
+                contact.addContactmethod(kind, type, address, label, isPrimary);
+            } else if (name.equals("ORG")) {
+                // vCard specification does not specify other types.
+                int type = Contacts.OrganizationColumns.TYPE_WORK;
+                boolean isPrimary = false;
+                
+                for (String typeString : propertyNode.paramMap_TYPE) {
+                    if (typeString.equals("PREF") && !prefIsSetOrganization) {
+                        // vCard specification officially does not have PREF in ORG.
+                        // This is just for safety.
+                        prefIsSetOrganization = true;
+                        isPrimary = true;
+                    }
+                    // XXX: Should we cope with X- words?
+                }
+
+                List<String> list = propertyNode.propValue_vector; 
+                int size = list.size();
+                StringBuilder builder = new StringBuilder();
+                for (Iterator<String> iter = list.iterator(); iter.hasNext();) {
+                    builder.append(iter.next());
+                    if (iter.hasNext()) {
+                        builder.append(' ');
+                    }
+                }
+
+                contact.addOrganization(type, builder.toString(), "", isPrimary);
+            } else if (name.equals("TITLE")) {
+                contact.setPosition(propertyNode.propValue);
+            } else if (name.equals("ROLE")) {
+                contact.setPosition(propertyNode.propValue);
+            } else if (name.equals("PHOTO")) {
+                // We prefer PHOTO to LOGO.
+                String valueType = propertyNode.paramMap.getAsString("VALUE");
+                if (valueType != null && valueType.equals("URL")) {
+                    // TODO: do something.
+                } else {
+                    // Assume PHOTO is stored in BASE64. In that case,
+                    // data is already stored in propValue_bytes in binary form.
+                    // It should be automatically done by VBuilder (VDataBuilder/VCardDatabuilder) 
+                    contact.photoBytes = propertyNode.propValue_bytes;
+                    String type = propertyNode.paramMap.getAsString("TYPE");
+                    if (type != null) {
+                        contact.photoType = type;
+                    }
+                }
+            } else if (name.equals("LOGO")) {
+                // When PHOTO is not available this is not URL,
+                // we use this instead of PHOTO.
+                String valueType = propertyNode.paramMap.getAsString("VALUE");
+                if (valueType != null && valueType.equals("URL")) {
+                    // TODO: do something.
+                } else if (contact.photoBytes == null) {
+                    contact.photoBytes = propertyNode.propValue_bytes;
+                    String type = propertyNode.paramMap.getAsString("TYPE");
+                    if (type != null) {
+                        contact.photoType = type;
+                    }
+                }
+            } else if (name.equals("EMAIL")) {
+                int type = -1;
+                String label = null;
+                boolean isPrimary = false;
+                for (String typeString : propertyNode.paramMap_TYPE) {
+                    if (typeString.equals("PREF") && !prefIsSetEmail) {
+                        // Only first "PREF" is considered.
+                        prefIsSetEmail = true;
+                        isPrimary = true;
+                    } else if (typeString.equalsIgnoreCase("HOME")) {
+                        type = Contacts.ContactMethodsColumns.TYPE_HOME;
+                    } else if (typeString.equalsIgnoreCase("WORK")) {
+                        type = Contacts.ContactMethodsColumns.TYPE_WORK;
+                    } else if (typeString.equalsIgnoreCase("CELL")) {
+                        // We do not have Contacts.ContactMethodsColumns.TYPE_MOBILE yet.
+                        type = Contacts.ContactMethodsColumns.TYPE_CUSTOM;
+                        label = Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME;
+                    } else if (typeString.toUpperCase().startsWith("X-") &&
+                            type < 0) {
+                        type = Contacts.ContactMethodsColumns.TYPE_CUSTOM;
+                        label = typeString.substring(2);
+                    } else if (type < 0) {
+                        // vCard 3.0 allows iana-token.
+                        // We may have INTERNET (specified in vCard spec),
+                        // SCHOOL, etc.
+                        type = Contacts.ContactMethodsColumns.TYPE_CUSTOM;
+                        label = typeString;
+                    }
+                }
+                // We use "OTHER" as default.
+                if (type < 0) {
+                    type = Contacts.ContactMethodsColumns.TYPE_OTHER;
+                }
+                contact.addContactmethod(Contacts.KIND_EMAIL,
+                        type, propertyNode.propValue,label, isPrimary);
+            } else if (name.equals("TEL")) {
+                int type = -1;
+                String label = null;
+                boolean isPrimary = false;
+                boolean isFax = false;
+                for (String typeString : propertyNode.paramMap_TYPE) {
+                    if (typeString.equals("PREF") && !prefIsSetPhone) {
+                        // Only first "PREF" is considered.
+                        prefIsSetPhone = true;
+                        isPrimary = true;
+                    } else if (typeString.equalsIgnoreCase("HOME")) {
+                        type = Contacts.PhonesColumns.TYPE_HOME;
+                    } else if (typeString.equalsIgnoreCase("WORK")) {
+                        type = Contacts.PhonesColumns.TYPE_WORK;
+                    } else if (typeString.equalsIgnoreCase("CELL")) {
+                        type = Contacts.PhonesColumns.TYPE_MOBILE;
+                    } else if (typeString.equalsIgnoreCase("PAGER")) {
+                        type = Contacts.PhonesColumns.TYPE_PAGER;
+                    } else if (typeString.equalsIgnoreCase("FAX")) {
+                        isFax = true;
+                    } else if (typeString.equalsIgnoreCase("VOICE") ||
+                            typeString.equalsIgnoreCase("MSG")) {
+                        // Defined in vCard 3.0. Ignore these because they
+                        // conflict with "HOME", "WORK", etc.
+                        // XXX: do something?
+                    } else if (typeString.toUpperCase().startsWith("X-") &&
+                            type < 0) {
+                        type = Contacts.PhonesColumns.TYPE_CUSTOM;
+                        label = typeString.substring(2);
+                    } else if (type < 0){
+                        // We may have MODEM, CAR, ISDN, etc...
+                        type = Contacts.PhonesColumns.TYPE_CUSTOM;
+                        label = typeString;
+                    }
+                }
+                // We use "HOME" as default
+                if (type < 0) {
+                    type = Contacts.PhonesColumns.TYPE_HOME;
+                }
+                if (isFax) {
+                    if (type == Contacts.PhonesColumns.TYPE_HOME) {
+                        type = Contacts.PhonesColumns.TYPE_FAX_HOME; 
+                    } else if (type == Contacts.PhonesColumns.TYPE_WORK) {
+                        type = Contacts.PhonesColumns.TYPE_FAX_WORK; 
+                    }
+                }
+
+                contact.addPhone(type, propertyNode.propValue, label, isPrimary);
+            } else if (name.equals("NOTE")) {
+                contact.notes.add(propertyNode.propValue);
+            } else if (name.equals("BDAY")) {
+                contact.addExtension(propertyNode);
+            } else if (name.equals("URL")) {
+                contact.addExtension(propertyNode);
+            } else if (name.equals("REV")) {                
+                // Revision of this VCard entry. I think we can ignore this.
+                contact.addExtension(propertyNode);
+            } else if (name.equals("UID")) {
+                contact.addExtension(propertyNode);
+            } else if (name.equals("KEY")) {
+                // Type is X509 or PGP? I don't know how to handle this...
+                contact.addExtension(propertyNode);
+            } else if (name.equals("MAILER")) {
+                contact.addExtension(propertyNode);
+            } else if (name.equals("TZ")) {
+                contact.addExtension(propertyNode);
+            } else if (name.equals("GEO")) {
+                contact.addExtension(propertyNode);
+            } else if (name.equals("NICKNAME")) {
+                // vCard 3.0 only.
+                contact.addExtension(propertyNode);
+            } else if (name.equals("CLASS")) {
+                // vCard 3.0 only.
+                // e.g. CLASS:CONFIDENTIAL
+                contact.addExtension(propertyNode);
+            } else if (name.equals("PROFILE")) {
+                // VCard 3.0 only. Must be "VCARD". I think we can ignore this.
+                contact.addExtension(propertyNode);
+            } else if (name.equals("CATEGORIES")) {
+                // VCard 3.0 only.
+                // e.g. CATEGORIES:INTERNET,IETF,INDUSTRY,INFORMATION TECHNOLOGY
+                contact.addExtension(propertyNode);
+            } else if (name.equals("SOURCE")) {
+                // VCard 3.0 only.
+                contact.addExtension(propertyNode);
+            } else if (name.equals("PRODID")) {
+                // VCard 3.0 only.
+                // To specify the identifier for the product that created
+                // the vCard object.
+                contact.addExtension(propertyNode);
+            } else if (name.equals("X-PHONETIC-FIRST-NAME")) {
+                xPhoneticFirstName = propertyNode.propValue;
+            } else if (name.equals("X-PHONETIC-MIDDLE-NAME")) {
+                xPhoneticMiddleName = propertyNode.propValue;
+            } else if (name.equals("X-PHONETIC-LAST-NAME")) {
+                xPhoneticLastName = propertyNode.propValue;
+            } else {
+                // Unknown X- words and IANA token.
+                contact.addExtension(propertyNode);
+            }
+        }
+
+        if (fullName != null) {
+            contact.name = fullName;
+        } else if(nameFromNProperty != null) {
+            contact.name = nameFromNProperty;
+        } else {
+            contact.name = "";
+        }
+
+        if (contact.phoneticName == null &&
+                (xPhoneticFirstName != null || xPhoneticMiddleName != null ||
+                        xPhoneticLastName != null)) {
+            // Note: In Europe, this order should be "LAST FIRST MIDDLE". See the comment around
+            //       NAME_ORDER_TYPE_* for more detail.
+            String first;
+            String second;
+            if (nameOrderType == NAME_ORDER_TYPE_JAPANESE) {
+                first = xPhoneticLastName;
+                second = xPhoneticFirstName;
+            } else {
+                first = xPhoneticFirstName;
+                second = xPhoneticLastName;
+            }
+            StringBuilder builder = new StringBuilder();
+            if (first != null) {
+                builder.append(first);
+            }
+            if (xPhoneticMiddleName != null) {
+                builder.append(xPhoneticMiddleName);
+            }
+            if (second != null) {
+                builder.append(second);
+            }
+            contact.phoneticName = builder.toString();
+        }
+        
+        // Remove unnecessary white spaces.
+        // It is found that some mobile phone emits  phonetic name with just one white space
+        // when a user does not specify one.
+        // This logic is effective toward such kind of weird data.
+        if (contact.phoneticName != null) {
+            contact.phoneticName = contact.phoneticName.trim();
+        }
+
+        // If there is no "PREF", we choose the first entries as primary.
+        if (!prefIsSetPhone &&
+                contact.phoneList != null && 
+                contact.phoneList.size() > 0) {
+            contact.phoneList.get(0).isPrimary = true;
+        }
+
+        if (!prefIsSetAddress && contact.contactmethodList != null) {
+            for (ContactMethod contactMethod : contact.contactmethodList) {
+                if (contactMethod.kind == Contacts.KIND_POSTAL) {
+                    contactMethod.isPrimary = true;
+                    break;
+                }
+            }
+        }
+        if (!prefIsSetEmail && contact.contactmethodList != null) {
+            for (ContactMethod contactMethod : contact.contactmethodList) {
+                if (contactMethod.kind == Contacts.KIND_EMAIL) {
+                    contactMethod.isPrimary = true;
+                    break;
+                }
+            }
+        }
+        if (!prefIsSetOrganization &&
+                contact.organizationList != null &&
+                contact.organizationList.size() > 0) {
+            contact.organizationList.get(0).isPrimary = true;
+        }
+        
+        return contact;
+    }
+    
+    public String displayString() {
+        if (name.length() > 0) {
+            return name;
+        }
+        if (contactmethodList != null && contactmethodList.size() > 0) {
+            for (ContactMethod contactMethod : contactmethodList) {
+                if (contactMethod.kind == Contacts.KIND_EMAIL && contactMethod.isPrimary) {
+                    return contactMethod.data;
+                }
+            }
+        }
+        if (phoneList != null && phoneList.size() > 0) {
+            for (PhoneData phoneData : phoneList) {
+                if (phoneData.isPrimary) {
+                    return phoneData.data;
+                }
+            }
+        }
+        return "";
+    }
+    
+//    private void pushIntoContentProviderOrResolver(Object contentSomething,
+//            long myContactsGroupId) {
+//        ContentResolver resolver = null;
+//        AbstractSyncableContentProvider provider = null;
+//        if (contentSomething instanceof ContentResolver) {
+//            resolver = (ContentResolver)contentSomething;
+//        } else if (contentSomething instanceof AbstractSyncableContentProvider) {
+//            provider = (AbstractSyncableContentProvider)contentSomething;
+//        } else {
+//            Log.e(LOG_TAG, "Unsupported object came.");
+//            return;
+//        }
+//
+//        ContentValues contentValues = new ContentValues();
+//        contentValues.put(People.NAME, name);
+//        contentValues.put(People.PHONETIC_NAME, phoneticName);
+//
+//        if (notes.size() > 1) {
+//            StringBuilder builder = new StringBuilder();
+//            for (String note : notes) {
+//                builder.append(note);
+//                builder.append("\n");
+//            }
+//            contentValues.put(People.NOTES, builder.toString());
+//        } else if (notes.size() == 1){
+//            contentValues.put(People.NOTES, notes.get(0));
+//        }
+//
+//        Uri personUri;
+//        long personId = 0;
+//        if (resolver != null) {
+//            personUri = Contacts.People.createPersonInMyContactsGroup(
+//                    resolver, contentValues);
+//            if (personUri != null) {
+//                personId = ContentUris.parseId(personUri);
+//            }
+//        } else {
+//            personUri = provider.nonTransactionalInsert(People.CONTENT_URI, contentValues);
+//            if (personUri != null) {
+//                personId = ContentUris.parseId(personUri);
+//                ContentValues values = new ContentValues();
+//                values.put(GroupMembership.PERSON_ID, personId);
+//                values.put(GroupMembership.GROUP_ID, myContactsGroupId);
+//                Uri resultUri = provider.nonTransactionalInsert(
+//                        GroupMembership.CONTENT_URI, values);
+//                if (resultUri == null) {
+//                    Log.e(LOG_TAG, "Faild to insert the person to MyContact.");
+//                    provider.nonTransactionalDelete(personUri, null, null);
+//                    personUri = null;
+//                }
+//            }
+//        }
+//
+//        if (personUri == null) {
+//            Log.e(LOG_TAG, "Failed to create the contact.");
+//            return;
+//        }
+//
+//        if (photoBytes != null) {
+//            if (resolver != null) {
+//                People.setPhotoData(resolver, personUri, photoBytes);
+//            } else {
+//                Uri photoUri = Uri.withAppendedPath(personUri, Contacts.Photos.CONTENT_DIRECTORY);
+//                ContentValues values = new ContentValues();
+//                values.put(Photos.DATA, photoBytes);
+//                provider.update(photoUri, values, null, null);
+//            }
+//        }
+//
+//        long primaryPhoneId = -1;
+//        if (phoneList != null && phoneList.size() > 0) {
+//            for (PhoneData phoneData : phoneList) {
+//                ContentValues values = new ContentValues();
+//                values.put(Contacts.PhonesColumns.TYPE, phoneData.type);
+//                if (phoneData.type == Contacts.PhonesColumns.TYPE_CUSTOM) {
+//                    values.put(Contacts.PhonesColumns.LABEL, phoneData.label);
+//                }
+//                // Already formatted.
+//                values.put(Contacts.PhonesColumns.NUMBER, phoneData.data);
+//
+//                // Not sure about Contacts.PhonesColumns.NUMBER_KEY ...
+//                values.put(Contacts.PhonesColumns.ISPRIMARY, 1);
+//                values.put(Contacts.Phones.PERSON_ID, personId);
+//                Uri phoneUri;
+//                if (resolver != null) {
+//                    phoneUri = resolver.insert(Phones.CONTENT_URI, values);
+//                } else {
+//                    phoneUri = provider.nonTransactionalInsert(Phones.CONTENT_URI, values);
+//                }
+//                if (phoneData.isPrimary) {
+//                    primaryPhoneId = Long.parseLong(phoneUri.getLastPathSegment());
+//                }
+//            }
+//        }
+//
+//        long primaryOrganizationId = -1;
+//        if (organizationList != null && organizationList.size() > 0) {
+//            for (OrganizationData organizationData : organizationList) {
+//                ContentValues values = new ContentValues();
+//                // Currently, we do not use TYPE_CUSTOM.
+//                values.put(Contacts.OrganizationColumns.TYPE,
+//                        organizationData.type);
+//                values.put(Contacts.OrganizationColumns.COMPANY,
+//                        organizationData.companyName);
+//                values.put(Contacts.OrganizationColumns.TITLE,
+//                        organizationData.positionName);
+//                values.put(Contacts.OrganizationColumns.ISPRIMARY, 1);
+//                values.put(Contacts.OrganizationColumns.PERSON_ID, personId);
+//
+//                Uri organizationUri;
+//                if (resolver != null) {
+//                    organizationUri = resolver.insert(Organizations.CONTENT_URI, values);
+//                } else {
+//                    organizationUri = provider.nonTransactionalInsert(
+//                            Organizations.CONTENT_URI, values);
+//                }
+//                if (organizationData.isPrimary) {
+//                    primaryOrganizationId = Long.parseLong(organizationUri.getLastPathSegment());
+//                }
+//            }
+//        }
+//
+//        long primaryEmailId = -1;
+//        if (contactmethodList != null && contactmethodList.size() > 0) {
+//            for (ContactMethod contactMethod : contactmethodList) {
+//                ContentValues values = new ContentValues();
+//                values.put(Contacts.ContactMethodsColumns.KIND, contactMethod.kind);
+//                values.put(Contacts.ContactMethodsColumns.TYPE, contactMethod.type);
+//                if (contactMethod.type == Contacts.ContactMethodsColumns.TYPE_CUSTOM) {
+//                    values.put(Contacts.ContactMethodsColumns.LABEL, contactMethod.label);
+//                }
+//                values.put(Contacts.ContactMethodsColumns.DATA, contactMethod.data);
+//                values.put(Contacts.ContactMethodsColumns.ISPRIMARY, 1);
+//                values.put(Contacts.ContactMethods.PERSON_ID, personId);
+//
+//                if (contactMethod.kind == Contacts.KIND_EMAIL) {
+//                    Uri emailUri;
+//                    if (resolver != null) {
+//                        emailUri = resolver.insert(ContactMethods.CONTENT_URI, values);
+//                    } else {
+//                        emailUri = provider.nonTransactionalInsert(
+//                                ContactMethods.CONTENT_URI, values);
+//                    }
+//                    if (contactMethod.isPrimary) {
+//                        primaryEmailId = Long.parseLong(emailUri.getLastPathSegment());
+//                    }
+//                } else {  // probably KIND_POSTAL
+//                    if (resolver != null) {
+//                        resolver.insert(ContactMethods.CONTENT_URI, values);
+//                    } else {
+//                        provider.nonTransactionalInsert(
+//                                ContactMethods.CONTENT_URI, values);
+//                    }
+//                }
+//            }
+//        }
+//
+//        if (extensionMap != null && extensionMap.size() > 0) {
+//            ArrayList<ContentValues> contentValuesArray;
+//            if (resolver != null) {
+//                contentValuesArray = new ArrayList<ContentValues>();
+//            } else {
+//                contentValuesArray = null;
+//            }
+//            for (Entry<String, List<String>> entry : extensionMap.entrySet()) {
+//                String key = entry.getKey();
+//                List<String> list = entry.getValue();
+//                for (String value : list) {
+//                    ContentValues values = new ContentValues();
+//                    values.put(Extensions.NAME, key);
+//                    values.put(Extensions.VALUE, value);
+//                    values.put(Extensions.PERSON_ID, personId);
+//                    if (resolver != null) {
+//                        contentValuesArray.add(values);
+//                    } else {
+//                        provider.nonTransactionalInsert(Extensions.CONTENT_URI, values);
+//                    }
+//                }
+//            }
+//            if (resolver != null) {
+//                resolver.bulkInsert(Extensions.CONTENT_URI,
+//                        contentValuesArray.toArray(new ContentValues[0]));
+//            }
+//        }
+//
+//        if (primaryPhoneId >= 0 || primaryOrganizationId >= 0 || primaryEmailId >= 0) {
+//            ContentValues values = new ContentValues();
+//            if (primaryPhoneId >= 0) {
+//                values.put(People.PRIMARY_PHONE_ID, primaryPhoneId);
+//            }
+//            if (primaryOrganizationId >= 0) {
+//                values.put(People.PRIMARY_ORGANIZATION_ID, primaryOrganizationId);
+//            }
+//            if (primaryEmailId >= 0) {
+//                values.put(People.PRIMARY_EMAIL_ID, primaryEmailId);
+//            }
+//            if (resolver != null) {
+//                resolver.update(personUri, values, null, null);
+//            } else {
+//                provider.nonTransactionalUpdate(personUri, values, null, null);
+//            }
+//        }
+//    }
+//
+//    /**
+//     * Push this object into database in the resolver.
+//     */
+//    public void pushIntoContentResolver(ContentResolver resolver) {
+//        pushIntoContentProviderOrResolver(resolver, 0);
+//    }
+//
+//    /**
+//     * Push this object into AbstractSyncableContentProvider object.
+//     */
+//    public void pushIntoAbstractSyncableContentProvider(
+//            AbstractSyncableContentProvider provider, long myContactsGroupId) {
+//        boolean successful = false;
+//        provider.beginTransaction();
+//        try {
+//            pushIntoContentProviderOrResolver(provider, myContactsGroupId);
+//            successful = true;
+//        } finally {
+//            provider.endTransaction(successful);
+//        }
+//    }
+    
+    public boolean isIgnorable() {
+        return TextUtils.isEmpty(name) &&
+                TextUtils.isEmpty(phoneticName) &&
+                (phoneList == null || phoneList.size() == 0) &&
+                (contactmethodList == null || contactmethodList.size() == 0);
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardComposer.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardComposer.java
new file mode 100755
index 0000000..d6939d2
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardComposer.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.codec.binary.Base64;
+
+import com.transage.privatespace.vcard.provider.Contacts;
+import com.transage.privatespace.vcard.pim.vcard.ContactStruct.PhoneData;
+
+/**
+ * Compose VCard string
+ */
+public class VCardComposer {
+    final public static int VERSION_VCARD21_INT = 1;
+
+    final public static int VERSION_VCARD30_INT = 2;
+
+    /**
+     * A new line
+     */
+    private String mNewline;
+
+    /**
+     * The composed string
+     */
+    private StringBuilder mResult;
+
+    /**
+     * The email's type
+     */
+    static final private HashSet<String> emailTypes = new HashSet<String>(
+            Arrays.asList("CELL", "AOL", "APPLELINK", "ATTMAIL", "CIS",
+                    "EWORLD", "INTERNET", "IBMMAIL", "MCIMAIL", "POWERSHARE",
+                    "PRODIGY", "TLX", "X400"));
+
+    static final private HashSet<String> phoneTypes = new HashSet<String>(
+            Arrays.asList("PREF", "WORK", "HOME", "VOICE", "FAX", "MSG",
+                    "CELL", "PAGER", "BBS", "MODEM", "CAR", "ISDN", "VIDEO"));
+
+    static final private String TAG = "VCardComposer";
+
+    public VCardComposer() {
+    }
+
+    private static final HashMap<Integer, String> phoneTypeMap = new HashMap<Integer, String>();
+
+    private static final HashMap<Integer, String> emailTypeMap = new HashMap<Integer, String>();
+
+    static {
+        phoneTypeMap.put(Contacts.Phones.TYPE_HOME, "HOME");
+        phoneTypeMap.put(Contacts.Phones.TYPE_MOBILE, "CELL");
+        phoneTypeMap.put(Contacts.Phones.TYPE_WORK, "WORK");
+        // FAX_WORK not exist in vcard spec. The approximate is the combine of
+        // WORK and FAX, here only map to FAX
+        phoneTypeMap.put(Contacts.Phones.TYPE_FAX_WORK, "WORK;FAX");
+        phoneTypeMap.put(Contacts.Phones.TYPE_FAX_HOME, "HOME;FAX");
+        phoneTypeMap.put(Contacts.Phones.TYPE_PAGER, "PAGER");
+        phoneTypeMap.put(Contacts.Phones.TYPE_OTHER, "X-OTHER");
+        emailTypeMap.put(Contacts.ContactMethods.TYPE_HOME, "HOME");
+        emailTypeMap.put(Contacts.ContactMethods.TYPE_WORK, "WORK");
+    }
+
+    /**
+     * Create a vCard String.
+     *
+     * @param struct
+     *            see more from ContactStruct class
+     * @param vcardversion
+     *            MUST be VERSION_VCARD21 /VERSION_VCARD30
+     * @return vCard string
+     * @throws VCardException
+     *             struct.name is null /vcardversion not match
+     */
+    public String createVCard(ContactStruct struct, int vcardversion)
+            throws VCardException {
+
+        mResult = new StringBuilder();
+        // check exception:
+        if (struct.name == null || struct.name.trim().equals("")) {
+            throw new VCardException(" struct.name MUST have value.");
+        }
+        if (vcardversion == VERSION_VCARD21_INT) {
+            mNewline = "\r\n";
+        } else if (vcardversion == VERSION_VCARD30_INT) {
+            mNewline = "\n";
+        } else {
+            throw new VCardException(
+                    " version not match VERSION_VCARD21 or VERSION_VCARD30.");
+        }
+        // build vcard:
+        mResult.append("BEGIN:VCARD").append(mNewline);
+
+        if (vcardversion == VERSION_VCARD21_INT) {
+            mResult.append("VERSION:2.1").append(mNewline);
+        } else {
+            mResult.append("VERSION:3.0").append(mNewline);
+        }
+
+        if (!isNull(struct.name)) {
+            appendNameStr(struct.name);
+        }
+
+        if (!isNull(struct.company)) {
+            mResult.append("ORG:").append(struct.company).append(mNewline);
+        }
+
+        if (struct.notes.size() > 0 && !isNull(struct.notes.get(0))) {
+            mResult.append("NOTE:").append(
+                    foldingString(struct.notes.get(0), vcardversion)).append(mNewline);
+        }
+
+        if (!isNull(struct.title)) {
+            mResult.append("TITLE:").append(
+                    foldingString(struct.title, vcardversion)).append(mNewline);
+        }
+
+        if (struct.photoBytes != null) {
+            appendPhotoStr(struct.photoBytes, struct.photoType, vcardversion);
+        }
+
+        if (struct.phoneList != null) {
+            appendPhoneStr(struct.phoneList, vcardversion);
+        }
+
+        if (struct.contactmethodList != null) {
+            appendContactMethodStr(struct.contactmethodList, vcardversion);
+        }
+
+        mResult.append("END:VCARD").append(mNewline);
+        return mResult.toString();
+    }
+
+    /**
+     * Alter str to folding supported format.
+     *
+     * @param str
+     *            the string to be folded
+     * @param version
+     *            the vcard version
+     * @return the folded string
+     */
+    private String foldingString(String str, int version) {
+        if (str.endsWith("\r\n")) {
+            str = str.substring(0, str.length() - 2);
+        } else if (str.endsWith("\n")) {
+            str = str.substring(0, str.length() - 1);
+        }
+
+        str = str.replaceAll("\r\n", "\n");
+        if (version == VERSION_VCARD21_INT) {
+            return str.replaceAll("\n", "\r\n ");
+        } else if (version == VERSION_VCARD30_INT) {
+            return str.replaceAll("\n", "\n ");
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Build LOGO property. format LOGO's param and encode value as base64.
+     *
+     * @param bytes
+     *            the binary string to be converted
+     * @param type
+     *            the type of the content
+     * @param version
+     *            the version of vcard
+     */
+    private void appendPhotoStr(byte[] bytes, String type, int version)
+            throws VCardException {
+        String value, encodingStr;
+        try {
+            value = foldingString(new String(Base64.encodeBase64(bytes, true)),
+                    version);
+        } catch (Exception e) {
+            throw new VCardException(e.getMessage());
+        }
+
+        if (isNull(type) || type.toUpperCase().indexOf("JPEG") >= 0) {
+            type = "JPEG";
+        } else if (type.toUpperCase().indexOf("GIF") >= 0) {
+            type = "GIF";
+        } else if (type.toUpperCase().indexOf("BMP") >= 0) {
+            type = "BMP";
+        } else {
+            // Handle the string like "image/tiff".
+            int indexOfSlash = type.indexOf("/");
+            if (indexOfSlash >= 0) {
+                type = type.substring(indexOfSlash + 1).toUpperCase();
+            } else {
+                type = type.toUpperCase();
+            }
+        }
+
+        mResult.append("LOGO;TYPE=").append(type);
+        if (version == VERSION_VCARD21_INT) {
+            encodingStr = ";ENCODING=BASE64:";
+            value = value + mNewline;
+        } else if (version == VERSION_VCARD30_INT) {
+            encodingStr = ";ENCODING=b:";
+        } else {
+            return;
+        }
+        mResult.append(encodingStr).append(value).append(mNewline);
+    }
+
+    private boolean isNull(String str) {
+        if (str == null || str.trim().equals("")) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Build FN and N property. format N's value.
+     *
+     * @param name
+     *            the name of the contact
+     */
+    private void appendNameStr(String name) {
+        mResult.append("FN:").append(name).append(mNewline);
+        mResult.append("N:").append(name).append(mNewline);
+        /*
+         * if(name.indexOf(";") > 0)
+         * mResult.append("N:").append(name).append(mNewline); else
+         * if(name.indexOf(" ") > 0) mResult.append("N:").append(name.replace(' ',
+         * ';')). append(mNewline); else
+         * mResult.append("N:").append(name).append("; ").append(mNewline);
+         */
+    }
+
+    /** Loop append TEL property. */
+    private void appendPhoneStr(List<PhoneData> phoneList,
+            int version) {
+        HashMap<String, String> numMap = new HashMap<String, String>();
+        String joinMark = version == VERSION_VCARD21_INT ? ";" : ",";
+
+        for (PhoneData phone : phoneList) {
+            String type;
+            if (!isNull(phone.data)) {
+                type = getPhoneTypeStr(phone);
+                if (version == VERSION_VCARD30_INT && type.indexOf(";") != -1) {
+                    type = type.replace(";", ",");
+                }
+                if (numMap.containsKey(phone.data)) {
+                    type = numMap.get(phone.data) + joinMark + type;
+                }
+                numMap.put(phone.data, type);
+            }
+        }
+
+        for (Map.Entry<String, String> num : numMap.entrySet()) {
+            if (version == VERSION_VCARD21_INT) {
+                mResult.append("TEL;");
+            } else { // vcard3.0
+                mResult.append("TEL;TYPE=");
+            }
+            mResult.append(num.getValue()).append(":").append(num.getKey())
+                    .append(mNewline);
+        }
+    }
+
+    private String getPhoneTypeStr(PhoneData phone) {
+
+        int phoneType = phone.type;
+        String typeStr, label;
+
+        if (phoneTypeMap.containsKey(phoneType)) {
+            typeStr = phoneTypeMap.get(phoneType);
+        } else if (phoneType == Contacts.Phones.TYPE_CUSTOM) {
+            label = phone.label.toUpperCase();
+            if (phoneTypes.contains(label) || label.startsWith("X-")) {
+                typeStr = label;
+            } else {
+                typeStr = "X-CUSTOM-" + label;
+            }
+        } else {
+            // TODO: need be updated with the provider's future changes
+            typeStr = "VOICE"; // the default type is VOICE in spec.
+        }
+        return typeStr;
+    }
+
+    /** Loop append ADR / EMAIL property. */
+    private void appendContactMethodStr(
+            List<ContactStruct.ContactMethod> contactMList, int version) {
+
+        HashMap<String, String> emailMap = new HashMap<String, String>();
+        String joinMark = version == VERSION_VCARD21_INT ? ";" : ",";
+        for (ContactStruct.ContactMethod contactMethod : contactMList) {
+            // same with v2.1 and v3.0
+            switch (contactMethod.kind) {
+            case Contacts.KIND_EMAIL:
+                String mailType = "INTERNET";
+                if (!isNull(contactMethod.data)) {
+                    int methodType = new Integer(contactMethod.type).intValue();
+                    if (emailTypeMap.containsKey(methodType)) {
+                        mailType = emailTypeMap.get(methodType);
+                    } else if (!isNull(contactMethod.label) && emailTypes.contains(contactMethod.label
+                            .toUpperCase())) {
+                        mailType = contactMethod.label.toUpperCase();
+                    }
+                    if (emailMap.containsKey(contactMethod.data)) {
+                        mailType = emailMap.get(contactMethod.data) + joinMark
+                                + mailType;
+                    }
+                    emailMap.put(contactMethod.data, mailType);
+                }
+                break;
+            case Contacts.KIND_POSTAL:
+                if (!isNull(contactMethod.data)) {
+                    mResult.append("ADR;TYPE=POSTAL:").append(
+                            foldingString(contactMethod.data, version)).append(
+                            mNewline);
+                }
+                break;
+            default:
+                break;
+            }
+        }
+        for (Map.Entry<String, String> email : emailMap.entrySet()) {
+            if (version == VERSION_VCARD21_INT) {
+                mResult.append("EMAIL;");
+            } else {
+                mResult.append("EMAIL;TYPE=");
+            }
+            mResult.append(email.getValue()).append(":").append(email.getKey())
+                    .append(mNewline);
+        }
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardException.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardException.java
new file mode 100755
index 0000000..a5c3363
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardException.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+public class VCardException extends Exception{
+    // constructors
+
+    /**
+     * Constructs a VCardException object
+     */
+
+    public VCardException()
+    {
+    }
+
+    /**
+     * Constructs a VCardException object
+     *
+     * @param message the error message
+     */
+
+    public VCardException( String message )
+    {
+        super( message );
+    }
+
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardNestedException.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardNestedException.java
new file mode 100755
index 0000000..647455e
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardNestedException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+/**
+ * VCardException thrown when VCard is nested without VCardParser's being notified.
+ */
+public class VCardNestedException extends VCardException {
+    public VCardNestedException() {}
+    public VCardNestedException(String message) {
+        super(message);
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardParser.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardParser.java
new file mode 100755
index 0000000..342b72e
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardParser.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+import com.transage.privatespace.vcard.pim.VDataBuilder;
+//import android.syncml.pim.VParser;
+//import android.util.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+public class VCardParser {
+
+    // TODO: fix this.
+    VCardParser_V21 mParser = null;
+
+    public final static String VERSION_VCARD21 = "vcard2.1";
+
+    public final static String VERSION_VCARD30 = "vcard3.0";
+
+    final public static int VERSION_VCARD21_INT = 1;
+
+    final public static int VERSION_VCARD30_INT = 2;
+
+    String mVersion = null;
+
+    static final private String TAG = "VCardParser";
+
+    public VCardParser() {
+    }
+
+    /**
+     * If version not given. Search from vcard string of the VERSION property.
+     * Then instance mParser to appropriate parser.
+     *
+     * @param vcardStr
+     *            the content of vcard data
+     */
+    private void judgeVersion(String vcardStr) {
+        if (mVersion == null) {// auto judge
+            int verIdx = vcardStr.indexOf("\nVERSION:");
+            if (verIdx == -1) // if not have VERSION, v2.1 default
+                mVersion = VERSION_VCARD21;
+            else {
+                String verStr = vcardStr.substring(verIdx, vcardStr.indexOf(
+                        "\n", verIdx + 1));
+                if (verStr.indexOf("2.1") > 0)
+                    mVersion = VERSION_VCARD21;
+                else if (verStr.indexOf("3.0") > 0)
+                    mVersion = VERSION_VCARD30;
+                else
+                    mVersion = VERSION_VCARD21;
+            }
+        }
+        if (mVersion.equals(VERSION_VCARD21))
+            mParser = new VCardParser_V21();
+        if (mVersion.equals(VERSION_VCARD30))
+            mParser = new VCardParser_V30();
+    }
+
+    /**
+     * To make sure the vcard string has proper wrap character
+     *
+     * @param vcardStr
+     *            the string to be checked
+     * @return string after verified
+     */
+    private String verifyVCard(String vcardStr) {
+        this.judgeVersion(vcardStr);
+        // -- indent line:
+        vcardStr = vcardStr.replaceAll("\r\n", "\n");
+        String[] strlist = vcardStr.split("\n");
+        StringBuilder v21str = new StringBuilder("");
+        for (int i = 0; i < strlist.length; i++) {
+            if (strlist[i].indexOf(":") < 0) {
+                if (strlist[i].length() == 0 && strlist[i + 1].indexOf(":") > 0)
+                    v21str.append(strlist[i]).append("\r\n");
+                else
+                    v21str.append(" ").append(strlist[i]).append("\r\n");
+            } else
+                v21str.append(strlist[i]).append("\r\n");
+        }
+        return v21str.toString();
+    }
+
+    /**
+     * Set current version
+     *
+     * @param version
+     *            the new version
+     */
+    private void setVersion(String version) {
+        this.mVersion = version;
+    }
+
+    /**
+     * Parse the given vcard string
+     *
+     * @param vcardStr
+     *            to content to be parsed
+     * @param encoding
+     *            encoding of vcardStr
+     * @param builder
+     *            the data builder to hold data
+     * @return true if the string is successfully parsed, else return false
+     * @throws VCardException
+     * @throws IOException
+     */
+    public boolean parse(String vcardStr, String encoding, VDataBuilder builder)
+            throws VCardException, IOException {
+
+        vcardStr = this.verifyVCard(vcardStr);
+
+        boolean isSuccess = mParser.parse(new ByteArrayInputStream(vcardStr
+                .getBytes(encoding)), encoding, builder);
+        if (!isSuccess) {
+            if (mVersion.equals(VERSION_VCARD21)) {
+//                if (Config.LOGD)
+//                    Log.d(TAG, "Parse failed for vCard 2.1 parser."
+//                            + " Try to use 3.0 parser.");
+
+                this.setVersion(VERSION_VCARD30);
+
+                return this.parse(vcardStr, builder);
+            }
+            throw new VCardException("parse failed.(even use 3.0 parser)");
+        }
+        return true;
+    }
+
+    /**
+     * Parse the given vcard string with US-ASCII encoding
+     *
+     * @param vcardStr
+     *            to content to be parsed
+     * @param builder
+     *            the data builder to hold data
+     * @return true if the string is successfully parsed, else return false
+     * @throws VCardException
+     * @throws IOException
+     */
+    public boolean parse(String vcardStr, VDataBuilder builder)
+            throws VCardException, IOException {
+       return parse(vcardStr, "US-ASCII", builder);
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardParser_V21.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardParser_V21.java
new file mode 100755
index 0000000..f07650f
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardParser_V21.java
@@ -0,0 +1,982 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+import com.transage.privatespace.vcard.pim.VBuilder;
+//import android.syncml.pim.VParser;
+import com.transage.privatespace.vcard.util.Log;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+
+/**
+ * This class is used to parse vcard. Please refer to vCard Specification 2.1.
+ */
+public class VCardParser_V21 {
+    private static final String LOG_TAG = "VCardParser_V21";
+    
+//    public static final String DEFAULT_CHARSET = VParser.DEFAULT_CHARSET;
+	public static final String DEFAULT_CHARSET = "UTF-8";
+    
+    /** Store the known-type */
+    private static final HashSet<String> sKnownTypeSet = new HashSet<String>(
+            Arrays.asList("DOM", "INTL", "POSTAL", "PARCEL", "HOME", "WORK",
+                    "PREF", "VOICE", "FAX", "MSG", "CELL", "PAGER", "BBS",
+                    "MODEM", "CAR", "ISDN", "VIDEO", "AOL", "APPLELINK",
+                    "ATTMAIL", "CIS", "EWORLD", "INTERNET", "IBMMAIL",
+                    "MCIMAIL", "POWERSHARE", "PRODIGY", "TLX", "X400", "GIF",
+                    "CGM", "WMF", "BMP", "MET", "PMB", "DIB", "PICT", "TIFF",
+                    "PDF", "PS", "JPEG", "QTIME", "MPEG", "MPEG2", "AVI",
+                    "WAVE", "AIFF", "PCM", "X509", "PGP"));
+
+    /** Store the known-value */
+    private static final HashSet<String> sKnownValueSet = new HashSet<String>(
+            Arrays.asList("INLINE", "URL", "CONTENT-ID", "CID"));
+        
+    /** Store the property names available in vCard 2.1 */
+    private static final HashSet<String> sAvailablePropertyNameV21 =
+        new HashSet<String>(Arrays.asList(
+                "BEGIN", "LOGO", "PHOTO", "LABEL", "FN", "TITLE", "SOUND",
+                "VERSION", "TEL", "EMAIL", "TZ", "GEO", "NOTE", "URL",
+                "BDAY", "ROLE", "REV", "UID", "KEY", "MAILER"));
+
+    // Though vCard 2.1 specification does not allow "B" encoding, some data may have it.
+    // We allow it for safety...
+    private static final HashSet<String> sAvailableEncodingV21 =
+        new HashSet<String>(Arrays.asList(
+                "7BIT", "8BIT", "QUOTED-PRINTABLE", "BASE64", "B"));
+    
+    // Used only for parsing END:VCARD.
+    private String mPreviousLine;
+    
+    /** The builder to build parsed data */
+    protected VBuilder mBuilder = null;
+
+    /** The encoding type */
+    protected String mEncoding = null;
+    
+    protected final String sDefaultEncoding = "8BIT";
+    
+    // Should not directly read a line from this. Use getLine() instead.
+    protected BufferedReader mReader;
+    
+    private boolean mCanceled;
+    
+    // In some cases, vCard is nested. Currently, we only consider the most interior vCard data.
+    // See v21_foma_1.vcf in test directory for more information.
+    private int mNestCount;
+    
+    // In order to reduce warning message as much as possible, we hold the value which made Logger
+    // emit a warning message.
+    protected HashSet<String> mWarningValueMap = new HashSet<String>();
+    
+    // Just for debugging
+    private long mTimeTotal;
+    private long mTimeStartRecord;
+    private long mTimeEndRecord;
+    private long mTimeStartProperty;
+    private long mTimeEndProperty;
+    private long mTimeParseItems;
+    private long mTimeParseItem1;
+    private long mTimeParseItem2;
+    private long mTimeParseItem3;
+    private long mTimeHandlePropertyValue1;
+    private long mTimeHandlePropertyValue2;
+    private long mTimeHandlePropertyValue3;
+    
+    /**
+     * Create a new VCard parser.
+     */
+    public VCardParser_V21() {
+        super();
+    }
+
+    public VCardParser_V21(VCardSourceDetector detector) {
+        super();
+        if (detector != null && detector.getType() == VCardSourceDetector.TYPE_FOMA) {
+            mNestCount = 1;
+        }
+    }
+    
+    /**
+     * Parse the file at the given position
+     * vcard_file   = [wsls] vcard [wsls]
+     */
+    protected void parseVCardFile() throws IOException, VCardException {
+        boolean firstReading = true;
+        while (true) {
+            if (mCanceled) {
+                break;
+            }
+            if (!parseOneVCard(firstReading)) {
+                break;
+            }
+            firstReading = false;
+        }
+
+        if (mNestCount > 0) {
+            boolean useCache = true;
+            for (int i = 0; i < mNestCount; i++) {
+                readEndVCard(useCache, true);
+                useCache = false;
+            }
+        }
+    }
+
+    protected String getVersion() {
+        return "2.1";
+    }
+    
+    /**
+     * @return true when the propertyName is a valid property name.
+     */
+    protected boolean isValidPropertyName(String propertyName) {
+        if (!(sAvailablePropertyNameV21.contains(propertyName.toUpperCase()) ||
+                propertyName.startsWith("X-")) && 
+                !mWarningValueMap.contains(propertyName)) {
+            mWarningValueMap.add(propertyName);
+            Log.w(LOG_TAG, "Property name unsupported by vCard 2.1: " + propertyName);
+        }
+        return true;
+    }
+
+    /**
+     * @return true when the encoding is a valid encoding.
+     */
+    protected boolean isValidEncoding(String encoding) {
+        return sAvailableEncodingV21.contains(encoding.toUpperCase());
+    }
+    
+    /**
+     * @return String. It may be null, or its length may be 0
+     * @throws IOException
+     */
+    protected String getLine() throws IOException {
+        return mReader.readLine();
+    }
+    
+    /**
+     * @return String with it's length > 0
+     * @throws IOException
+     * @throws VCardException when the stream reached end of line
+     */
+    protected String getNonEmptyLine() throws IOException, VCardException {
+        String line;
+        while (true) {
+            line = getLine();
+            if (line == null) {
+                throw new VCardException("Reached end of buffer.");
+            } else if (line.trim().length() > 0) {                
+                return line;
+            }
+        }
+    }
+    
+    /**
+     *  vcard        = "BEGIN" [ws] ":" [ws] "VCARD" [ws] 1*CRLF
+     *                 items *CRLF
+     *                 "END" [ws] ":" [ws] "VCARD"
+     */
+    private boolean parseOneVCard(boolean firstReading) throws IOException, VCardException {
+        boolean allowGarbage = false;
+        if (firstReading) {
+            if (mNestCount > 0) {
+                for (int i = 0; i < mNestCount; i++) {
+                    if (!readBeginVCard(allowGarbage)) {
+                        return false;
+                    }
+                    allowGarbage = true;
+                }
+            }
+        }
+
+        if (!readBeginVCard(allowGarbage)) {
+            return false;
+        }
+        long start;
+        if (mBuilder != null) {
+            start = System.currentTimeMillis();
+            mBuilder.startRecord("VCARD");
+            mTimeStartRecord += System.currentTimeMillis() - start;
+        }
+        start = System.currentTimeMillis();
+        parseItems();
+        mTimeParseItems += System.currentTimeMillis() - start;
+        readEndVCard(true, false);
+        if (mBuilder != null) {
+            start = System.currentTimeMillis();
+            mBuilder.endRecord();
+            mTimeEndRecord += System.currentTimeMillis() - start;
+        }
+        return true;
+    }
+    
+    /**
+     * @return True when successful. False when reaching the end of line  
+     * @throws IOException
+     * @throws VCardException
+     */
+    protected boolean readBeginVCard(boolean allowGarbage)
+            throws IOException, VCardException {
+        String line;
+        do {
+            while (true) {
+                line = getLine();
+                if (line == null) {
+                    return false;
+                } else if (line.trim().length() > 0) {
+                    break;
+                }
+            }
+            String[] strArray = line.split(":", 2);
+            int length = strArray.length;
+
+            // Though vCard 2.1/3.0 specification does not allow lower cases,
+            // some data may have them, so we allow it (Actually, previous code
+            // had explicitly allowed "BEGIN:vCard" though there's no example).
+            //
+            // TODO: ignore non vCard entry (e.g. vcalendar).
+            // XXX: Not sure, but according to VDataBuilder.java, vcalendar
+            // entry
+            // may be nested. Just seeking "END:SOMETHING" may not be enough.
+            // e.g.
+            // BEGIN:VCARD
+            // ... (Valid. Must parse this)
+            // END:VCARD
+            // BEGIN:VSOMETHING
+            // ... (Must ignore this)
+            // BEGIN:VSOMETHING2
+            // ... (Must ignore this)
+            // END:VSOMETHING2
+            // ... (Must ignore this!)
+            // END:VSOMETHING
+            // BEGIN:VCARD
+            // ... (Valid. Must parse this)
+            // END:VCARD
+            // INVALID_STRING (VCardException should be thrown)
+            if (length == 2 &&
+                    strArray[0].trim().equalsIgnoreCase("BEGIN") &&
+                    strArray[1].trim().equalsIgnoreCase("VCARD")) {
+                return true;
+            } else if (!allowGarbage) {
+                if (mNestCount > 0) {
+                    mPreviousLine = line;
+                    return false;
+                } else {
+                    throw new VCardException(
+                            "Expected String \"BEGIN:VCARD\" did not come "
+                            + "(Instead, \"" + line + "\" came)");
+                }
+            }
+        } while(allowGarbage);
+
+        throw new VCardException("Reached where must not be reached.");
+    }
+
+    /**
+     * The arguments useCache and allowGarbase are usually true and false accordingly when
+     * this function is called outside this function itself. 
+     * 
+     * @param useCache When true, line is obtained from mPreviousline. Otherwise, getLine()
+     * is used.
+     * @param allowGarbage When true, ignore non "END:VCARD" line.
+     * @throws IOException
+     * @throws VCardException
+     */
+    protected void readEndVCard(boolean useCache, boolean allowGarbage)
+            throws IOException, VCardException {
+        String line;
+        do {
+            if (useCache) {
+                // Though vCard specification does not allow lower cases,
+                // some data may have them, so we allow it.
+                line = mPreviousLine;
+            } else {
+                while (true) {
+                    line = getLine();
+                    if (line == null) {
+                        throw new VCardException("Expected END:VCARD was not found.");
+                    } else if (line.trim().length() > 0) {
+                        break;
+                    }
+                }
+            }
+
+            String[] strArray = line.split(":", 2);
+            if (strArray.length == 2 &&
+                    strArray[0].trim().equalsIgnoreCase("END") &&
+                    strArray[1].trim().equalsIgnoreCase("VCARD")) {
+                return;
+            } else if (!allowGarbage) {
+                throw new VCardException("END:VCARD != \"" + mPreviousLine + "\"");
+            }
+            useCache = false;
+        } while (allowGarbage);
+    }
+    
+    /**
+     * items = *CRLF item 
+     *       / item
+     */
+    protected void parseItems() throws IOException, VCardException {
+        /* items *CRLF item / item */
+        boolean ended = false;
+        
+        if (mBuilder != null) {
+            long start = System.currentTimeMillis();
+            mBuilder.startProperty();
+            mTimeStartProperty += System.currentTimeMillis() - start;
+        }
+        ended = parseItem();
+        if (mBuilder != null && !ended) {
+            long start = System.currentTimeMillis();
+            mBuilder.endProperty();
+            mTimeEndProperty += System.currentTimeMillis() - start;
+        }
+
+        while (!ended) {
+            // follow VCARD ,it wont reach endProperty
+            if (mBuilder != null) {
+                long start = System.currentTimeMillis();
+                mBuilder.startProperty();
+                mTimeStartProperty += System.currentTimeMillis() - start;
+            }
+            ended = parseItem();
+            if (mBuilder != null && !ended) {
+                long start = System.currentTimeMillis();
+                mBuilder.endProperty();
+                mTimeEndProperty += System.currentTimeMillis() - start;
+            }
+        }
+    }
+    
+    /**
+     * item      = [groups "."] name    [params] ":" value CRLF
+     *           / [groups "."] "ADR"   [params] ":" addressparts CRLF
+     *           / [groups "."] "ORG"   [params] ":" orgparts CRLF
+     *           / [groups "."] "N"     [params] ":" nameparts CRLF
+     *           / [groups "."] "AGENT" [params] ":" vcard CRLF 
+     */
+    protected boolean parseItem() throws IOException, VCardException {
+        mEncoding = sDefaultEncoding;
+
+        String line = getNonEmptyLine();
+        long start = System.currentTimeMillis();
+
+        String[] propertyNameAndValue = separateLineAndHandleGroup(line);
+        if (propertyNameAndValue == null) {
+            return true;
+        }
+        if (propertyNameAndValue.length != 2) {
+            throw new VCardException("Invalid line \"" + line + "\""); 
+        }
+        String propertyName = propertyNameAndValue[0].toUpperCase();
+        String propertyValue = propertyNameAndValue[1];
+
+        mTimeParseItem1 += System.currentTimeMillis() - start;
+
+        if (propertyName.equals("ADR") ||
+                propertyName.equals("ORG") ||
+                propertyName.equals("N")) {
+            start = System.currentTimeMillis();
+            handleMultiplePropertyValue(propertyName, propertyValue);
+            mTimeParseItem3 += System.currentTimeMillis() - start;
+            return false;
+        } else if (propertyName.equals("AGENT")) {
+            handleAgent(propertyValue);
+            return false;
+        } else if (isValidPropertyName(propertyName)) {
+            if (propertyName.equals("BEGIN")) {
+                if (propertyValue.equals("VCARD")) {
+                    throw new VCardNestedException("This vCard has nested vCard data in it.");
+                } else {
+                    throw new VCardException("Unknown BEGIN type: " + propertyValue);
+                }
+            } else if (propertyName.equals("VERSION") &&
+                    !propertyValue.equals(getVersion())) {
+                throw new VCardVersionException("Incompatible version: " + 
+                        propertyValue + " != " + getVersion());
+            }
+            start = System.currentTimeMillis();
+            handlePropertyValue(propertyName, propertyValue);
+            mTimeParseItem2 += System.currentTimeMillis() - start;
+            return false;
+        }
+        
+        throw new VCardException("Unknown property name: \"" + 
+                propertyName + "\"");
+    }
+
+    static private final int STATE_GROUP_OR_PROPNAME = 0;
+    static private final int STATE_PARAMS = 1;
+    // vCard 3.1 specification allows double-quoted param-value, while vCard 2.1 does not.
+    // This is just for safety.
+    static private final int STATE_PARAMS_IN_DQUOTE = 2;
+    
+    protected String[] separateLineAndHandleGroup(String line) throws VCardException {
+        int length = line.length();
+        int state = STATE_GROUP_OR_PROPNAME;
+        int nameIndex = 0;
+
+        String[] propertyNameAndValue = new String[2];
+        
+        for (int i = 0; i < length; i++) {
+            char ch = line.charAt(i); 
+            switch (state) {
+            case STATE_GROUP_OR_PROPNAME:
+                if (ch == ':') { 
+                    String propertyName = line.substring(nameIndex, i);
+                    if (propertyName.equalsIgnoreCase("END")) {
+                        mPreviousLine = line;
+                        return null;
+                    }
+                    if (mBuilder != null) {
+                        mBuilder.propertyName(propertyName);
+                    }
+                    propertyNameAndValue[0] = propertyName; 
+                    if (i < length - 1) {
+                        propertyNameAndValue[1] = line.substring(i + 1); 
+                    } else {
+                        propertyNameAndValue[1] = "";
+                    }
+                    return propertyNameAndValue;
+                } else if (ch == '.') {
+                    String groupName = line.substring(nameIndex, i);
+                    if (mBuilder != null) {
+                        mBuilder.propertyGroup(groupName);
+                    }
+                    nameIndex = i + 1;
+                } else if (ch == ';') {
+                    String propertyName = line.substring(nameIndex, i);
+                    if (propertyName.equalsIgnoreCase("END")) {
+                        mPreviousLine = line;
+                        return null;
+                    }
+                    if (mBuilder != null) {
+                        mBuilder.propertyName(propertyName);
+                    }
+                    propertyNameAndValue[0] = propertyName;
+                    nameIndex = i + 1;
+                    state = STATE_PARAMS;
+                }
+                break;
+            case STATE_PARAMS:
+                if (ch == '"') {
+                    state = STATE_PARAMS_IN_DQUOTE;
+                } else if (ch == ';') { 
+                    handleParams(line.substring(nameIndex, i));
+                    nameIndex = i + 1;
+                } else if (ch == ':') {
+                    handleParams(line.substring(nameIndex, i));
+                    if (i < length - 1) {
+                        propertyNameAndValue[1] = line.substring(i + 1);
+                    } else {
+                        propertyNameAndValue[1] = "";
+                    }
+                    return propertyNameAndValue;
+                }
+                break;
+            case STATE_PARAMS_IN_DQUOTE:
+                if (ch == '"') {
+                    state = STATE_PARAMS;
+                }
+                break;
+            }
+        }
+        
+        throw new VCardException("Invalid line: \"" + line + "\"");
+    }
+    
+    
+    /**
+     * params      = ";" [ws] paramlist
+     * paramlist   = paramlist [ws] ";" [ws] param
+     *             / param
+     * param       = "TYPE" [ws] "=" [ws] ptypeval
+     *             / "VALUE" [ws] "=" [ws] pvalueval
+     *             / "ENCODING" [ws] "=" [ws] pencodingval
+     *             / "CHARSET" [ws] "=" [ws] charsetval
+     *             / "LANGUAGE" [ws] "=" [ws] langval
+     *             / "X-" word [ws] "=" [ws] word
+     *             / knowntype
+     */
+    protected void handleParams(String params) throws VCardException {
+        String[] strArray = params.split("=", 2);
+        if (strArray.length == 2) {
+            String paramName = strArray[0].trim();
+            String paramValue = strArray[1].trim();
+            if (paramName.equals("TYPE")) {
+                handleType(paramValue);
+            } else if (paramName.equals("VALUE")) {
+                handleValue(paramValue);
+            } else if (paramName.equals("ENCODING")) {
+                handleEncoding(paramValue);
+            } else if (paramName.equals("CHARSET")) {
+                handleCharset(paramValue);
+            } else if (paramName.equals("LANGUAGE")) {
+                handleLanguage(paramValue);
+            } else if (paramName.startsWith("X-")) {
+                handleAnyParam(paramName, paramValue);
+            } else {
+                throw new VCardException("Unknown type \"" + paramName + "\"");
+            }
+        } else {
+            handleType(strArray[0]);
+        }
+    }
+    
+    /**
+     * ptypeval  = knowntype / "X-" word
+     */
+    protected void handleType(String ptypeval) {
+        String upperTypeValue = ptypeval;
+        if (!(sKnownTypeSet.contains(upperTypeValue) || upperTypeValue.startsWith("X-")) && 
+                !mWarningValueMap.contains(ptypeval)) {
+            mWarningValueMap.add(ptypeval);
+            Log.w(LOG_TAG, "Type unsupported by vCard 2.1: " + ptypeval);
+        }
+        if (mBuilder != null) {
+            mBuilder.propertyParamType("TYPE");
+            mBuilder.propertyParamValue(upperTypeValue);
+        }
+    }
+    
+    /**
+     * pvalueval = "INLINE" / "URL" / "CONTENT-ID" / "CID" / "X-" word
+     */
+    protected void handleValue(String pvalueval) throws VCardException {
+        if (sKnownValueSet.contains(pvalueval.toUpperCase()) ||
+                pvalueval.startsWith("X-")) {
+            if (mBuilder != null) {
+                mBuilder.propertyParamType("VALUE");
+                mBuilder.propertyParamValue(pvalueval);
+            }
+        } else {
+            throw new VCardException("Unknown value \"" + pvalueval + "\"");
+        }
+    }
+    
+    /**
+     * pencodingval = "7BIT" / "8BIT" / "QUOTED-PRINTABLE" / "BASE64" / "X-" word
+     */
+    protected void handleEncoding(String pencodingval) throws VCardException {
+        if (isValidEncoding(pencodingval) ||
+                pencodingval.startsWith("X-")) {
+            if (mBuilder != null) {
+                mBuilder.propertyParamType("ENCODING");
+                mBuilder.propertyParamValue(pencodingval);
+            }
+            mEncoding = pencodingval;
+        } else {
+            throw new VCardException("Unknown encoding \"" + pencodingval + "\"");
+        }
+    }
+    
+    /**
+     * vCard specification only allows us-ascii and iso-8859-xxx (See RFC 1521),
+     * but some vCard contains other charset, so we allow them. 
+     */
+    protected void handleCharset(String charsetval) {
+        if (mBuilder != null) {
+            mBuilder.propertyParamType("CHARSET");
+            mBuilder.propertyParamValue(charsetval);
+        }
+    }
+    
+    /**
+     * See also Section 7.1 of RFC 1521
+     */
+    protected void handleLanguage(String langval) throws VCardException {
+        //modified to handle LANGUAGE codes properly - it crashed on vcards
+        //from MS Outlook
+        //see http://code.google.com/p/android-vcard/issues/detail?id=3
+        final String[] strArray = langval.split("-");
+        if (strArray.length > 2) {
+            throw new VCardException("Invalid Language: \"" + langval + "\"");
+        }
+        String tmp = strArray[0];
+        int length = tmp.length();
+        for (int i = 0; i < length; i++) {
+            if (!isLetter(tmp.charAt(i))) {
+                throw new VCardException("Invalid Language: \"" + langval + "\"");
+            }
+        }
+
+        if (strArray.length > 1) {
+            tmp = strArray[1];
+            length = tmp.length();
+            for (int i = 0; i < length; i++) {
+                if (!isLetter(tmp.charAt(i))) {
+                    throw new VCardException("Invalid Language: \"" + langval + "\"");
+                }
+            }
+        }
+        if (mBuilder != null) {
+            mBuilder.propertyParamType("LANGUAGE");
+            mBuilder.propertyParamValue(langval);
+        }
+    }
+
+    /**
+     * Mainly for "X-" type. This accepts any kind of type without check.
+     */
+    protected void handleAnyParam(String paramName, String paramValue) {
+        if (mBuilder != null) {
+            mBuilder.propertyParamType(paramName);
+            mBuilder.propertyParamValue(paramValue);
+        }
+    }
+    
+    protected void handlePropertyValue(
+            String propertyName, String propertyValue) throws
+            IOException, VCardException {
+        if (mEncoding.equalsIgnoreCase("QUOTED-PRINTABLE")) {
+            long start = System.currentTimeMillis();
+            String result = getQuotedPrintable(propertyValue);
+            if (mBuilder != null) {
+                ArrayList<String> v = new ArrayList<String>();
+                v.add(result);
+                mBuilder.propertyValues(v);
+            }
+            mTimeHandlePropertyValue2 += System.currentTimeMillis() - start;
+        } else if (mEncoding.equalsIgnoreCase("BASE64") ||
+                mEncoding.equalsIgnoreCase("B")) {
+            long start = System.currentTimeMillis();
+            // It is very rare, but some BASE64 data may be so big that
+            // OutOfMemoryError occurs. To ignore such cases, use try-catch.
+            try {
+                String result = getBase64(propertyValue);
+                if (mBuilder != null) {
+                    ArrayList<String> v = new ArrayList<String>();
+                    v.add(result);
+                    mBuilder.propertyValues(v);
+                }
+            } catch (OutOfMemoryError error) {
+                Log.e(LOG_TAG, "OutOfMemoryError happened during parsing BASE64 data!");
+                if (mBuilder != null) {
+                    mBuilder.propertyValues(null);
+                }
+            }
+            mTimeHandlePropertyValue3 += System.currentTimeMillis() - start;
+        } else {
+            if (!(mEncoding == null || mEncoding.equalsIgnoreCase("7BIT")
+                    || mEncoding.equalsIgnoreCase("8BIT")
+                    || mEncoding.toUpperCase().startsWith("X-"))) {
+                Log.w(LOG_TAG, "The encoding unsupported by vCard spec: \"" + mEncoding + "\".");
+            }
+
+            long start = System.currentTimeMillis();
+            if (mBuilder != null) {
+                ArrayList<String> v = new ArrayList<String>();
+                v.add(maybeUnescapeText(propertyValue));
+                mBuilder.propertyValues(v);
+            }
+            mTimeHandlePropertyValue1 += System.currentTimeMillis() - start;
+        }
+    }
+    
+    protected String getQuotedPrintable(String firstString) throws IOException, VCardException {
+        // Specifically, there may be some padding between = and CRLF.
+        // See the following:
+        //
+        // qp-line := *(qp-segment transport-padding CRLF)
+        //            qp-part transport-padding
+        // qp-segment := qp-section *(SPACE / TAB) "="
+        //             ; Maximum length of 76 characters
+        //
+        // e.g. (from RFC 2045)
+        // Now's the time =
+        // for all folk to come=
+        //  to the aid of their country.
+        if (firstString.trim().endsWith("=")) {
+            // remove "transport-padding"
+            int pos = firstString.length() - 1;
+            while(firstString.charAt(pos) != '=') {
+            }
+            StringBuilder builder = new StringBuilder();
+            builder.append(firstString.substring(0, pos + 1));
+            builder.append("\r\n");
+            String line;
+            while (true) {
+                line = getLine();
+                if (line == null) {
+                    throw new VCardException(
+                            "File ended during parsing quoted-printable String");
+                }
+                if (line.trim().endsWith("=")) {
+                    // remove "transport-padding"
+                    pos = line.length() - 1;
+                    while(line.charAt(pos) != '=') {
+                    }
+                    builder.append(line.substring(0, pos + 1));
+                    builder.append("\r\n");
+                } else {
+                    builder.append(line);
+                    break;
+                }
+            }
+            return builder.toString(); 
+        } else {
+            return firstString;
+        }
+    }
+    
+    protected String getBase64(String firstString) throws IOException, VCardException {
+        StringBuilder builder = new StringBuilder();
+        builder.append(firstString);
+        
+        while (true) {
+            String line = getLine();
+            if (line == null) {
+                throw new VCardException(
+                        "File ended during parsing BASE64 binary");
+            }
+            if (line.length() == 0) {
+                break;
+            }
+            builder.append(line);
+        }
+        
+        return builder.toString();
+    }
+    
+    /**
+     * Mainly for "ADR", "ORG", and "N"
+     * We do not care the number of strnosemi here.
+     * 
+     * addressparts = 0*6(strnosemi ";") strnosemi
+     *              ; PO Box, Extended Addr, Street, Locality, Region,
+     *                Postal Code, Country Name
+     * orgparts     = *(strnosemi ";") strnosemi
+     *              ; First is Organization Name,
+     *                remainder are Organization Units.
+     * nameparts    = 0*4(strnosemi ";") strnosemi
+     *              ; Family, Given, Middle, Prefix, Suffix.
+     *              ; Example:Public;John;Q.;Reverend Dr.;III, Esq.
+     * strnosemi    = *(*nonsemi ("\;" / "\" CRLF)) *nonsemi
+     *              ; To include a semicolon in this string, it must be escaped
+     *              ; with a "\" character.
+     *              
+     * We are not sure whether we should add "\" CRLF to each value.
+     * For now, we exclude them.               
+     */
+    protected void handleMultiplePropertyValue(
+            String propertyName, String propertyValue) throws IOException, VCardException {
+        // vCard 2.1 does not allow QUOTED-PRINTABLE here, but some data have it.
+        if (mEncoding.equalsIgnoreCase("QUOTED-PRINTABLE")) {
+            propertyValue = getQuotedPrintable(propertyValue);
+        }
+
+        if (mBuilder != null) {
+            // TODO: limit should be set in accordance with propertyName?
+            StringBuilder builder = new StringBuilder();
+            ArrayList<String> list = new ArrayList<String>();
+            int length = propertyValue.length();
+            for (int i = 0; i < length; i++) {
+                char ch = propertyValue.charAt(i);
+                if (ch == '\\' && i < length - 1) {
+                    char nextCh = propertyValue.charAt(i + 1);
+                    String unescapedString = maybeUnescape(nextCh); 
+                    if (unescapedString != null) {
+                        builder.append(unescapedString);
+                        i++;
+                    } else {
+                        builder.append(ch);
+                    }
+                } else if (ch == ';') {
+                    list.add(builder.toString());
+                    builder = new StringBuilder();
+                } else {
+                    builder.append(ch);
+                }
+            }
+            list.add(builder.toString());
+            mBuilder.propertyValues(list);
+        }
+    }
+    
+    /**
+     * vCard 2.1 specifies AGENT allows one vcard entry. It is not encoded at all.
+     * 
+     * item     = ...
+     *          / [groups "."] "AGENT"
+     *            [params] ":" vcard CRLF
+     * vcard    = "BEGIN" [ws] ":" [ws] "VCARD" [ws] 1*CRLF
+     *            items *CRLF "END" [ws] ":" [ws] "VCARD"
+     * 
+     */
+    protected void handleAgent(String propertyValue) throws VCardException {
+        throw new VCardException("AGENT Property is not supported.");
+        /* This is insufficient support. Also, AGENT Property is very rare.
+           Ignore it for now.
+           TODO: fix this.
+
+        String[] strArray = propertyValue.split(":", 2);
+        if (!(strArray.length == 2 ||
+                strArray[0].trim().equalsIgnoreCase("BEGIN") && 
+                strArray[1].trim().equalsIgnoreCase("VCARD"))) {
+            throw new VCardException("BEGIN:VCARD != \"" + propertyValue + "\"");
+        }
+        parseItems();
+        readEndVCard();
+        */
+    }
+    
+    /**
+     * For vCard 3.0.
+     */
+    protected String maybeUnescapeText(String text) {
+        return text;
+    }
+    
+    /**
+     * Returns unescaped String if the character should be unescaped. Return null otherwise.
+     * e.g. In vCard 2.1, "\;" should be unescaped into ";" while "\x" should not be.
+     */
+    protected String maybeUnescape(char ch) {
+        // Original vCard 2.1 specification does not allow transformation
+        // "\:" -> ":", "\," -> ",", and "\\" -> "\", but previous implementation of
+        // this class allowed them, so keep it as is.
+        if (ch == '\\' || ch == ';' || ch == ':' || ch == ',') {
+            return String.valueOf(ch);
+        } else {
+            return null;
+        }
+    }
+    
+    /**
+     * Parse the given stream and constructs VCardDataBuilder object.
+     * Note that vCard 2.1 specification allows "CHARSET" parameter, and some career sets
+     * local encoding to it. For example, Japanese phone career uses Shift_JIS, which
+     * is not formally allowed in vCard specification.
+     * As a result, there is a case where the encoding given here does not do well with
+     * the "CHARSET".
+     * 
+     * In order to avoid such cases, It may be fine to use "ISO-8859-1" as an encoding,
+     * and to encode each localized String afterward.
+     * 
+     * RFC 2426 "recommends" (not forces) to use UTF-8, so it may be OK to use
+     * UTF-8 as an encoding when parsing vCard 3.0. But note that some Japanese
+     * phone uses Shift_JIS as a charset (e.g. W61SH), and another uses
+     * "CHARSET=SHIFT_JIS", which is explicitly prohibited in vCard 3.0 specification
+     * (e.g. W53K). 
+     *      
+     * @param is
+     *            The source to parse.
+     * @param charset
+     *            The charset.
+     * @param builder
+     *            The v builder which used to construct data.
+     * @return Return true for success, otherwise false.
+     * @throws IOException
+     */
+    public boolean parse(InputStream is, String charset, VBuilder builder)
+            throws IOException, VCardException {
+        // TODO: make this count error entries instead of just throwing VCardException.
+        
+        // TODO: If we really need to allow only CRLF as line break,
+        // we will have to develop our own BufferedReader().
+        mReader = new CustomBufferedReader(new InputStreamReader(is, charset));
+        
+        mBuilder = builder;
+
+        long start = System.currentTimeMillis();
+        if (mBuilder != null) {
+            mBuilder.start();
+        }
+        parseVCardFile();
+        if (mBuilder != null) {
+            mBuilder.end();
+        }
+        mTimeTotal += System.currentTimeMillis() - start;
+                
+        return true;
+    }
+    
+    public boolean parse(InputStream is, VBuilder builder) throws IOException, VCardException {
+        return parse(is, DEFAULT_CHARSET, builder);
+    }
+    
+    /**
+     * Cancel parsing.
+     * Actual cancel is done after the end of the current one vcard entry parsing.
+     */
+    public void cancel() {
+        mCanceled = true;
+    }
+    
+    /**
+     * It is very, very rare case, but there is a case where
+     * canceled may be already true outside this object.
+     * @hide
+     */
+    public void parse(InputStream is, String charset, VBuilder builder, boolean canceled)
+            throws IOException, VCardException {
+        mCanceled = canceled;
+        parse(is, charset, builder);
+    }
+    
+    public void showDebugInfo() {
+        Log.d(LOG_TAG, "total parsing time:  " + mTimeTotal + " ms");
+        if (mReader instanceof CustomBufferedReader) {
+            Log.d(LOG_TAG, "total readLine time: " +
+                    ((CustomBufferedReader)mReader).getTotalmillisecond() + " ms");
+        }
+        Log.d(LOG_TAG, "mTimeStartRecord: " + mTimeStartRecord + " ms");
+        Log.d(LOG_TAG, "mTimeEndRecord: " + mTimeEndRecord + " ms");
+        Log.d(LOG_TAG, "mTimeParseItem1: " + mTimeParseItem1 + " ms");
+        Log.d(LOG_TAG, "mTimeParseItem2: " + mTimeParseItem2 + " ms");
+        Log.d(LOG_TAG, "mTimeParseItem3: " + mTimeParseItem3 + " ms");
+        Log.d(LOG_TAG, "mTimeHandlePropertyValue1: " + mTimeHandlePropertyValue1 + " ms");
+        Log.d(LOG_TAG, "mTimeHandlePropertyValue2: " + mTimeHandlePropertyValue2 + " ms");
+        Log.d(LOG_TAG, "mTimeHandlePropertyValue3: " + mTimeHandlePropertyValue3 + " ms");
+    }
+    
+    private boolean isLetter(char ch) {
+        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
+            return true;
+        }
+        return false;
+    }
+}
+
+class CustomBufferedReader extends BufferedReader {
+    private long mTime;
+    
+    public CustomBufferedReader(Reader in) {
+        super(in);
+    }
+    
+    @Override
+    public String readLine() throws IOException {
+        long start = System.currentTimeMillis();
+        String ret = super.readLine();
+        long end = System.currentTimeMillis();
+        mTime += end - start;
+        return ret;
+    }
+    
+    public long getTotalmillisecond() {
+        return mTime;
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardParser_V30.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardParser_V30.java
new file mode 100755
index 0000000..abd8eb8
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardParser_V30.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+import com.transage.privatespace.vcard.util.Log;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+
+/**
+ * This class is used to parse vcard3.0. <br>
+ * Please refer to vCard Specification 3.0 (http://tools.ietf.org/html/rfc2426)
+ */
+public class VCardParser_V30 extends VCardParser_V21 {
+    private static final String LOG_TAG = "VCardParser_V30";
+    
+    private static final HashSet<String> acceptablePropsWithParam = new HashSet<String>(
+            Arrays.asList(
+                    "BEGIN", "LOGO", "PHOTO", "LABEL", "FN", "TITLE", "SOUND", 
+                    "VERSION", "TEL", "EMAIL", "TZ", "GEO", "NOTE", "URL",
+                    "BDAY", "ROLE", "REV", "UID", "KEY", "MAILER", // 2.1
+                    "NAME", "PROFILE", "SOURCE", "NICKNAME", "CLASS",
+                    "SORT-STRING", "CATEGORIES", "PRODID")); // 3.0
+    
+    // Although "7bit" and "BASE64" is not allowed in vCard 3.0, we allow it for safety.
+    private static final HashSet<String> sAcceptableEncodingV30 = new HashSet<String>(
+            Arrays.asList("7BIT", "8BIT", "BASE64", "B"));
+    
+    // Although RFC 2426 specifies some property must not have parameters, we allow it, 
+    // since there may be some careers which violates the RFC...
+    private static final HashSet<String> acceptablePropsWithoutParam = new HashSet<String>();
+
+    private String mPreviousLine;
+    
+    @Override
+    protected String getVersion() {
+        return "3.0";
+    }
+    
+    @Override
+    protected boolean isValidPropertyName(String propertyName) {
+        if (!(acceptablePropsWithParam.contains(propertyName) ||
+                acceptablePropsWithoutParam.contains(propertyName) ||
+                propertyName.startsWith("X-")) &&
+                !mWarningValueMap.contains(propertyName)) {
+            mWarningValueMap.add(propertyName);
+            Log.w(LOG_TAG, "Property name unsupported by vCard 3.0: " + propertyName);
+        }
+        return true;
+    }
+    
+    @Override
+    protected boolean isValidEncoding(String encoding) {
+        return sAcceptableEncodingV30.contains(encoding.toUpperCase());
+    }
+    
+    @Override
+    protected String getLine() throws IOException {
+        if (mPreviousLine != null) {
+            String ret = mPreviousLine;
+            mPreviousLine = null;
+            return ret;
+        } else {
+            return mReader.readLine();
+        }
+    }
+    
+    /**
+     * vCard 3.0 requires that the line with space at the beginning of the line
+     * must be combined with previous line. 
+     */
+    @Override
+    protected String getNonEmptyLine() throws IOException, VCardException {
+        String line;
+        StringBuilder builder = null;
+        while (true) {
+            line = mReader.readLine();
+            if (line == null) {
+                if (builder != null) {
+                    return builder.toString();
+                } else if (mPreviousLine != null) {
+                    String ret = mPreviousLine;
+                    mPreviousLine = null;
+                    return ret;
+                }
+                throw new VCardException("Reached end of buffer.");
+            } else if (line.length() == 0) {
+                if (builder != null) {
+                    return builder.toString();
+                } else if (mPreviousLine != null) {
+                    String ret = mPreviousLine;
+                    mPreviousLine = null;
+                    return ret;
+                }
+            } else if (line.charAt(0) == ' ' || line.charAt(0) == '\t') {
+                if (builder != null) {
+                    // See Section 5.8.1 of RFC 2425 (MIME-DIR document).
+                    // Following is the excerpts from it.  
+                    //
+                    // DESCRIPTION:This is a long description that exists on a long line.
+                    // 
+                    // Can be represented as:
+                    //
+                    // DESCRIPTION:This is a long description
+                    //  that exists on a long line.
+                    //
+                    // It could also be represented as:
+                    //
+                    // DESCRIPTION:This is a long descrip
+                    //  tion that exists o
+                    //  n a long line.
+                    builder.append(line.substring(1));
+                } else if (mPreviousLine != null) {
+                    builder = new StringBuilder();
+                    builder.append(mPreviousLine);
+                    mPreviousLine = null;
+                    builder.append(line.substring(1));
+                } else {
+                    throw new VCardException("Space exists at the beginning of the line");
+                }
+            } else {
+                if (mPreviousLine == null) {
+                    mPreviousLine = line;
+                    if (builder != null) {
+                        return builder.toString();
+                    }
+                } else {
+                    String ret = mPreviousLine;
+                    mPreviousLine = line;
+                    return ret;
+                }
+            }
+        }
+    }
+    
+    
+    /**
+     * vcard = [group "."] "BEGIN" ":" "VCARD" 1*CRLF
+     *         1*(contentline)
+     *         ;A vCard object MUST include the VERSION, FN and N types.
+     *         [group "."] "END" ":" "VCARD" 1*CRLF
+     */
+    @Override
+    protected boolean readBeginVCard(boolean allowGarbage) throws IOException, VCardException {
+        // TODO: vCard 3.0 supports group.
+        return super.readBeginVCard(allowGarbage);
+    }
+    
+    @Override
+    protected void readEndVCard(boolean useCache, boolean allowGarbage)
+            throws IOException, VCardException {
+        // TODO: vCard 3.0 supports group.
+        super.readEndVCard(useCache, allowGarbage);
+    }
+
+    /**
+     * vCard 3.0 allows iana-token as paramType, while vCard 2.1 does not.
+     */
+    @Override
+    protected void handleParams(String params) throws VCardException {
+        try {
+            super.handleParams(params);
+        } catch (VCardException e) {
+            // maybe IANA type
+            String[] strArray = params.split("=", 2);
+            if (strArray.length == 2) {
+                handleAnyParam(strArray[0], strArray[1]);
+            } else {
+                // Must not come here in the current implementation.
+                throw new VCardException(
+                        "Unknown params value: " + params);
+            }
+        }
+    }
+    
+    @Override
+    protected void handleAnyParam(String paramName, String paramValue) {
+        // vCard 3.0 accept comma-separated multiple values, but
+        // current PropertyNode does not accept it.
+        // For now, we do not split the values.
+        //
+        // TODO: fix this.
+        super.handleAnyParam(paramName, paramValue);
+    }
+    
+    /**
+     *  vCard 3.0 defines
+     *  
+     *  param         = param-name "=" param-value *("," param-value)
+     *  param-name    = iana-token / x-name
+     *  param-value   = ptext / quoted-string
+     *  quoted-string = DQUOTE QSAFE-CHAR DQUOTE
+     */
+    @Override
+    protected void handleType(String ptypevalues) {
+        String[] ptypeArray = ptypevalues.split(",");
+        mBuilder.propertyParamType("TYPE");
+        for (String value : ptypeArray) {
+            int length = value.length();
+            if (length >= 2 && value.startsWith("\"") && value.endsWith("\"")) {
+                mBuilder.propertyParamValue(value.substring(1, value.length() - 1));
+            } else {
+                mBuilder.propertyParamValue(value);
+            }
+        }
+    }
+
+    @Override
+    protected void handleAgent(String propertyValue) throws VCardException {
+        // The way how vCard 3.0 supports "AGENT" is completely different from vCard 2.0.
+        //
+        // e.g.
+        // AGENT:BEGIN:VCARD\nFN:Joe Friday\nTEL:+1-919-555-7878\n
+        //  TITLE:Area Administrator\, Assistant\n EMAIL\;TYPE=INTERN\n
+        //  ET:jfriday@host.com\nEND:VCARD\n
+        //
+        // TODO: fix this.
+        //
+        // issue:
+        //  vCard 3.0 also allows this as an example.
+        //
+        // AGENT;VALUE=uri:
+        //  CID:JQPUBLIC.part3.960129T083020.xyzMail@host3.com
+        //
+        // This is not VCARD. Should we support this?
+        throw new VCardException("AGENT in vCard 3.0 is not supported yet.");
+    }
+    
+    /**
+     * vCard 3.0 does not require two CRLF at the last of BASE64 data.
+     * It only requires that data should be MIME-encoded.
+     */
+    @Override
+    protected String getBase64(String firstString) throws IOException, VCardException {
+        StringBuilder builder = new StringBuilder();
+        builder.append(firstString);
+        
+        while (true) {
+            String line = getLine();
+            if (line == null) {
+                throw new VCardException(
+                        "File ended during parsing BASE64 binary");
+            }
+            if (line.length() == 0) {
+                break;
+            } else if (!line.startsWith(" ") && !line.startsWith("\t")) {
+                mPreviousLine = line;
+                break;
+            }
+            builder.append(line);
+        }
+        
+        return builder.toString();
+    }
+    
+    /**
+     * ESCAPED-CHAR = "\\" / "\;" / "\," / "\n" / "\N")
+     *              ; \\ encodes \, \n or \N encodes newline
+     *              ; \; encodes ;, \, encodes ,
+     *              
+     * Note: Apple escape ':' into '\:' while does not escape '\'
+     */ 
+    @Override
+    protected String maybeUnescapeText(String text) {
+        StringBuilder builder = new StringBuilder();
+        int length = text.length();
+        for (int i = 0; i < length; i++) {
+            char ch = text.charAt(i);
+            if (ch == '\\' && i < length - 1) {
+                char next_ch = text.charAt(++i); 
+                if (next_ch == 'n' || next_ch == 'N') {
+                    builder.append("\r\n");
+                } else {
+                    builder.append(next_ch);
+                }
+            } else {
+                builder.append(ch);
+            }
+        }
+        return builder.toString();
+    }
+    
+    @Override
+    protected String maybeUnescape(char ch) {
+        if (ch == 'n' || ch == 'N') {
+            return "\r\n";
+        } else {
+            return String.valueOf(ch);
+        }
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardSourceDetector.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardSourceDetector.java
new file mode 100755
index 0000000..fbe94eb
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardSourceDetector.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+import com.transage.privatespace.vcard.pim.VBuilder;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Class which tries to detects the source of the vCard from its properties.
+ * Currently this implementation is very premature.
+ * @hide
+ */
+public class VCardSourceDetector implements VBuilder {
+    // Should only be used in package. 
+    static final int TYPE_UNKNOWN = 0;
+    static final int TYPE_APPLE = 1;
+    static final int TYPE_JAPANESE_MOBILE_PHONE = 2;  // Used in Japanese mobile phones.
+    static final int TYPE_FOMA = 3;  // Used in some Japanese FOMA mobile phones.
+    static final int TYPE_WINDOWS_MOBILE_JP = 4;
+    // TODO: Excel, etc.
+
+    private static Set<String> APPLE_SIGNS = new HashSet<String>(Arrays.asList(
+            "X-PHONETIC-FIRST-NAME", "X-PHONETIC-MIDDLE-NAME", "X-PHONETIC-LAST-NAME",
+            "X-ABADR", "X-ABUID"));
+    
+    private static Set<String> JAPANESE_MOBILE_PHONE_SIGNS = new HashSet<String>(Arrays.asList(
+            "X-GNO", "X-GN", "X-REDUCTION"));
+    
+    private static Set<String> WINDOWS_MOBILE_PHONE_SIGNS = new HashSet<String>(Arrays.asList(
+            "X-MICROSOFT-ASST_TEL", "X-MICROSOFT-ASSISTANT", "X-MICROSOFT-OFFICELOC"));
+    
+    // Note: these signes appears before the signs of the other type (e.g. "X-GN").
+    // In other words, Japanese FOMA mobile phones are detected as FOMA, not JAPANESE_MOBILE_PHONES.
+    private static Set<String> FOMA_SIGNS = new HashSet<String>(Arrays.asList(
+            "X-SD-VERN", "X-SD-FORMAT_VER", "X-SD-CATEGORIES", "X-SD-CLASS", "X-SD-DCREATED",
+            "X-SD-DESCRIPTION"));
+    private static String TYPE_FOMA_CHARSET_SIGN = "X-SD-CHAR_CODE";
+    
+    private int mType = TYPE_UNKNOWN;
+    // Some mobile phones (like FOMA) tells us the charset of the data.
+    private boolean mNeedParseSpecifiedCharset;
+    private String mSpecifiedCharset;
+    
+    public void start() {
+    }
+    
+    public void end() {
+    }
+
+    public void startRecord(String type) {
+    }    
+
+    public void startProperty() {
+        mNeedParseSpecifiedCharset = false;
+    }
+    
+    public void endProperty() {
+    }
+
+    public void endRecord() {
+    }
+
+    public void propertyGroup(String group) {
+    }
+    
+    public void propertyName(String name) {
+        if (name.equalsIgnoreCase(TYPE_FOMA_CHARSET_SIGN)) {
+            mType = TYPE_FOMA;
+            mNeedParseSpecifiedCharset = true;
+            return;
+        }
+        if (mType != TYPE_UNKNOWN) {
+            return;
+        }
+        if (WINDOWS_MOBILE_PHONE_SIGNS.contains(name)) {
+            mType = TYPE_WINDOWS_MOBILE_JP;
+        } else if (FOMA_SIGNS.contains(name)) {
+            mType = TYPE_FOMA;
+        } else if (JAPANESE_MOBILE_PHONE_SIGNS.contains(name)) {
+            mType = TYPE_JAPANESE_MOBILE_PHONE;
+        } else if (APPLE_SIGNS.contains(name)) {
+            mType = TYPE_APPLE;
+        }
+    }
+
+    public void propertyParamType(String type) {
+    }
+
+    public void propertyParamValue(String value) {
+    }
+
+    public void propertyValues(List<String> values) {
+        if (mNeedParseSpecifiedCharset && values.size() > 0) {
+            mSpecifiedCharset = values.get(0);
+        }
+    }
+
+    int getType() {
+        return mType;
+    }
+    
+    /**
+     * Return charset String guessed from the source's properties.
+     * This method must be called after parsing target file(s).
+     * @return Charset String. Null is returned if guessing the source fails.
+     */
+    public String getEstimatedCharset() {
+        if (mSpecifiedCharset != null) {
+            return mSpecifiedCharset;
+        }
+        switch (mType) {
+        case TYPE_WINDOWS_MOBILE_JP:
+        case TYPE_FOMA:
+        case TYPE_JAPANESE_MOBILE_PHONE:
+            return "SHIFT_JIS";
+        case TYPE_APPLE:
+            return "UTF-8";
+        default:
+            return null;
+        }
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/pim/vcard/VCardVersionException.java b/src/com/transage/privatespace/vcard/pim/vcard/VCardVersionException.java
new file mode 100755
index 0000000..cd54085
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/pim/vcard/VCardVersionException.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.pim.vcard;
+
+/**
+ * VCardException used only when the version of the vCard is different. 
+ */
+public class VCardVersionException extends VCardException {
+    public VCardVersionException() {
+    }
+
+    public VCardVersionException(String message) {
+        super(message);
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/provider/BaseColumns.java b/src/com/transage/privatespace/vcard/provider/BaseColumns.java
new file mode 100755
index 0000000..2a398b7
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/provider/BaseColumns.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.provider;
+
+public interface BaseColumns
+{
+    /**
+     * The unique ID for a row.
+     * <P>Type: INTEGER (long)</P>
+     */
+    public static final String _ID = "_id";
+
+    /**
+     * The count of rows in a directory.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String _COUNT = "_count";
+}
diff --git a/src/com/transage/privatespace/vcard/provider/Contacts.java b/src/com/transage/privatespace/vcard/provider/Contacts.java
new file mode 100755
index 0000000..4f02b3b
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/provider/Contacts.java
@@ -0,0 +1,1769 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.provider;
+
+//import com.android.internal.R;
+
+//import android.content.ContentResolver;
+//import android.content.ContentUris;
+//import android.content.ContentValues;
+//import android.content.Context;
+//import android.content.Intent;
+//import android.database.Cursor;
+//import android.graphics.Bitmap;
+//import android.graphics.BitmapFactory;
+//import android.net.Uri;
+//import android.text.TextUtils;
+//import android.util.Log;
+//import android.widget.ImageView;
+
+//import java.io.ByteArrayInputStream;
+//import java.io.InputStream;
+
+/**
+ * The Contacts provider stores all information about contacts.
+ */
+public class Contacts {
+    private static final String TAG = "Contacts";
+    
+    public static final String AUTHORITY = "contacts";
+
+//    /**
+//     * The content:// style URL for this provider
+//     */
+//    public static final Uri CONTENT_URI =
+//        Uri.parse("content://" + AUTHORITY);
+
+    /** Signifies an email address row that is stored in the ContactMethods table */
+    public static final int KIND_EMAIL = 1;
+    /** Signifies a postal address row that is stored in the ContactMethods table */
+    public static final int KIND_POSTAL = 2;
+    /** Signifies an IM address row that is stored in the ContactMethods table */
+    public static final int KIND_IM = 3;
+    /** Signifies an Organization row that is stored in the Organizations table */
+    public static final int KIND_ORGANIZATION = 4;
+    /** Signifies an Phone row that is stored in the Phones table */
+    public static final int KIND_PHONE = 5;
+
+    /**
+     * no public constructor since this is a utility class
+     */
+    private Contacts() {}
+
+//    /**
+//     * Columns from the Settings table that other columns join into themselves.
+//     */
+//    public interface SettingsColumns {
+//        /**
+//         * The _SYNC_ACCOUNT to which this setting corresponds. This may be null.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String _SYNC_ACCOUNT = "_sync_account";
+//
+//        /**
+//         * The key of this setting.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String KEY = "key";
+//
+//        /**
+//         * The value of this setting.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String VALUE = "value";
+//    }
+//
+//    /**
+//     * The settings over all of the people
+//     */
+//    public static final class Settings implements BaseColumns, SettingsColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private Settings() {}
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/settings");
+//
+//        /**
+//         * The directory twig for this sub-table
+//         */
+//        public static final String CONTENT_DIRECTORY = "settings";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "key ASC";
+//
+//        /**
+//         * A setting that is used to indicate if we should sync down all groups for the
+//         * specified account. For this setting the _SYNC_ACCOUNT column must be set.
+//         * If this isn't set then we will only sync the groups whose SHOULD_SYNC column
+//         * is set to true.
+//         * <p>
+//         * This is a boolean setting. It is true if it is set and it is anything other than the
+//         * emptry string or "0".
+//         */
+//        public static final String SYNC_EVERYTHING = "syncEverything";
+//
+//        public static String getSetting(ContentResolver cr, String account, String key) {
+//            // For now we only support a single account and the UI doesn't know what
+//            // the account name is, so we're using a global setting for SYNC_EVERYTHING.
+//            // Some day when we add multiple accounts to the UI this should honor the account
+//            // that was asked for.
+//            String selectString;
+//            String[] selectArgs;
+//            if (false) {
+//                selectString = (account == null)
+//                        ? "_sync_account is null AND key=?"
+//                        : "_sync_account=? AND key=?";
+//                selectArgs = (account == null)
+//                ? new String[]{key}
+//                : new String[]{account, key};
+//            } else {
+//                selectString = "key=?";
+//                selectArgs = new String[] {key};
+//            }
+//            Cursor cursor = cr.query(Settings.CONTENT_URI, new String[]{VALUE},
+//                    selectString, selectArgs, null);
+//            try {
+//                if (!cursor.moveToNext()) return null;
+//                return cursor.getString(0);
+//            } finally {
+//                cursor.close();
+//            }
+//        }
+//
+//        public static void setSetting(ContentResolver cr, String account, String key,
+//                String value) {
+//            ContentValues values = new ContentValues();
+//            // For now we only support a single account and the UI doesn't know what
+//            // the account name is, so we're using a global setting for SYNC_EVERYTHING.
+//            // Some day when we add multiple accounts to the UI this should honor the account
+//            // that was asked for.
+//            //values.put(_SYNC_ACCOUNT, account);
+//            values.put(KEY, key);
+//            values.put(VALUE, value);
+//            cr.update(Settings.CONTENT_URI, values, null, null);
+//        }
+//    }
+//
+    /**
+     * Columns from the People table that other tables join into themselves.
+     */
+    public interface PeopleColumns {
+        /**
+         * The person's name.
+         * <P>Type: TEXT</P>
+         */
+        public static final String NAME = "name";
+
+        /**
+         * Phonetic equivalent of the person's name, in a locale-dependent
+         * character set (e.g. hiragana for Japanese).
+         * Used for pronunciation and/or collation in some languages.
+         * <p>Type: TEXT</P>
+         */
+        public static final String PHONETIC_NAME = "phonetic_name";
+        
+        /**
+         * The display name. If name is not null name, else if number is not null number,
+         * else if email is not null email.
+         * <P>Type: TEXT</P>
+         */
+        public static final String DISPLAY_NAME = "display_name";
+
+        /**
+         * The field for sorting list phonetically. The content of this field
+         * may not be human readable but phonetically sortable.
+         * <P>Type: TEXT</p>
+         * @hide Used only in Contacts application for now.
+         */
+        public static final String SORT_STRING = "sort_string";
+        
+        /**
+         * Notes about the person.
+         * <P>Type: TEXT</P>
+         */
+        public static final String NOTES = "notes";
+
+        /**
+         * The number of times a person has been contacted
+         * <P>Type: INTEGER</P>
+         */
+        public static final String TIMES_CONTACTED = "times_contacted";
+
+        /**
+         * The last time a person was contacted.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String LAST_TIME_CONTACTED = "last_time_contacted";
+
+        /**
+         * A custom ringtone associated with a person. Not always present.
+         * <P>Type: TEXT (URI to the ringtone)</P>
+         */
+        public static final String CUSTOM_RINGTONE = "custom_ringtone";
+
+        /**
+         * Whether the person should always be sent to voicemail. Not always
+         * present.
+         * <P>Type: INTEGER (0 for false, 1 for true)</P>
+         */
+        public static final String SEND_TO_VOICEMAIL = "send_to_voicemail";
+
+        /**
+         * Is the contact starred?
+         * <P>Type: INTEGER (boolean)</P>
+         */
+        public static final String STARRED = "starred";
+
+        /**
+         * The server version of the photo
+         * <P>Type: TEXT (the version number portion of the photo URI)</P>
+         */
+        public static final String PHOTO_VERSION = "photo_version";       
+    }
+//
+//    /**
+//     * This table contains people.
+//     */
+//    public static final class People implements BaseColumns, SyncConstValue, PeopleColumns,
+//            PhonesColumns, PresenceColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private People() {}
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/people");
+//
+//        /**
+//         * The content:// style URL for filtering people by name. The filter
+//         * argument should be passed as an additional path segment after this URI.
+//         */
+//        public static final Uri CONTENT_FILTER_URI =
+//            Uri.parse("content://contacts/people/filter");
+//
+//        /**
+//         * The content:// style URL for the table that holds the deleted
+//         * contacts.
+//         */
+//        public static final Uri DELETED_CONTENT_URI =
+//            Uri.parse("content://contacts/deleted_people");
+//
+//        /**
+//         * The content:// style URL for filtering people that have a specific
+//         * E-mail or IM address. The filter argument should be passed as an
+//         * additional path segment after this URI. This matches any people with
+//         * at least one E-mail or IM {@link ContactMethods} that match the
+//         * filter.
+//         *
+//         * Not exposed because we expect significant changes in the contacts
+//         * schema and do not want to have to support this.
+//         * @hide
+//         */
+//        public static final Uri WITH_EMAIL_OR_IM_FILTER_URI =
+//            Uri.parse("content://contacts/people/with_email_or_im_filter");
+//
+//        /**
+//         * The MIME type of {@link #CONTENT_URI} providing a directory of
+//         * people.
+//         */
+//        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/person";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} subdirectory of a single
+//         * person.
+//         */
+//        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/person";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = People.NAME + " ASC";
+//
+//        /**
+//         * The ID of the persons preferred phone number.
+//         * <P>Type: INTEGER (foreign key to phones table on the _ID field)</P>
+//         */
+//        public static final String PRIMARY_PHONE_ID = "primary_phone";
+//
+//        /**
+//         * The ID of the persons preferred email.
+//         * <P>Type: INTEGER (foreign key to contact_methods table on the
+//         * _ID field)</P>
+//         */
+//        public static final String PRIMARY_EMAIL_ID = "primary_email";
+//
+//        /**
+//         * The ID of the persons preferred organization.
+//         * <P>Type: INTEGER (foreign key to organizations table on the
+//         * _ID field)</P>
+//         */
+//        public static final String PRIMARY_ORGANIZATION_ID = "primary_organization";
+//
+//        /**
+//         * Mark a person as having been contacted.
+//         *
+//         * @param resolver the ContentResolver to use
+//         * @param personId the person who was contacted
+//         */
+//        public static void markAsContacted(ContentResolver resolver, long personId) {
+//            Uri uri = ContentUris.withAppendedId(CONTENT_URI, personId);
+//            uri = Uri.withAppendedPath(uri, "update_contact_time");
+//            ContentValues values = new ContentValues();
+//            // There is a trigger in place that will update TIMES_CONTACTED when
+//            // LAST_TIME_CONTACTED is modified.
+//            values.put(LAST_TIME_CONTACTED, System.currentTimeMillis());
+//            resolver.update(uri, values, null, null);
+//        }
+//
+//        /**
+//         * @hide Used in vCard parser code.
+//         */
+//        public static long tryGetMyContactsGroupId(ContentResolver resolver) {
+//            Cursor groupsCursor = resolver.query(Groups.CONTENT_URI, GROUPS_PROJECTION,
+//                    Groups.SYSTEM_ID + "='" + Groups.GROUP_MY_CONTACTS + "'", null, null);
+//            if (groupsCursor != null) {
+//                try {
+//                    if (groupsCursor.moveToFirst()) {
+//                        return groupsCursor.getLong(0);
+//                    }
+//                } finally {
+//                    groupsCursor.close();
+//                }
+//            }
+//            return 0;
+//        }
+//
+//        /**
+//         * Adds a person to the My Contacts group.
+//         *
+//         * @param resolver the resolver to use
+//         * @param personId the person to add to the group
+//         * @return the URI of the group membership row
+//         * @throws IllegalStateException if the My Contacts group can't be found
+//         */
+//        public static Uri addToMyContactsGroup(ContentResolver resolver, long personId) {
+//            long groupId = tryGetMyContactsGroupId(resolver);
+//            if (groupId == 0) {
+//                throw new IllegalStateException("Failed to find the My Contacts group");
+//            }
+//
+//            return addToGroup(resolver, personId, groupId);
+//        }
+//
+//        /**
+//         * Adds a person to a group referred to by name.
+//         *
+//         * @param resolver the resolver to use
+//         * @param personId the person to add to the group
+//         * @param groupName the name of the group to add the contact to
+//         * @return the URI of the group membership row
+//         * @throws IllegalStateException if the group can't be found
+//         */
+//        public static Uri addToGroup(ContentResolver resolver, long personId, String groupName) {
+//            long groupId = 0;
+//            Cursor groupsCursor = resolver.query(Groups.CONTENT_URI, GROUPS_PROJECTION,
+//                    Groups.NAME + "=?", new String[] { groupName }, null);
+//            if (groupsCursor != null) {
+//                try {
+//                    if (groupsCursor.moveToFirst()) {
+//                        groupId = groupsCursor.getLong(0);
+//                    }
+//                } finally {
+//                    groupsCursor.close();
+//                }
+//            }
+//
+//            if (groupId == 0) {
+//                throw new IllegalStateException("Failed to find the My Contacts group");
+//            }
+//
+//            return addToGroup(resolver, personId, groupId);
+//        }
+//
+//        /**
+//         * Adds a person to a group.
+//         *
+//         * @param resolver the resolver to use
+//         * @param personId the person to add to the group
+//         * @param groupId the group to add the person to
+//         * @return the URI of the group membership row
+//         */
+//        public static Uri addToGroup(ContentResolver resolver, long personId, long groupId) {
+//            ContentValues values = new ContentValues();
+//            values.put(GroupMembership.PERSON_ID, personId);
+//            values.put(GroupMembership.GROUP_ID, groupId);
+//            return resolver.insert(GroupMembership.CONTENT_URI, values);
+//        }
+//
+//        private static final String[] GROUPS_PROJECTION = new String[] {
+//            Groups._ID,
+//        };
+//
+//        /**
+//         * Creates a new contacts and adds it to the "My Contacts" group.
+//         *
+//         * @param resolver the ContentResolver to use
+//         * @param values the values to use when creating the contact
+//         * @return the URI of the contact, or null if the operation fails
+//         */
+//        public static Uri createPersonInMyContactsGroup(ContentResolver resolver,
+//                ContentValues values) {
+//
+//            Uri contactUri = resolver.insert(People.CONTENT_URI, values);
+//            if (contactUri == null) {
+//                Log.e(TAG, "Failed to create the contact");
+//                return null;
+//            }
+//
+//            if (addToMyContactsGroup(resolver, ContentUris.parseId(contactUri)) == null) {
+//                resolver.delete(contactUri, null, null);
+//                return null;
+//            }
+//            return contactUri;
+//        }
+//
+//        public static Cursor queryGroups(ContentResolver resolver, long person) {
+//            return resolver.query(GroupMembership.CONTENT_URI, null, "person=?",
+//                    new String[]{String.valueOf(person)}, Groups.DEFAULT_SORT_ORDER);
+//        }
+//
+//        /**
+//         * Set the photo for this person. data may be null
+//         * @param cr the ContentResolver to use
+//         * @param person the Uri of the person whose photo is to be updated
+//         * @param data the byte[] that represents the photo
+//         */
+//        public static void setPhotoData(ContentResolver cr, Uri person, byte[] data) {
+//            Uri photoUri = Uri.withAppendedPath(person, Contacts.Photos.CONTENT_DIRECTORY);
+//            ContentValues values = new ContentValues();
+//            values.put(Photos.DATA, data);
+//            cr.update(photoUri, values, null, null);
+//        }
+//
+//        /**
+//         * Opens an InputStream for the person's photo and returns the photo as a Bitmap.
+//         * If the person's photo isn't present returns the placeholderImageResource instead.
+//         * @param person the person whose photo should be used
+//         */
+//        public static InputStream openContactPhotoInputStream(ContentResolver cr, Uri person) {
+//            Uri photoUri = Uri.withAppendedPath(person, Contacts.Photos.CONTENT_DIRECTORY);
+//            Cursor cursor = cr.query(photoUri, new String[]{Photos.DATA}, null, null, null);
+//            try {
+//                if (!cursor.moveToNext()) {
+//                    return null;
+//                }
+//                byte[] data = cursor.getBlob(0);
+//                if (data == null) {
+//                    return null;
+//                }
+//                return new ByteArrayInputStream(data);
+//            } finally {
+//                cursor.close();
+//            }
+//        }
+//
+//        /**
+//         * Opens an InputStream for the person's photo and returns the photo as a Bitmap.
+//         * If the person's photo isn't present returns the placeholderImageResource instead.
+//         * @param context the Context
+//         * @param person the person whose photo should be used
+//         * @param placeholderImageResource the image resource to use if the person doesn't
+//         *   have a photo
+//         * @param options the decoding options, can be set to null
+//         */
+//        public static Bitmap loadContactPhoto(Context context, Uri person,
+//                int placeholderImageResource, BitmapFactory.Options options) {
+//            if (person == null) {
+//                return loadPlaceholderPhoto(placeholderImageResource, context, options);
+//            }
+//
+//            InputStream stream = openContactPhotoInputStream(context.getContentResolver(), person);
+//            Bitmap bm = stream != null ? BitmapFactory.decodeStream(stream, null, options) : null;
+//            if (bm == null) {
+//                bm = loadPlaceholderPhoto(placeholderImageResource, context, options);
+//            }
+//            return bm;
+//        }
+//
+//        private static Bitmap loadPlaceholderPhoto(int placeholderImageResource, Context context,
+//                BitmapFactory.Options options) {
+//            if (placeholderImageResource == 0) {
+//                return null;
+//            }
+//            return BitmapFactory.decodeResource(context.getResources(),
+//                    placeholderImageResource, options);
+//        }
+
+        /**
+         * A sub directory of a single person that contains all of their Phones.
+         */
+        public static final class Phones implements BaseColumns, PhonesColumns,
+                PeopleColumns {
+            /**
+             * no public constructor since this is a utility class
+             */
+            private Phones() {}
+
+            /**
+             * The directory twig for this sub-table
+             */
+            public static final String CONTENT_DIRECTORY = "phones";
+
+            /**
+             * The default sort order for this table
+             */
+            public static final String DEFAULT_SORT_ORDER = "number ASC";
+        }
+
+        /**
+         * A subdirectory of a single person that contains all of their
+         * ContactMethods.
+         */
+        public static final class ContactMethods
+                implements BaseColumns, ContactMethodsColumns, PeopleColumns {
+            /**
+             * no public constructor since this is a utility class
+             */
+            private ContactMethods() {}
+
+            /**
+             * The directory twig for this sub-table
+             */
+            public static final String CONTENT_DIRECTORY = "contact_methods";
+
+            /**
+             * The default sort order for this table
+             */
+            public static final String DEFAULT_SORT_ORDER = "data ASC";
+        }
+
+//        /**
+//         * The extensions for a person
+//         */
+//        public static class Extensions implements BaseColumns, ExtensionsColumns {
+//            /**
+//             * no public constructor since this is a utility class
+//             */
+//            private Extensions() {}
+//
+//            /**
+//             * The directory twig for this sub-table
+//             */
+//            public static final String CONTENT_DIRECTORY = "extensions";
+//
+//            /**
+//             * The default sort order for this table
+//             */
+//            public static final String DEFAULT_SORT_ORDER = "name ASC";
+//
+//            /**
+//             * The ID of the person this phone number is assigned to.
+//             * <P>Type: INTEGER (long)</P>
+//             */
+//            public static final String PERSON_ID = "person";
+//        }
+//    }
+//
+//    /**
+//     * Columns from the groups table.
+//     */
+//    public interface GroupsColumns {
+//        /**
+//         * The group name.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String NAME = "name";
+//
+//        /**
+//         * Notes about the group.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String NOTES = "notes";
+//
+//        /**
+//         * Whether this group should be synced if the SYNC_EVERYTHING settings is false
+//         * for this group's account.
+//         * <P>Type: INTEGER (boolean)</P>
+//         */
+//        public static final String SHOULD_SYNC = "should_sync";
+//
+//        /**
+//         * The ID of this group if it is a System Group, null otherwise.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String SYSTEM_ID = "system_id";
+//    }
+//
+//    /**
+//     * This table contains the groups for an account.
+//     */
+//    public static final class Groups
+//            implements BaseColumns, SyncConstValue, GroupsColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private Groups() {}
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/groups");
+//
+//        /**
+//         * The content:// style URL for the table that holds the deleted
+//         * groups.
+//         */
+//        public static final Uri DELETED_CONTENT_URI =
+//            Uri.parse("content://contacts/deleted_groups");
+//
+//        /**
+//         * The MIME type of {@link #CONTENT_URI} providing a directory of
+//         * groups.
+//         */
+//        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/contactsgroup";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} subdirectory of a single
+//         * group.
+//         */
+//        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/contactsgroup";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = NAME + " ASC";
+//
+//        /**
+//         *
+//         */
+//        public static final String GROUP_ANDROID_STARRED = "Starred in Android";
+//
+//        /**
+//         * The "My Contacts" system group.
+//         */
+//        public static final String GROUP_MY_CONTACTS = "Contacts";
+//    }
+//
+    /**
+     * Columns from the Phones table that other columns join into themselves.
+     */
+    public interface PhonesColumns {
+        /**
+         * The type of the the phone number.
+         * <P>Type: INTEGER (one of the constants below)</P>
+         */
+        public static final String TYPE = "type";
+
+        public static final int TYPE_CUSTOM = 0;
+        public static final int TYPE_HOME = 1;
+        public static final int TYPE_MOBILE = 2;
+        public static final int TYPE_WORK = 3;
+        public static final int TYPE_FAX_WORK = 4;
+        public static final int TYPE_FAX_HOME = 5;
+        public static final int TYPE_PAGER = 6;
+        public static final int TYPE_OTHER = 7;
+
+        /**
+         * The user provided label for the phone number, only used if TYPE is TYPE_CUSTOM.
+         * <P>Type: TEXT</P>
+         */
+        public static final String LABEL = "label";
+
+        /**
+         * The phone number as the user entered it.
+         * <P>Type: TEXT</P>
+         */
+        public static final String NUMBER = "number";
+
+        /**
+         * The normalized phone number
+         * <P>Type: TEXT</P>
+         */
+        public static final String NUMBER_KEY = "number_key";
+
+        /**
+         * Whether this is the primary phone number
+         * <P>Type: INTEGER (if set, non-0 means true)</P>
+         */
+        public static final String ISPRIMARY = "isprimary";
+    }
+//
+//    /**
+//     * This table stores phone numbers and a reference to the person that the
+//     * contact method belongs to. Phone numbers are stored separately from
+//     * other contact methods to make caller ID lookup more efficient.
+//     */
+//    public static final class Phones
+//            implements BaseColumns, PhonesColumns, PeopleColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private Phones() {}
+//
+//        public static final CharSequence getDisplayLabel(Context context, int type,
+//                CharSequence label, CharSequence[] labelArray) {
+//            CharSequence display = "";
+//
+//            if (type != People.Phones.TYPE_CUSTOM) {
+//                CharSequence[] labels = labelArray != null? labelArray
+//                        : context.getResources().getTextArray(
+//                                com.android.internal.R.array.phoneTypes);
+//                try {
+//                    display = labels[type - 1];
+//                } catch (ArrayIndexOutOfBoundsException e) {
+//                    display = labels[People.Phones.TYPE_HOME - 1];
+//                }
+//            } else {
+//                if (!TextUtils.isEmpty(label)) {
+//                    display = label;
+//                }
+//            }
+//            return display;
+//        }
+//
+//        public static final CharSequence getDisplayLabel(Context context, int type,
+//                CharSequence label) {
+//            return getDisplayLabel(context, type, label, null);
+//        }
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/phones");
+//
+//        /**
+//         * The content:// style URL for filtering phone numbers
+//         */
+//        public static final Uri CONTENT_FILTER_URL =
+//            Uri.parse("content://contacts/phones/filter");
+//
+//        /**
+//         * The MIME type of {@link #CONTENT_URI} providing a directory of
+//         * phones.
+//         */
+//        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/phone";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} subdirectory of a single
+//         * phone.
+//         */
+//        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/phone";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "name ASC";
+//
+//        /**
+//         * The ID of the person this phone number is assigned to.
+//         * <P>Type: INTEGER (long)</P>
+//         */
+//        public static final String PERSON_ID = "person";
+//    }
+//
+//    public static final class GroupMembership implements BaseColumns, GroupsColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private GroupMembership() {}
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/groupmembership");
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri RAW_CONTENT_URI =
+//            Uri.parse("content://contacts/groupmembershipraw");
+//
+//        /**
+//         * The directory twig for this sub-table
+//         */
+//        public static final String CONTENT_DIRECTORY = "groupmembership";
+//        /**
+//         * The MIME type of {@link #CONTENT_URI} providing a directory of all
+//         * person groups.
+//         */
+//        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/contactsgroupmembership";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} subdirectory of a single
+//         * person group.
+//         */
+//        public static final String CONTENT_ITEM_TYPE =
+//                "vnd.android.cursor.item/contactsgroupmembership";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "group_id ASC";
+//
+//        /**
+//         * The row id of the accounts group.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String GROUP_ID = "group_id";
+//
+//        /**
+//         * The sync id of the group.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String GROUP_SYNC_ID = "group_sync_id";
+//
+//        /**
+//         * The account of the group.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String GROUP_SYNC_ACCOUNT = "group_sync_account";
+//
+//        /**
+//         * The row id of the person.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String PERSON_ID = "person";
+//    }
+//
+    /**
+     * Columns from the ContactMethods table that other tables join into
+     * themseleves.
+     */
+    public interface ContactMethodsColumns {
+        /**
+         * The kind of the the contact method. For example, email address,
+         * postal address, etc.
+         * <P>Type: INTEGER (one of the values below)</P>
+         */
+        public static final String KIND = "kind";
+
+        /**
+         * The type of the contact method, must be one of the types below.
+         * <P>Type: INTEGER (one of the values below)</P>
+         */
+        public static final String TYPE = "type";
+        public static final int TYPE_CUSTOM = 0;
+        public static final int TYPE_HOME = 1;
+        public static final int TYPE_WORK = 2;
+        public static final int TYPE_OTHER = 3;
+
+        /**
+         * @hide This is temporal. TYPE_MOBILE should be added to TYPE in the future.
+         */
+        public static final int MOBILE_EMAIL_TYPE_INDEX = 2;
+
+        /**
+         * @hide This is temporal. TYPE_MOBILE should be added to TYPE in the future.
+         * This is not "mobile" but "CELL" since vCard uses it for identifying mobile phone.
+         */
+        public static final String MOBILE_EMAIL_TYPE_NAME = "_AUTO_CELL";
+
+        /**
+         * The user defined label for the the contact method.
+         * <P>Type: TEXT</P>
+         */
+        public static final String LABEL = "label";
+
+        /**
+         * The data for the contact method.
+         * <P>Type: TEXT</P>
+         */
+        public static final String DATA = "data";
+
+        /**
+         * Auxiliary data for the contact method.
+         * <P>Type: TEXT</P>
+         */
+        public static final String AUX_DATA = "aux_data";
+
+        /**
+         * Whether this is the primary organization
+         * <P>Type: INTEGER (if set, non-0 means true)</P>
+         */
+        public static final String ISPRIMARY = "isprimary";
+    }
+//
+//    /**
+//     * This table stores all non-phone contact methods and a reference to the
+//     * person that the contact method belongs to.
+//     */
+//    public static final class ContactMethods
+//            implements BaseColumns, ContactMethodsColumns, PeopleColumns {
+//        /**
+//         * The column with latitude data for postal locations
+//         * <P>Type: REAL</P>
+//         */
+//        public static final String POSTAL_LOCATION_LATITUDE = DATA;
+//
+//        /**
+//         * The column with longitude data for postal locations
+//         * <P>Type: REAL</P>
+//         */
+//        public static final String POSTAL_LOCATION_LONGITUDE = AUX_DATA;
+//
+//        /**
+//         * The predefined IM protocol types. The protocol can either be non-present, one
+//         * of these types, or a free-form string. These cases are encoded in the AUX_DATA
+//         * column as:
+//         *  - null
+//         *  - pre:<an integer, one of the protocols below>
+//         *  - custom:<a string>
+//         */
+//        public static final int PROTOCOL_AIM = 0;
+//        public static final int PROTOCOL_MSN = 1;
+//        public static final int PROTOCOL_YAHOO = 2;
+//        public static final int PROTOCOL_SKYPE = 3;
+//        public static final int PROTOCOL_QQ = 4;
+//        public static final int PROTOCOL_GOOGLE_TALK = 5;
+//        public static final int PROTOCOL_ICQ = 6;
+//        public static final int PROTOCOL_JABBER = 7;
+//
+//        public static String encodePredefinedImProtocol(int protocol) {
+//            return "pre:" + protocol;
+//        }
+//
+//        public static String encodeCustomImProtocol(String protocolString) {
+//            return "custom:" + protocolString;
+//        }
+//
+//        public static Object decodeImProtocol(String encodedString) {
+//            if (encodedString == null) {
+//                return null;
+//            }
+//
+//            if (encodedString.startsWith("pre:")) {
+//                return Integer.parseInt(encodedString.substring(4));
+//            }
+//
+//            if (encodedString.startsWith("custom:")) {
+//                return encodedString.substring(7);
+//            }
+//
+//            throw new IllegalArgumentException(
+//                    "the value is not a valid encoded protocol, " + encodedString);
+//        }
+//
+//        /**
+//         * This looks up the provider name defined in
+//         * {@link android.provider.Im.ProviderNames} from the predefined IM protocol id.
+//         * This is used for interacting with the IM application.
+//         *
+//         * @param protocol the protocol ID
+//         * @return the provider name the IM app uses for the given protocol, or null if no
+//         * provider is defined for the given protocol
+//         * @hide
+//         */
+//        public static String lookupProviderNameFromId(int protocol) {
+//            switch (protocol) {
+//                case PROTOCOL_GOOGLE_TALK:
+//                    return Im.ProviderNames.GTALK;
+//                case PROTOCOL_AIM:
+//                    return Im.ProviderNames.AIM;
+//                case PROTOCOL_MSN:
+//                    return Im.ProviderNames.MSN;
+//                case PROTOCOL_YAHOO:
+//                    return Im.ProviderNames.YAHOO;
+//                case PROTOCOL_ICQ:
+//                    return Im.ProviderNames.ICQ;
+//                case PROTOCOL_JABBER:
+//                    return Im.ProviderNames.JABBER;
+//                case PROTOCOL_SKYPE:
+//                    return Im.ProviderNames.SKYPE;
+//                case PROTOCOL_QQ:
+//                    return Im.ProviderNames.QQ;
+//            }
+//            return null;
+//        }
+//
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private ContactMethods() {}
+//
+//        public static final CharSequence getDisplayLabel(Context context, int kind,
+//                int type, CharSequence label) {
+//            CharSequence display = "";
+//            switch (kind) {
+//                case KIND_EMAIL: {
+//                    if (type != People.ContactMethods.TYPE_CUSTOM) {
+//                        CharSequence[] labels = context.getResources().getTextArray(
+//                                com.android.internal.R.array.emailAddressTypes);
+//                        try {
+//                            display = labels[type - 1];
+//                        } catch (ArrayIndexOutOfBoundsException e) {
+//                            display = labels[ContactMethods.TYPE_HOME - 1];
+//                        }
+//                    } else {
+//                        if (!TextUtils.isEmpty(label)) {
+//                            if (label.toString().equals(MOBILE_EMAIL_TYPE_NAME)) {
+//                                display =
+//                                    context.getString(
+//                                            com.android.internal.R.string.mobileEmailTypeName);
+//                            } else {
+//                                display = label;
+//                            }
+//                        }
+//                    }
+//                    break;
+//                }
+//
+//                case KIND_POSTAL: {
+//                    if (type != People.ContactMethods.TYPE_CUSTOM) {
+//                        CharSequence[] labels = context.getResources().getTextArray(
+//                                com.android.internal.R.array.postalAddressTypes);
+//                        try {
+//                            display = labels[type - 1];
+//                        } catch (ArrayIndexOutOfBoundsException e) {
+//                            display = labels[ContactMethods.TYPE_HOME - 1];
+//                        }
+//                    } else {
+//                        if (!TextUtils.isEmpty(label)) {
+//                            display = label;
+//                        }
+//                    }
+//                    break;
+//                }
+//
+//                default:
+//                    display = context.getString(R.string.untitled);
+//            }
+//            return display;
+//        }
+//
+//        /**
+//         * Add a longitude and latitude location to a postal address.
+//         *
+//         * @param context the context to use when updating the database
+//         * @param postalId the address to update
+//         * @param latitude the latitude for the address
+//         * @param longitude the longitude for the address
+//         */
+//        public void addPostalLocation(Context context, long postalId,
+//                double latitude, double longitude) {
+//            final ContentResolver resolver = context.getContentResolver();
+//            // Insert the location
+//            ContentValues values = new ContentValues(2);
+//            values.put(POSTAL_LOCATION_LATITUDE, latitude);
+//            values.put(POSTAL_LOCATION_LONGITUDE, longitude);
+//            Uri loc = resolver.insert(CONTENT_URI, values);
+//            long locId = ContentUris.parseId(loc);
+//
+//            // Update the postal address
+//            values.clear();
+//            values.put(AUX_DATA, locId);
+//            resolver.update(ContentUris.withAppendedId(CONTENT_URI, postalId), values, null, null);
+//        }
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/contact_methods");
+//
+//        /**
+//         * The content:// style URL for sub-directory of e-mail addresses.
+//         */
+//        public static final Uri CONTENT_EMAIL_URI =
+//            Uri.parse("content://contacts/contact_methods/email");
+//
+//        /**
+//         * The MIME type of {@link #CONTENT_URI} providing a directory of
+//         * phones.
+//         */
+//        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/contact-methods";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_EMAIL_URI} sub-directory of\
+//         * multiple {@link Contacts#KIND_EMAIL} entries.
+//         */
+//        public static final String CONTENT_EMAIL_TYPE = "vnd.android.cursor.dir/email";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_EMAIL_URI} sub-directory of\
+//         * multiple {@link Contacts#KIND_POSTAL} entries.
+//         */
+//        public static final String CONTENT_POSTAL_TYPE = "vnd.android.cursor.dir/postal-address";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} sub-directory of a single
+//         * {@link Contacts#KIND_EMAIL} entry.
+//         */
+//        public static final String CONTENT_EMAIL_ITEM_TYPE = "vnd.android.cursor.item/email";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} sub-directory of a single
+//         * {@link Contacts#KIND_POSTAL} entry.
+//         */
+//        public static final String CONTENT_POSTAL_ITEM_TYPE
+//                = "vnd.android.cursor.item/postal-address";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} sub-directory of a single
+//         * {@link Contacts#KIND_IM} entry.
+//         */
+//        public static final String CONTENT_IM_ITEM_TYPE = "vnd.android.cursor.item/jabber-im";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "name ASC";
+//
+//        /**
+//         * The ID of the person this contact method is assigned to.
+//         * <P>Type: INTEGER (long)</P>
+//         */
+//        public static final String PERSON_ID = "person";
+//    }
+//
+//    /**
+//     * The IM presence columns with some contacts specific columns mixed in.
+//     */
+//    public interface PresenceColumns extends Im.CommonPresenceColumns {
+//        /**
+//         * The IM service the presence is coming from. Formatted using either
+//         * {@link Contacts.ContactMethods#encodePredefinedImProtocol} or
+//         * {@link Contacts.ContactMethods#encodeCustomImProtocol}.
+//         * <P>Type: STRING</P>
+//         */
+//        public static final String IM_PROTOCOL = "im_protocol";
+//
+//        /**
+//         * The IM handle the presence item is for. The handle is scoped to
+//         * the {@link #IM_PROTOCOL}.
+//         * <P>Type: STRING</P>
+//         */
+//        public static final String IM_HANDLE = "im_handle";
+//
+//        /**
+//         * The IM account for the local user that the presence data came from.
+//         * <P>Type: STRING</P>
+//         */
+//        public static final String IM_ACCOUNT = "im_account";
+//    }
+//
+//    /**
+//     * Contains presence information about contacts.
+//     * @hide
+//     */
+//    public static final class Presence
+//            implements BaseColumns, PresenceColumns, PeopleColumns {
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/presence");
+//
+//        /**
+//         * The ID of the person this presence item is assigned to.
+//         * <P>Type: INTEGER (long)</P>
+//         */
+//        public static final String PERSON_ID = "person";
+//
+//        /**
+//         * Gets the resource ID for the proper presence icon.
+//         *
+//         * @param status the status to get the icon for
+//         * @return the resource ID for the proper presence icon
+//         */
+//        public static final int getPresenceIconResourceId(int status) {
+//            switch (status) {
+//                case Contacts.People.AVAILABLE:
+//                    return com.android.internal.R.drawable.presence_online;
+//
+//                case Contacts.People.IDLE:
+//                case Contacts.People.AWAY:
+//                    return com.android.internal.R.drawable.presence_away;
+//
+//                case Contacts.People.DO_NOT_DISTURB:
+//                    return com.android.internal.R.drawable.presence_busy;
+//
+//                case Contacts.People.INVISIBLE:
+//                    return com.android.internal.R.drawable.presence_invisible;
+//
+//                case Contacts.People.OFFLINE:
+//                default:
+//                    return com.android.internal.R.drawable.presence_offline;
+//            }
+//        }
+//
+//        /**
+//         * Sets a presence icon to the proper graphic
+//         *
+//         * @param icon the icon to to set
+//         * @param serverStatus that status
+//         */
+//        public static final void setPresenceIcon(ImageView icon, int serverStatus) {
+//            icon.setImageResource(getPresenceIconResourceId(serverStatus));
+//        }
+//    }
+//
+    /**
+     * Columns from the Organizations table that other columns join into themselves.
+     */
+    public interface OrganizationColumns {
+        /**
+         * The type of the organizations.
+         * <P>Type: INTEGER (one of the constants below)</P>
+         */
+        public static final String TYPE = "type";
+
+        public static final int TYPE_CUSTOM = 0;
+        public static final int TYPE_WORK = 1;
+        public static final int TYPE_OTHER = 2;
+
+        /**
+         * The user provided label, only used if TYPE is TYPE_CUSTOM.
+         * <P>Type: TEXT</P>
+         */
+        public static final String LABEL = "label";
+
+        /**
+         * The name of the company for this organization.
+         * <P>Type: TEXT</P>
+         */
+        public static final String COMPANY = "company";
+
+        /**
+         * The title within this organization.
+         * <P>Type: TEXT</P>
+         */
+        public static final String TITLE = "title";
+
+        /**
+         * The person this organization is tied to.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PERSON_ID = "person";
+
+        /**
+         * Whether this is the primary organization
+         * <P>Type: INTEGER (if set, non-0 means true)</P>
+         */
+        public static final String ISPRIMARY = "isprimary";
+    }
+//
+//    /**
+//     * A sub directory of a single person that contains all of their Phones.
+//     */
+//    public static final class Organizations implements BaseColumns, OrganizationColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private Organizations() {}
+//
+//        public static final CharSequence getDisplayLabel(Context context, int type,
+//                CharSequence label) {
+//            CharSequence display = "";
+//
+//            if (type != TYPE_CUSTOM) {
+//                CharSequence[] labels = context.getResources().getTextArray(
+//                        com.android.internal.R.array.organizationTypes);
+//                try {
+//                    display = labels[type - 1];
+//                } catch (ArrayIndexOutOfBoundsException e) {
+//                    display = labels[Organizations.TYPE_WORK - 1];
+//                }
+//            } else {
+//                if (!TextUtils.isEmpty(label)) {
+//                    display = label;
+//                }
+//            }
+//            return display;
+//        }
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/organizations");
+//
+//        /**
+//         * The directory twig for this sub-table
+//         */
+//        public static final String CONTENT_DIRECTORY = "organizations";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "company, title, isprimary ASC";
+//    }
+//
+//    /**
+//     * Columns from the Photos table that other columns join into themselves.
+//     */
+//    public interface PhotosColumns {
+//        /**
+//         * The _SYNC_VERSION of the photo that was last downloaded
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String LOCAL_VERSION = "local_version";
+//
+//        /**
+//         * The person this photo is associated with.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String PERSON_ID = "person";
+//
+//        /**
+//         * non-zero if a download is required and the photo isn't marked as a bad resource.
+//         * You must specify this in the columns in order to use it in the where clause.
+//         * <P>Type: INTEGER(boolean)</P>
+//         */
+//        public static final String DOWNLOAD_REQUIRED = "download_required";
+//
+//        /**
+//         * non-zero if this photo is known to exist on the server
+//         * <P>Type: INTEGER(boolean)</P>
+//         */
+//        public static final String EXISTS_ON_SERVER = "exists_on_server";
+//
+//        /**
+//         * Contains the description of the upload or download error from
+//         * the previous attempt. If null then the previous attempt succeeded.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String SYNC_ERROR = "sync_error";
+//
+//        /**
+//         * The image data, or null if there is no image.
+//         * <P>Type: BLOB</P>
+//         */
+//        public static final String DATA = "data";
+//
+//    }
+//
+//    /**
+//     * The photos over all of the people
+//     */
+//    public static final class Photos implements BaseColumns, PhotosColumns, SyncConstValue {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private Photos() {}
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/photos");
+//
+//        /**
+//         * The directory twig for this sub-table
+//         */
+//        public static final String CONTENT_DIRECTORY = "photo";
+//
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "person ASC";
+//    }
+//
+//    public interface ExtensionsColumns {
+//        /**
+//         * The name of this extension. May not be null. There may be at most one row for each name.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String NAME = "name";
+//
+//        /**
+//         * The value of this extension. May not be null.
+//         * <P>Type: TEXT</P>
+//         */
+//        public static final String VALUE = "value";
+//    }
+//
+//    /**
+//     * The extensions for a person
+//     */
+//    public static final class Extensions implements BaseColumns, ExtensionsColumns {
+//        /**
+//         * no public constructor since this is a utility class
+//         */
+//        private Extensions() {}
+//
+//        /**
+//         * The content:// style URL for this table
+//         */
+//        public static final Uri CONTENT_URI =
+//            Uri.parse("content://contacts/extensions");
+//
+//        /**
+//         * The MIME type of {@link #CONTENT_URI} providing a directory of
+//         * phones.
+//         */
+//        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/contact_extensions";
+//
+//        /**
+//         * The MIME type of a {@link #CONTENT_URI} subdirectory of a single
+//         * phone.
+//         */
+//        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/contact_extensions";
+//        /**
+//         * The default sort order for this table
+//         */
+//        public static final String DEFAULT_SORT_ORDER = "person, name ASC";
+//
+//        /**
+//         * The ID of the person this phone number is assigned to.
+//         * <P>Type: INTEGER (long)</P>
+//         */
+//        public static final String PERSON_ID = "person";
+//    }
+//
+//    /**
+//     * Contains helper classes used to create or manage {@link android.content.Intent Intents}
+//     * that involve contacts.
+//     */
+//    public static final class Intents {
+//        /**
+//         * This is the intent that is fired when a search suggestion is clicked on.
+//         */
+//        public static final String SEARCH_SUGGESTION_CLICKED =
+//                "android.provider.Contacts.SEARCH_SUGGESTION_CLICKED";
+//
+//        /**
+//         * This is the intent that is fired when a search suggestion for dialing a number
+//         * is clicked on.
+//         */
+//        public static final String SEARCH_SUGGESTION_DIAL_NUMBER_CLICKED =
+//                "android.provider.Contacts.SEARCH_SUGGESTION_DIAL_NUMBER_CLICKED";
+//
+//        /**
+//         * This is the intent that is fired when a search suggestion for creating a contact
+//         * is clicked on.
+//         */
+//        public static final String SEARCH_SUGGESTION_CREATE_CONTACT_CLICKED =
+//                "android.provider.Contacts.SEARCH_SUGGESTION_CREATE_CONTACT_CLICKED";
+//
+//        /**
+//         * Starts an Activity that lets the user pick a contact to attach an image to.
+//         * After picking the contact it launches the image cropper in face detection mode.
+//         */
+//        public static final String ATTACH_IMAGE =
+//                "com.android.contacts.action.ATTACH_IMAGE";
+//
+//        /**
+//         * Takes as input a data URI with a mailto: or tel: scheme. If a single
+//         * contact exists with the given data it will be shown. If no contact
+//         * exists, a dialog will ask the user if they want to create a new
+//         * contact with the provided details filled in. If multiple contacts
+//         * share the data the user will be prompted to pick which contact they
+//         * want to view.
+//         * <p>
+//         * For <code>mailto:</code> URIs, the scheme specific portion must be a
+//         * raw email address, such as one built using
+//         * {@link Uri#fromParts(String, String, String)}.
+//         * <p>
+//         * For <code>tel:</code> URIs, the scheme specific portion is compared
+//         * to existing numbers using the standard caller ID lookup algorithm.
+//         * The number must be properly encoded, for example using
+//         * {@link Uri#fromParts(String, String, String)}.
+//         * <p>
+//         * Any extras from the {@link Insert} class will be passed along to the
+//         * create activity if there are no contacts to show.
+//         * <p>
+//         * Passing true for the {@link #EXTRA_FORCE_CREATE} extra will skip
+//         * prompting the user when the contact doesn't exist.
+//         */
+//        public static final String SHOW_OR_CREATE_CONTACT =
+//                "com.android.contacts.action.SHOW_OR_CREATE_CONTACT";
+//
+//        /**
+//         * Used with {@link #SHOW_OR_CREATE_CONTACT} to force creating a new
+//         * contact if no matching contact found. Otherwise, default behavior is
+//         * to prompt user with dialog before creating.
+//         * <p>
+//         * Type: BOOLEAN
+//         */
+//        public static final String EXTRA_FORCE_CREATE =
+//                "com.android.contacts.action.FORCE_CREATE";
+//
+//        /**
+//         * Used with {@link #SHOW_OR_CREATE_CONTACT} to specify an exact
+//         * description to be shown when prompting user about creating a new
+//         * contact.
+//         * <p>
+//         * Type: STRING
+//         */
+//        public static final String EXTRA_CREATE_DESCRIPTION =
+//            "com.android.contacts.action.CREATE_DESCRIPTION";
+//
+//        /**
+//         * Intents related to the Contacts app UI.
+//         */
+//        public static final class UI {
+//            /**
+//             * The action for the default contacts list tab.
+//             */
+//            public static final String LIST_DEFAULT =
+//                    "com.android.contacts.action.LIST_DEFAULT";
+//
+//            /**
+//             * The action for the contacts list tab.
+//             */
+//            public static final String LIST_GROUP_ACTION =
+//                    "com.android.contacts.action.LIST_GROUP";
+//
+//            /**
+//             * When in LIST_GROUP_ACTION mode, this is the group to display.
+//             */
+//            public static final String GROUP_NAME_EXTRA_KEY = "com.android.contacts.extra.GROUP";
+//
+//            /**
+//             * The action for the all contacts list tab.
+//             */
+//            public static final String LIST_ALL_CONTACTS_ACTION =
+//                    "com.android.contacts.action.LIST_ALL_CONTACTS";
+//
+//            /**
+//             * The action for the contacts with phone numbers list tab.
+//             */
+//            public static final String LIST_CONTACTS_WITH_PHONES_ACTION =
+//                    "com.android.contacts.action.LIST_CONTACTS_WITH_PHONES";
+//
+//            /**
+//             * The action for the starred contacts list tab.
+//             */
+//            public static final String LIST_STARRED_ACTION =
+//                    "com.android.contacts.action.LIST_STARRED";
+//
+//            /**
+//             * The action for the frequent contacts list tab.
+//             */
+//            public static final String LIST_FREQUENT_ACTION =
+//                    "com.android.contacts.action.LIST_FREQUENT";
+//
+//            /**
+//             * The action for the "strequent" contacts list tab. It first lists the starred
+//             * contacts in alphabetical order and then the frequent contacts in descending
+//             * order of the number of times they have been contacted.
+//             */
+//            public static final String LIST_STREQUENT_ACTION =
+//                    "com.android.contacts.action.LIST_STREQUENT";
+//
+//            /**
+//             * A key for to be used as an intent extra to set the activity
+//             * title to a custom String value.
+//             */
+//            public static final String TITLE_EXTRA_KEY =
+//                "com.android.contacts.extra.TITLE_EXTRA";
+//
+//            /**
+//             * Activity Action: Display a filtered list of contacts
+//             * <p>
+//             * Input: Extra field {@link #FILTER_TEXT_EXTRA_KEY} is the text to use for
+//             * filtering
+//             * <p>
+//             * Output: Nothing.
+//             */
+//            public static final String FILTER_CONTACTS_ACTION =
+//                "com.android.contacts.action.FILTER_CONTACTS";
+//
+//            /**
+//             * Used as an int extra field in {@link #FILTER_CONTACTS_ACTION}
+//             * intents to supply the text on which to filter.
+//             */
+//            public static final String FILTER_TEXT_EXTRA_KEY =
+//                "com.android.contacts.extra.FILTER_TEXT";
+//        }
+//
+//        /**
+//         * Convenience class that contains string constants used
+//         * to create contact {@link android.content.Intent Intents}.
+//         */
+//        public static final class Insert {
+//            /** The action code to use when adding a contact */
+//            public static final String ACTION = Intent.ACTION_INSERT;
+//
+//            /**
+//             * If present, forces a bypass of quick insert mode.
+//             */
+//            public static final String FULL_MODE = "full_mode";
+//
+//            /**
+//             * The extra field for the contact name.
+//             * <P>Type: String</P>
+//             */
+//            public static final String NAME = "name";
+//
+//            /**
+//             * The extra field for the contact phonetic name.
+//             * <P>Type: String</P>
+//             */
+//            public static final String PHONETIC_NAME = "phonetic_name";
+//
+//            /**
+//             * The extra field for the contact company.
+//             * <P>Type: String</P>
+//             */
+//            public static final String COMPANY = "company";
+//
+//            /**
+//             * The extra field for the contact job title.
+//             * <P>Type: String</P>
+//             */
+//            public static final String JOB_TITLE = "job_title";
+//
+//            /**
+//             * The extra field for the contact notes.
+//             * <P>Type: String</P>
+//             */
+//            public static final String NOTES = "notes";
+//
+//            /**
+//             * The extra field for the contact phone number.
+//             * <P>Type: String</P>
+//             */
+//            public static final String PHONE = "phone";
+//
+//            /**
+//             * The extra field for the contact phone number type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.PhonesColumns PhonesColumns},
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String PHONE_TYPE = "phone_type";
+//
+//            /**
+//             * The extra field for the phone isprimary flag.
+//             * <P>Type: boolean</P>
+//             */
+//            public static final String PHONE_ISPRIMARY = "phone_isprimary";
+//
+//            /**
+//             * The extra field for an optional second contact phone number.
+//             * <P>Type: String</P>
+//             */
+//            public static final String SECONDARY_PHONE = "secondary_phone";
+//
+//            /**
+//             * The extra field for an optional second contact phone number type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.PhonesColumns PhonesColumns},
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String SECONDARY_PHONE_TYPE = "secondary_phone_type";
+//
+//            /**
+//             * The extra field for an optional third contact phone number.
+//             * <P>Type: String</P>
+//             */
+//            public static final String TERTIARY_PHONE = "tertiary_phone";
+//
+//            /**
+//             * The extra field for an optional third contact phone number type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.PhonesColumns PhonesColumns},
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String TERTIARY_PHONE_TYPE = "tertiary_phone_type";
+//
+//            /**
+//             * The extra field for the contact email address.
+//             * <P>Type: String</P>
+//             */
+//            public static final String EMAIL = "email";
+//
+//            /**
+//             * The extra field for the contact email type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.ContactMethodsColumns ContactMethodsColumns}
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String EMAIL_TYPE = "email_type";
+//
+//            /**
+//             * The extra field for the email isprimary flag.
+//             * <P>Type: boolean</P>
+//             */
+//            public static final String EMAIL_ISPRIMARY = "email_isprimary";
+//
+//            /**
+//             * The extra field for an optional second contact email address.
+//             * <P>Type: String</P>
+//             */
+//            public static final String SECONDARY_EMAIL = "secondary_email";
+//
+//            /**
+//             * The extra field for an optional second contact email type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.ContactMethodsColumns ContactMethodsColumns}
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String SECONDARY_EMAIL_TYPE = "secondary_email_type";
+//
+//            /**
+//             * The extra field for an optional third contact email address.
+//             * <P>Type: String</P>
+//             */
+//            public static final String TERTIARY_EMAIL = "tertiary_email";
+//
+//            /**
+//             * The extra field for an optional third contact email type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.ContactMethodsColumns ContactMethodsColumns}
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String TERTIARY_EMAIL_TYPE = "tertiary_email_type";
+//
+//            /**
+//             * The extra field for the contact postal address.
+//             * <P>Type: String</P>
+//             */
+//            public static final String POSTAL = "postal";
+//
+//            /**
+//             * The extra field for the contact postal address type.
+//             * <P>Type: Either an integer value from {@link android.provider.Contacts.ContactMethodsColumns ContactMethodsColumns}
+//             *  or a string specifying a custom label.</P>
+//             */
+//            public static final String POSTAL_TYPE = "postal_type";
+//
+//            /**
+//             * The extra field for the postal isprimary flag.
+//             * <P>Type: boolean</P>
+//             */
+//            public static final String POSTAL_ISPRIMARY = "postal_isprimary";
+//
+//            /**
+//             * The extra field for an IM handle.
+//             * <P>Type: String</P>
+//             */
+//            public static final String IM_HANDLE = "im_handle";
+//
+//            /**
+//             * The extra field for the IM protocol
+//             * <P>Type: the result of {@link Contacts.ContactMethods#encodePredefinedImProtocol}
+//             * or {@link Contacts.ContactMethods#encodeCustomImProtocol}.</P>
+//             */
+//            public static final String IM_PROTOCOL = "im_protocol";
+//
+//            /**
+//             * The extra field for the IM isprimary flag.
+//             * <P>Type: boolean</P>
+//             */
+//            public static final String IM_ISPRIMARY = "im_isprimary";
+//        }
+//    }
+}
diff --git a/src/com/transage/privatespace/vcard/telephony/JapanesePhoneNumberFormatter.java b/src/com/transage/privatespace/vcard/telephony/JapanesePhoneNumberFormatter.java
new file mode 100755
index 0000000..13b1a6d
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/telephony/JapanesePhoneNumberFormatter.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.telephony;
+
+import com.transage.privatespace.vcard.text.Editable;
+
+/*
+ * Japanese Phone number formatting rule is a bit complicated.
+ * Here are some valid examples:
+ *
+ * 022-229-1234 0223-23-1234 022-301-9876 015-482-7849 0154-91-3478
+ * 01547-5-4534 090-1234-1234 080-0123-6789
+ * 0800-000-9999 0570-000-000 0276-00-0000
+ *
+ * As you can see, there is no straight-forward rule here.
+ * In order to handle this, a big array is prepared.
+ */
+/* package */ class JapanesePhoneNumberFormatter {
+    private static short FORMAT_MAP[] = {
+    -100, 10, 220, -15, 410, 530, -15, 670, 780, 1060,
+    -100, -25, 20, 40, 70, 100, 150, 190, 200, 210,
+    -36, -100, -100, -35, -35, -35, 30, -100, -100, -100,
+    -35, -35, -35, -35, -35, -35, -35, -45, -35, -35,
+    -100, -100, -100, -35, -35, -35, -35, 50, -35, 60,
+    -35, -35, -45, -35, -45, -35, -35, -45, -35, -35,
+    -35, -35, -45, -35, -35, -35, -35, -45, -45, -35,
+    -100, -100, -35, -35, -35, 80, 90, -100, -100, -100,
+    -35, -35, -35, -35, -35, -35, -45, -45, -35, -35,
+    -35, -35, -35, -35, -35, -35, -45, -35, -35, -35,
+    -25, -25, -35, -35, 110, 120, 130, -35, 140, -25,
+    -35, -25, -35, -35, -35, -35, -35, -45, -25, -35,
+    -35, -25, -35, -35, -35, -35, -35, -25, -45, -35,
+    -35, -35, -35, -35, -45, -35, -35, -35, -35, -35,
+    -35, -35, -35, -35, -35, -35, -45, -45, -35, -35,
+    -100, -100, -35, 160, 170, 180, -35, -35, -100, -100,
+    -35, -35, -45, -35, -45, -45, -35, -35, -35, -35,
+    -35, -35, -35, -35, -35, -35, -35, -35, -45, -35,
+    -35, -35, -35, -35, -45, -45, -45, -35, -45, -35,
+    -25, -25, -35, -35, -35, -35, -35, -25, -35, -35,
+    -25, -25, -35, -35, -35, -35, -35, -35, -25, -25,
+    -25, -35, -35, -35, -35, -35, -25, -35, -35, -25,
+    -100, -100, 230, 250, 260, 270, 320, 340, 360, 390,
+    -35, -25, -25, 240, -35, -35, -35, -25, -35, -35,
+    -25, -35, -35, -35, -25, -25, -25, -25, -25, -25,
+    -25, -25, -25, -35, -35, -35, -25, -35, -35, -25,
+    -35, -35, -35, -35, -35, -25, -35, -35, -35, -25,
+    -35, -25, -25, -25, -35, 280, 290, 300, 310, -35,
+    -25, -25, -25, -25, -25, -25, -25, -35, -35, -25,
+    -25, -35, -35, -35, -35, -35, -35, -35, -35, -35,
+    -25, -25, -35, -35, -35, -25, -25, -25, -25, -25,
+    -25, -35, -35, -35, -35, -35, -35, -35, -35, -35,
+    -35, -35, -25, -35, 330, -35, -35, -35, -35, -35,
+    -25, -35, -35, -35, -35, -35, -25, -25, -25, -25,
+    -35, -25, -25, -25, -35, -25, -35, -35, 350, -35,
+    -25, -35, -35, -35, -35, -35, -35, -35, -25, -25,
+    -35, -25, -35, 370, -35, -35, -25, -35, -35, 380,
+    -25, -35, -35, -25, -25, -35, -35, -35, -35, -35,
+    -25, -35, -25, -25, -25, -25, -35, -35, -35, -35,
+    -25, -35, -25, 400, -35, -35, -35, -35, -25, -35,
+    -25, -35, -35, -35, -35, -25, -25, -25, -25, -25,
+    -15, -15, 420, 460, -25, -25, 470, 480, 500, 510,
+    -15, -25, 430, -25, -25, -25, -25, -25, 440, 450,
+    -25, -35, -35, -35, -35, -35, -35, -35, -35, -35,
+    -25, -25, -35, -35, -25, -25, -25, -35, -35, -35,
+    -15, -25, -15, -15, -15, -15, -15, -25, -25, -15,
+    -25, -25, -25, -25, -25, -25, -35, -25, -35, -35,
+    -35, -25, -25, -35, -25, -35, -35, -35, -25, -25,
+    490, -15, -25, -25, -25, -35, -35, -25, -35, -35,
+    -15, -35, -35, -35, -35, -35, -35, -35, -35, -15,
+    -35, -25, -25, -25, -25, -25, -25, -25, -25, -25,
+    -25, -25, -25, -35, -35, -35, -25, -25, -25, 520,
+    -100, -100, -45, -100, -45, -100, -45, -100, -45, -100,
+    -25, -100, -25, 540, 580, 590, 600, 610, 630, 640,
+    -25, -35, -35, -35, -25, -25, -35, -35, -35, 550,
+    -35, -35, -25, -25, -25, -25, 560, 570, -25, -35,
+    -35, -35, -35, -35, -25, -25, -25, -25, -25, -25,
+    -25, -25, -25, -25, -35, -25, -25, -35, -25, -25,
+    -25, -25, -25, -25, -35, -35, -25, -35, -35, -25,
+    -35, -35, -25, -35, -35, -35, -35, -35, -35, -25,
+    -100, -35, -35, -35, -35, -35, -35, -35, -35, -35,
+    -36, -100, -35, -35, -35, -35, 620, -35, -35, -100,
+    -35, -35, -35, -35, -35, -35, -35, -35, -35, -45,
+    -25, -35, -25, -25, -35, -35, -35, -35, -25, -25,
+    -25, -25, -25, -25, -35, -35, -35, 650, -35, 660,
+    -35, -35, -35, -35, -45, -35, -35, -35, -35, -45,
+    -35, -35, -35, -35, -35, -35, -35, -35, -35, -25,
+    -26, -100, 680, 690, 700, -25, 720, 730, -25, 740,
+    -25, -35, -25, -25, -25, -35, -25, -25, -25, -25,
+    -25, -25, -25, -25, -25, -35, -35, -35, -35, -35,
+    -35, -100, -35, -35, -35, -35, 710, -35, -35, -35,
+    -35, -35, -35, -35, -35, -35, -35, -35, -45, -35,
+    -25, -35, -25, -35, -25, -35, -35, -35, -35, -25,
+    -35, -35, -35, -35, -35, -25, -35, -25, -35, -35,
+    -35, -35, -25, -25, 750, 760, 770, -35, -35, -35,
+    -25, -35, -25, -25, -25, -25, -35, -35, -35, -25,
+    -25, -35, -35, -35, -35, -25, -25, -35, -35, -25,
+    -25, -35, -35, -35, -35, -35, -25, -25, -35, -35,
+    790, -100, 800, 850, 900, 920, 940, 1030, 1040, 1050,
+    -36, -26, -26, -26, -26, -26, -26, -26, -26, -26,
+    -35, -25, -25, -35, 810, -25, -35, -35, -25, 820,
+    -25, -35, -25, -25, -35, -35, -35, -35, -35, -25,
+    -25, -35, 830, -35, 840, -35, -25, -35, -35, -25,
+    -35, -25, -25, -25, -25, -25, -25, -25, -25, -25,
+    -100, -25, -25, -25, -100, -100, -100, -100, -100, -100,
+    -25, -25, -35, -35, -35, -35, 860, -35, 870, 880,
+    -25, -35, -35, -35, -35, -35, -35, -35, -35, -35,
+    -35, -35, -35, -35, -35, -35, -35, -45, -45, -35,
+    -100, -100, -100, -100, -100, -100, 890, -100, -100, -100,
+    -25, -45, -45, -25, -45, -45, -25, -45, -45, -45,
+    -25, -25, -25, -25, -25, -35, -35, 910, -35, -25,
+    -35, -35, -35, -35, -35, -35, -35, -45, -35, -35,
+    -100, 930, -35, -35, -35, -35, -35, -35, -35, -35,
+    -100, -100, -45, -100, -45, -100, -100, -100, -100, -100,
+    -25, -25, -25, 950, -25, 970, 990, -35, 1000, 1010,
+    -35, -35, -35, -35, -35, -35, 960, -35, -35, -35,
+    -45, -45, -45, -45, -45, -45, -35, -45, -45, -45,
+    -35, -35, -25, -35, -35, 980, -35, -35, -35, -35,
+    -100, -100, -25, -25, -100, -100, -100, -100, -100, -100,
+    -25, -35, -35, -35, -35, -35, -35, -35, -35, -35,
+    -25, -35, -35, -35, -35, -35, -35, -35, -35, -25,
+    -25, -35, -35, -35, -25, -25, -35, -35, -35, 1020,
+    -45, -45, -35, -35, -45, -45, -45, -45, -45, -45,
+    -25, -25, -25, -25, -25, -35, -25, -35, -25, -35,
+    -35, -25, -25, -35, -35, -35, -25, -35, -25, -35,
+    -25, -25, -35, -35, -35, -35, -35, -35, -35, -25,
+    -26, -100, 1070, 1080, 1090, 1110, 1120, 1130, 1140, 1160,
+    -35, -25, -25, -25, -25, -25, -25, -25, -25, -25,
+    -35, -25, -25, -25, -25, -25, -25, -25, -25, -25,
+    -35, -100, -35, -35, -35, -100, -35, -35, -35, 1100,
+    -35, -35, -35, -35, -35, -35, -45, -35, -35, -35,
+    -35, -25, -35, -25, -35, -35, -35, -35, -25, -35,
+    -25, -25, -25, -25, -35, -35, -35, -35, -35, -35,
+    -25, -25, -35, -35, -35, -25, -25, -35, -35, -35,
+    1150, -25, -35, -35, -35, -35, -35, -35, -25, -25,
+    -35, -35, -45, -35, -35, -35, -35, -35, -35, -35,
+    -35, 1170, -25, -35, 1180, -35, 1190, -35, -25, -25,
+    -100, -100, -45, -45, -100, -100, -100, -100, -100, -100,
+    -25, -35, -35, -35, -35, -35, -35, -25, -25, -35,
+    -35, -35, -35, -35, -35, -35, -35, -35, -35, -45};
+
+    public static void format(Editable text) {
+        // Here, "root" means the position of "'":
+        // 0'3, 0'90, and +81'-90
+        // (dash will be deleted soon, so it is actually +81'90).
+        int rootIndex = 1;
+        int length = text.length();
+        if (length > 3
+                && text.subSequence(0, 3).toString().equals("+81")) {
+            rootIndex = 3;
+        } else if (length < 1 || text.charAt(0) != '0') {
+            return;
+        }
+
+        CharSequence saved = text.subSequence(0, length);
+
+        // Strip the dashes first, as we're going to add them back
+        int i = 0;
+        while (i < text.length()) {
+            if (text.charAt(i) == '-') {
+                text.delete(i, i + 1);
+            } else {
+                i++;
+            }
+        }
+
+        length = text.length();
+        int dashposition;
+
+        i = rootIndex;
+        int base = 0;
+        while (i < length) {
+            char ch = text.charAt(i);
+            if (!Character.isDigit(ch)) {
+                text.replace(0, length, saved);
+                return;
+            }
+            short value = FORMAT_MAP[base + ch - '0'];
+            if (value < 0) {
+                if (value <= -100) {
+                    text.replace(0, length, saved);
+                    return;
+                }
+                int dashPos2 = rootIndex + (Math.abs(value) % 10);
+                if (length > dashPos2) {
+                    text.insert(dashPos2, "-");
+                }
+                int dashPos1 = rootIndex + (Math.abs(value) / 10);
+                if (length > dashPos1) {
+                    text.insert(dashPos1, "-");
+                }
+                break;
+            } else {
+                base = value;
+                i++;
+            }
+        }
+
+        if (length > 3 && rootIndex == 3) {
+            text.insert(rootIndex, "-");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/transage/privatespace/vcard/telephony/PhoneNumberUtils.java b/src/com/transage/privatespace/vcard/telephony/PhoneNumberUtils.java
new file mode 100755
index 0000000..fe93136
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/telephony/PhoneNumberUtils.java
@@ -0,0 +1,1214 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.telephony;
+
+//import android.content.Context;
+//import android.content.Intent;
+//import android.database.Cursor;
+//import android.net.Uri;
+//import android.os.SystemProperties;
+import com.transage.privatespace.vcard.text.Editable;
+import com.transage.privatespace.vcard.text.SpannableStringBuilder;
+//import android.util.SparseIntArray;
+
+import java.util.Locale;
+
+/**
+ * Various utilities for dealing with phone number strings.
+ */
+public class PhoneNumberUtils
+{
+//    /*
+//     * Special characters
+//     *
+//     * (See "What is a phone number?" doc)
+//     * 'p' --- GSM pause character, same as comma
+//     * 'n' --- GSM wild character
+//     * 'w' --- GSM wait character
+//     */
+//    public static final char PAUSE = ',';
+//    public static final char WAIT = ';';
+//    public static final char WILD = 'N';
+//
+//    /*
+//     * TOA = TON + NPI
+//     * See TS 24.008 section 10.5.4.7 for details.
+//     * These are the only really useful TOA values
+//     */
+//    public static final int TOA_International = 0x91;
+//    public static final int TOA_Unknown = 0x81;
+//
+//    /*
+//     * global-phone-number = ["+"] 1*( DIGIT / written-sep )
+//     * written-sep         = ("-"/".")
+//     */
+//    private static final Pattern GLOBAL_PHONE_NUMBER_PATTERN =
+//            Pattern.compile("[\\+]?[0-9.-]+");
+//
+//    /** True if c is ISO-LATIN characters 0-9 */
+//    public static boolean
+//    isISODigit (char c) {
+//        return c >= '0' && c <= '9';
+//    }
+//
+//    /** True if c is ISO-LATIN characters 0-9, *, # */
+//    public final static boolean
+//    is12Key(char c) {
+//        return (c >= '0' && c <= '9') || c == '*' || c == '#';
+//    }
+//
+//    /** True if c is ISO-LATIN characters 0-9, *, # , +, WILD  */
+//    public final static boolean
+//    isDialable(char c) {
+//        return (c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+' || c == WILD;
+//    }
+//
+//    /** True if c is ISO-LATIN characters 0-9, *, # , + (no WILD)  */
+//    public final static boolean
+//    isReallyDialable(char c) {
+//        return (c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+';
+//    }
+//
+//    /** True if c is ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE   */
+//    public final static boolean
+//    isNonSeparator(char c) {
+//        return (c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+'
+//                || c == WILD || c == WAIT || c == PAUSE;
+//    }
+//
+//    /** This any anything to the right of this char is part of the
+//     *  post-dial string (eg this is PAUSE or WAIT)
+//     */
+//    public final static boolean
+//    isStartsPostDial (char c) {
+//        return c == PAUSE || c == WAIT;
+//    }
+//
+//    /** Extracts the phone number from an Intent.
+//     *
+//     * @param intent the intent to get the number of
+//     * @param context a context to use for database access
+//     *
+//     * @return the phone number that would be called by the intent, or
+//     *         <code>null</code> if the number cannot be found.
+//     */
+//    public static String getNumberFromIntent(Intent intent, Context context) {
+//        String number = null;
+//
+//        Uri uri = intent.getData();
+//        String scheme = uri.getScheme();
+//
+//        if (scheme.equals("tel")) {
+//            return uri.getSchemeSpecificPart();
+//        }
+//
+//        if (scheme.equals("voicemail")) {
+//            return TelephonyManager.getDefault().getVoiceMailNumber();
+//        }
+//
+//        if (context == null) {
+//            return null;
+//        }
+//
+//        String type = intent.resolveType(context);
+//
+//        Cursor c = context.getContentResolver().query(
+//                uri, new String[]{ Contacts.People.Phones.NUMBER },
+//                null, null, null);
+//        if (c != null) {
+//            try {
+//                if (c.moveToFirst()) {
+//                    number = c.getString(
+//                            c.getColumnIndex(Contacts.People.Phones.NUMBER));
+//                }
+//            } finally {
+//                c.close();
+//            }
+//        }
+//
+//        return number;
+//    }
+//
+//    /** Extracts the network address portion and canonicalizes
+//     *  (filters out separators.)
+//     *  Network address portion is everything up to DTMF control digit
+//     *  separators (pause or wait), but without non-dialable characters.
+//     *
+//     *  Please note that the GSM wild character is allowed in the result.
+//     *  This must be resolved before dialing.
+//     *
+//     *  Allows + only in the first  position in the result string.
+//     *
+//     *  Returns null if phoneNumber == null
+//     */
+//    public static String
+//    extractNetworkPortion(String phoneNumber) {
+//        if (phoneNumber == null) {
+//            return null;
+//        }
+//
+//        int len = phoneNumber.length();
+//        StringBuilder ret = new StringBuilder(len);
+//        boolean firstCharAdded = false;
+//
+//        for (int i = 0; i < len; i++) {
+//            char c = phoneNumber.charAt(i);
+//            if (isDialable(c) && (c != '+' || !firstCharAdded)) {
+//                firstCharAdded = true;
+//                ret.append(c);
+//            } else if (isStartsPostDial (c)) {
+//                break;
+//            }
+//        }
+//
+//        return ret.toString();
+//    }
+//
+//    /**
+//     * Strips separators from a phone number string.
+//     * @param phoneNumber phone number to strip.
+//     * @return phone string stripped of separators.
+//     */
+//    public static String stripSeparators(String phoneNumber) {
+//        if (phoneNumber == null) {
+//            return null;
+//        }
+//        int len = phoneNumber.length();
+//        StringBuilder ret = new StringBuilder(len);
+//
+//        for (int i = 0; i < len; i++) {
+//            char c = phoneNumber.charAt(i);
+//            if (isNonSeparator(c)) {
+//                ret.append(c);
+//            }
+//        }
+//
+//        return ret.toString();
+//    }
+//
+//    /** or -1 if both are negative */
+//    static private int
+//    minPositive (int a, int b) {
+//        if (a >= 0 && b >= 0) {
+//            return (a < b) ? a : b;
+//        } else if (a >= 0) { /* && b < 0 */
+//            return a;
+//        } else if (b >= 0) { /* && a < 0 */
+//            return b;
+//        } else { /* a < 0 && b < 0 */
+//            return -1;
+//        }
+//    }
+//
+//    /** index of the last character of the network portion
+//     *  (eg anything after is a post-dial string)
+//     */
+//    static private int
+//    indexOfLastNetworkChar(String a) {
+//        int pIndex, wIndex;
+//        int origLength;
+//        int trimIndex;
+//
+//        origLength = a.length();
+//
+//        pIndex = a.indexOf(PAUSE);
+//        wIndex = a.indexOf(WAIT);
+//
+//        trimIndex = minPositive(pIndex, wIndex);
+//
+//        if (trimIndex < 0) {
+//            return origLength - 1;
+//        } else {
+//            return trimIndex - 1;
+//        }
+//    }
+//
+//    /**
+//     * Extracts the post-dial sequence of DTMF control digits, pauses, and
+//     * waits. Strips separators. This string may be empty, but will not be null
+//     * unless phoneNumber == null.
+//     *
+//     * Returns null if phoneNumber == null
+//     */
+//
+//    public static String
+//    extractPostDialPortion(String phoneNumber) {
+//        if (phoneNumber == null) return null;
+//
+//        int trimIndex;
+//        StringBuilder ret = new StringBuilder();
+//
+//        trimIndex = indexOfLastNetworkChar (phoneNumber);
+//
+//        for (int i = trimIndex + 1, s = phoneNumber.length()
+//                ; i < s; i++
+//        ) {
+//            char c = phoneNumber.charAt(i);
+//            if (isNonSeparator(c)) {
+//                ret.append(c);
+//            }
+//        }
+//
+//        return ret.toString();
+//    }
+//
+//    /**
+//     * Compare phone numbers a and b, return true if they're identical
+//     * enough for caller ID purposes.
+//     *
+//     * - Compares from right to left
+//     * - requires MIN_MATCH (5) characters to match
+//     * - handles common trunk prefixes and international prefixes
+//     *   (basically, everything except the Russian trunk prefix)
+//     *
+//     * Tolerates nulls
+//     */
+//    public static boolean
+//    compare(String a, String b) {
+//        int ia, ib;
+//        int matched;
+//
+//        if (a == null || b == null) return a == b;
+//
+//        if (a.length() == 0 || b.length() == 0) {
+//            return false;
+//        }
+//
+//        ia = indexOfLastNetworkChar (a);
+//        ib = indexOfLastNetworkChar (b);
+//        matched = 0;
+//
+//        while (ia >= 0 && ib >=0) {
+//            char ca, cb;
+//            boolean skipCmp = false;
+//
+//            ca = a.charAt(ia);
+//
+//            if (!isDialable(ca)) {
+//                ia--;
+//                skipCmp = true;
+//            }
+//
+//            cb = b.charAt(ib);
+//
+//            if (!isDialable(cb)) {
+//                ib--;
+//                skipCmp = true;
+//            }
+//
+//            if (!skipCmp) {
+//                if (cb != ca && ca != WILD && cb != WILD) {
+//                    break;
+//                }
+//                ia--; ib--; matched++;
+//            }
+//        }
+//
+//        if (matched < MIN_MATCH) {
+//            int aLen = a.length();
+//
+//            // if the input strings match, but their lengths < MIN_MATCH,
+//            // treat them as equal.
+//            if (aLen == b.length() && aLen == matched) {
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//        // At least one string has matched completely;
+//        if (matched >= MIN_MATCH && (ia < 0 || ib < 0)) {
+//            return true;
+//        }
+//
+//        /*
+//         * Now, what remains must be one of the following for a
+//         * match:
+//         *
+//         *  - a '+' on one and a '00' or a '011' on the other
+//         *  - a '0' on one and a (+,00)<country code> on the other
+//         *     (for this, a '0' and a '00' prefix would have succeeded above)
+//         */
+//
+//        if (matchIntlPrefix(a, ia + 1)
+//            && matchIntlPrefix (b, ib +1)
+//        ) {
+//            return true;
+//        }
+//
+//        if (matchTrunkPrefix(a, ia + 1)
+//            && matchIntlPrefixAndCC(b, ib +1)
+//        ) {
+//            return true;
+//        }
+//
+//        if (matchTrunkPrefix(b, ib + 1)
+//            && matchIntlPrefixAndCC(a, ia +1)
+//        ) {
+//            return true;
+//        }
+//
+//        return false;
+//    }
+//
+//    /**
+//     * Returns the rightmost MIN_MATCH (5) characters in the network portion
+//     * in *reversed* order
+//     *
+//     * This can be used to do a database lookup against the column
+//     * that stores getStrippedReversed()
+//     *
+//     * Returns null if phoneNumber == null
+//     */
+//    public static String
+//    toCallerIDMinMatch(String phoneNumber) {
+//        String np = extractNetworkPortion(phoneNumber);
+//        return internalGetStrippedReversed(np, MIN_MATCH);
+//    }
+//
+//    /**
+//     * Returns the network portion reversed.
+//     * This string is intended to go into an index column for a
+//     * database lookup.
+//     *
+//     * Returns null if phoneNumber == null
+//     */
+//    public static String
+//    getStrippedReversed(String phoneNumber) {
+//        String np = extractNetworkPortion(phoneNumber);
+//
+//        if (np == null) return null;
+//
+//        return internalGetStrippedReversed(np, np.length());
+//    }
+//
+//    /**
+//     * Returns the last numDigits of the reversed phone number
+//     * Returns null if np == null
+//     */
+//    private static String
+//    internalGetStrippedReversed(String np, int numDigits) {
+//        if (np == null) return null;
+//
+//        StringBuilder ret = new StringBuilder(numDigits);
+//        int length = np.length();
+//
+//        for (int i = length - 1, s = length
+//            ; i >= 0 && (s - i) <= numDigits ; i--
+//        ) {
+//            char c = np.charAt(i);
+//
+//            ret.append(c);
+//        }
+//
+//        return ret.toString();
+//    }
+//
+//    /**
+//     * Basically: makes sure there's a + in front of a
+//     * TOA_International number
+//     *
+//     * Returns null if s == null
+//     */
+//    public static String
+//    stringFromStringAndTOA(String s, int TOA) {
+//        if (s == null) return null;
+//
+//        if (TOA == TOA_International && s.length() > 0 && s.charAt(0) != '+') {
+//            return "+" + s;
+//        }
+//
+//        return s;
+//    }
+//
+//    /**
+//     * Returns the TOA for the given dial string
+//     * Basically, returns TOA_International if there's a + prefix
+//     */
+//
+//    public static int
+//    toaFromString(String s) {
+//        if (s != null && s.length() > 0 && s.charAt(0) == '+') {
+//            return TOA_International;
+//        }
+//
+//        return TOA_Unknown;
+//    }
+//
+//    /**
+//     * Phone numbers are stored in "lookup" form in the database
+//     * as reversed strings to allow for caller ID lookup
+//     *
+//     * This method takes a phone number and makes a valid SQL "LIKE"
+//     * string that will match the lookup form
+//     *
+//     */
+//    /** all of a up to len must be an international prefix or
+//     *  separators/non-dialing digits
+//     */
+//    private static boolean
+//    matchIntlPrefix(String a, int len) {
+//        /* '([^0-9*#+pwn]\+[^0-9*#+pwn] | [^0-9*#+pwn]0(0|11)[^0-9*#+pwn] )$' */
+//        /*        0       1                           2 3 45               */
+//
+//        int state = 0;
+//        for (int i = 0 ; i < len ; i++) {
+//            char c = a.charAt(i);
+//
+//            switch (state) {
+//                case 0:
+//                    if      (c == '+') state = 1;
+//                    else if (c == '0') state = 2;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                case 2:
+//                    if      (c == '0') state = 3;
+//                    else if (c == '1') state = 4;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                case 4:
+//                    if      (c == '1') state = 5;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                default:
+//                    if (isNonSeparator(c)) return false;
+//                break;
+//
+//            }
+//        }
+//
+//        return state == 1 || state == 3 || state == 5;
+//    }
+//
+//    /**
+//     *  3GPP TS 24.008 10.5.4.7
+//     *  Called Party BCD Number
+//     *
+//     *  See Also TS 51.011 10.5.1 "dialing number/ssc string"
+//     *  and TS 11.11 "10.3.1 EF adn (Abbreviated dialing numbers)"
+//     *
+//     * @param bytes the data buffer
+//     * @param offset should point to the TOA (aka. TON/NPI) octet after the length byte
+//     * @param length is the number of bytes including TOA byte
+//     *                and must be at least 2
+//     *
+//     * @return partial string on invalid decode
+//     *
+//     * FIXME(mkf) support alphanumeric address type
+//     *  currently implemented in SMSMessage.getAddress()
+//     */
+//    public static String
+//    calledPartyBCDToString (byte[] bytes, int offset, int length) {
+//        boolean prependPlus = false;
+//        StringBuilder ret = new StringBuilder(1 + length * 2);
+//
+//        if (length < 2) {
+//            return "";
+//        }
+//
+//        if ((bytes[offset] & 0xff) == TOA_International) {
+//            prependPlus = true;
+//        }
+//
+//        internalCalledPartyBCDFragmentToString(
+//                ret, bytes, offset + 1, length - 1);
+//
+//        if (prependPlus && ret.length() == 0) {
+//            // If the only thing there is a prepended plus, return ""
+//            return "";
+//        }
+//
+//        if (prependPlus) {
+//            // This is an "international number" and should have
+//            // a plus prepended to the dialing number. But there
+//            // can also be Gsm MMI codes as defined in TS 22.030 6.5.2
+//            // so we need to handle those also.
+//            //
+//            // http://web.telia.com/~u47904776/gsmkode.htm is a
+//            // has a nice list of some of these GSM codes.
+//            //
+//            // Examples are:
+//            //   **21*+886988171479#
+//            //   **21*8311234567#
+//            //   *21#
+//            //   #21#
+//            //   *#21#
+//            //   *31#+11234567890
+//            //   #31#+18311234567
+//            //   #31#8311234567
+//            //   18311234567
+//            //   +18311234567#
+//            //   +18311234567
+//            // Odd ball cases that some phones handled
+//            // where there is no dialing number so they
+//            // append the "+"
+//            //   *21#+
+//            //   **21#+
+//            String retString = ret.toString();
+//            Pattern p = Pattern.compile("(^[#*])(.*)([#*])(.*)(#)$");
+//            Matcher m = p.matcher(retString);
+//            if (m.matches()) {
+//                if ("".equals(m.group(2))) {
+//                    // Started with two [#*] ends with #
+//                    // So no dialing number and we'll just
+//                    // append a +, this handles **21#+
+//                    ret = new StringBuilder();
+//                    ret.append(m.group(1));
+//                    ret.append(m.group(3));
+//                    ret.append(m.group(4));
+//                    ret.append(m.group(5));
+//                    ret.append("+");
+//                } else {
+//                    // Starts with [#*] and ends with #
+//                    // Assume group 4 is a dialing number
+//                    // such as *21*+1234554#
+//                    ret = new StringBuilder();
+//                    ret.append(m.group(1));
+//                    ret.append(m.group(2));
+//                    ret.append(m.group(3));
+//                    ret.append("+");
+//                    ret.append(m.group(4));
+//                    ret.append(m.group(5));
+//                }
+//            } else {
+//                p = Pattern.compile("(^[#*])(.*)([#*])(.*)");
+//                m = p.matcher(retString);
+//                if (m.matches()) {
+//                    // Starts with [#*] and only one other [#*]
+//                    // Assume the data after last [#*] is dialing
+//                    // number (i.e. group 4) such as *31#+11234567890.
+//                    // This also includes the odd ball *21#+
+//                    ret = new StringBuilder();
+//                    ret.append(m.group(1));
+//                    ret.append(m.group(2));
+//                    ret.append(m.group(3));
+//                    ret.append("+");
+//                    ret.append(m.group(4));
+//                } else {
+//                    // Does NOT start with [#*] just prepend '+'
+//                    ret = new StringBuilder();
+//                    ret.append('+');
+//                    ret.append(retString);
+//                }
+//            }
+//        }
+//
+//        return ret.toString();
+//    }
+//
+//    private static void
+//    internalCalledPartyBCDFragmentToString(
+//        StringBuilder sb, byte [] bytes, int offset, int length) {
+//        for (int i = offset ; i < length + offset ; i++) {
+//            byte b;
+//            char c;
+//
+//            c = bcdToChar((byte)(bytes[i] & 0xf));
+//
+//            if (c == 0) {
+//                return;
+//            }
+//            sb.append(c);
+//
+//            // FIXME(mkf) TS 23.040 9.1.2.3 says
+//            // "if a mobile receives 1111 in a position prior to
+//            // the last semi-octet then processing shall commense with
+//            // the next semi-octet and the intervening
+//            // semi-octet shall be ignored"
+//            // How does this jive with 24,008 10.5.4.7
+//
+//            b = (byte)((bytes[i] >> 4) & 0xf);
+//
+//            if (b == 0xf && i + 1 == length + offset) {
+//                //ignore final 0xf
+//                break;
+//            }
+//
+//            c = bcdToChar(b);
+//            if (c == 0) {
+//                return;
+//            }
+//
+//            sb.append(c);
+//        }
+//
+//    }
+//
+//    /**
+//     * Like calledPartyBCDToString, but field does not start with a
+//     * TOA byte. For example: SIM ADN extension fields
+//     */
+//
+//    public static String
+//    calledPartyBCDFragmentToString(byte [] bytes, int offset, int length) {
+//        StringBuilder ret = new StringBuilder(length * 2);
+//
+//        internalCalledPartyBCDFragmentToString(ret, bytes, offset, length);
+//
+//        return ret.toString();
+//    }
+//
+//    /** returns 0 on invalid value */
+//    private static char
+//    bcdToChar(byte b) {
+//        if (b < 0xa) {
+//            return (char)('0' + b);
+//        } else switch (b) {
+//            case 0xa: return '*';
+//            case 0xb: return '#';
+//            case 0xc: return PAUSE;
+//            case 0xd: return WILD;
+//
+//            default: return 0;
+//        }
+//    }
+//
+//    private static int
+//    charToBCD(char c) {
+//        if (c >= '0' && c <= '9') {
+//            return c - '0';
+//        } else if (c == '*') {
+//            return 0xa;
+//        } else if (c == '#') {
+//            return 0xb;
+//        } else if (c == PAUSE) {
+//            return 0xc;
+//        } else if (c == WILD) {
+//            return 0xd;
+//        } else {
+//            throw new RuntimeException ("invalid char for BCD " + c);
+//        }
+//    }
+//
+//    /**
+//     * Return true iff the network portion of <code>address</code> is,
+//     * as far as we can tell on the device, suitable for use as an SMS
+//     * destination address.
+//     */
+//    public static boolean isWellFormedSmsAddress(String address) {
+//        String networkPortion =
+//                PhoneNumberUtils.extractNetworkPortion(address);
+//
+//        return (!(networkPortion.equals("+")
+//                  || TextUtils.isEmpty(networkPortion)))
+//               && isDialable(networkPortion);
+//    }
+//
+//    public static boolean isGlobalPhoneNumber(String phoneNumber) {
+//        if (TextUtils.isEmpty(phoneNumber)) {
+//            return false;
+//        }
+//
+//        Matcher match = GLOBAL_PHONE_NUMBER_PATTERN.matcher(phoneNumber);
+//        return match.matches();
+//    }
+//
+//    private static boolean isDialable(String address) {
+//        for (int i = 0, count = address.length(); i < count; i++) {
+//            if (!isDialable(address.charAt(i))) {
+//                return false;
+//            }
+//        }
+//        return true;
+//    }
+//
+//    /**
+//     * Note: calls extractNetworkPortion(), so do not use for
+//     * SIM EF[ADN] style records
+//     *
+//     * Returns null if network portion is empty.
+//     */
+//    public static byte[]
+//    networkPortionToCalledPartyBCD(String s) {
+//        String networkPortion = extractNetworkPortion(s);
+//        return numberToCalledPartyBCDHelper(networkPortion, false);
+//    }
+//
+//    /**
+//     * Same as {@link #networkPortionToCalledPartyBCD}, but includes a
+//     * one-byte length prefix.
+//     */
+//    public static byte[]
+//    networkPortionToCalledPartyBCDWithLength(String s) {
+//        String networkPortion = extractNetworkPortion(s);
+//        return numberToCalledPartyBCDHelper(networkPortion, true);
+//    }
+//
+//    /**
+//     * Convert a dialing number to BCD byte array
+//     *
+//     * @param number dialing number string
+//     *        if the dialing number starts with '+', set to internationl TOA
+//     * @return BCD byte array
+//     */
+//    public static byte[]
+//    numberToCalledPartyBCD(String number) {
+//        return numberToCalledPartyBCDHelper(number, false);
+//    }
+//
+//    /**
+//     * If includeLength is true, prepend a one-byte length value to
+//     * the return array.
+//     */
+//    private static byte[]
+//    numberToCalledPartyBCDHelper(String number, boolean includeLength) {
+//        int numberLenReal = number.length();
+//        int numberLenEffective = numberLenReal;
+//        boolean hasPlus = number.indexOf('+') != -1;
+//        if (hasPlus) numberLenEffective--;
+//
+//        if (numberLenEffective == 0) return null;
+//
+//        int resultLen = (numberLenEffective + 1) / 2;  // Encoded numbers require only 4 bits each.
+//        int extraBytes = 1;                            // Prepended TOA byte.
+//        if (includeLength) extraBytes++;               // Optional prepended length byte.
+//        resultLen += extraBytes;
+//
+//        byte[] result = new byte[resultLen];
+//
+//        int digitCount = 0;
+//        for (int i = 0; i < numberLenReal; i++) {
+//            char c = number.charAt(i);
+//            if (c == '+') continue;
+//            int shift = ((digitCount & 0x01) == 1) ? 4 : 0;
+//            result[extraBytes + (digitCount >> 1)] |= (byte)((charToBCD(c) & 0x0F) << shift);
+//            digitCount++;
+//        }
+//
+//        // 1-fill any trailing odd nibble/quartet.
+//        if ((digitCount & 0x01) == 1) result[extraBytes + (digitCount >> 1)] |= 0xF0;
+//
+//        int offset = 0;
+//        if (includeLength) result[offset++] = (byte)(resultLen - 1);
+//        result[offset] = (byte)(hasPlus ? TOA_International : TOA_Unknown);
+//
+//        return result;
+//    }
+//
+//    /** all of 'a' up to len must match non-US trunk prefix ('0') */
+//    private static boolean
+//    matchTrunkPrefix(String a, int len) {
+//        boolean found;
+//
+//        found = false;
+//
+//        for (int i = 0 ; i < len ; i++) {
+//            char c = a.charAt(i);
+//
+//            if (c == '0' && !found) {
+//                found = true;
+//            } else if (isNonSeparator(c)) {
+//                return false;
+//            }
+//        }
+//
+//        return found;
+//    }
+//
+//    /** all of 'a' up to len must be a (+|00|011)country code)
+//     *  We're fast and loose with the country code. Any \d{1,3} matches */
+//    private static boolean
+//    matchIntlPrefixAndCC(String a, int len) {
+//        /*  [^0-9*#+pwn]*(\+|0(0|11)\d\d?\d? [^0-9*#+pwn] $ */
+//        /*      0          1 2 3 45  6 7  8                 */
+//
+//        int state = 0;
+//        for (int i = 0 ; i < len ; i++ ) {
+//            char c = a.charAt(i);
+//
+//            switch (state) {
+//                case 0:
+//                    if      (c == '+') state = 1;
+//                    else if (c == '0') state = 2;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                case 2:
+//                    if      (c == '0') state = 3;
+//                    else if (c == '1') state = 4;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                case 4:
+//                    if      (c == '1') state = 5;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                case 1:
+//                case 3:
+//                case 5:
+//                    if      (isISODigit(c)) state = 6;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                case 6:
+//                case 7:
+//                    if      (isISODigit(c)) state++;
+//                    else if (isNonSeparator(c)) return false;
+//                break;
+//
+//                default:
+//                    if (isNonSeparator(c)) return false;
+//            }
+//        }
+//
+//        return state == 6 || state == 7 || state == 8;
+//    }
+//
+//    //================ Number formatting =========================
+//
+    /** The current locale is unknown, look for a country code or don't format */
+    public static final int FORMAT_UNKNOWN = 0;
+    /** NANP formatting */
+    public static final int FORMAT_NANP = 1;
+    /** Japastaticnese formatting */
+    public static final int FORMAT_JAPAN = 2;
+
+    /** List of country codes for countries that use the NANP */
+    private static final String[] NANP_COUNTRIES = new String[] {
+        "US", // United States
+        "CA", // Canada
+        "AS", // American Samoa
+        "AI", // Anguilla
+        "AG", // Antigua and Barbuda
+        "BS", // Bahamas
+        "BB", // Barbados
+        "BM", // Bermuda
+        "VG", // British Virgin Islands
+        "KY", // Cayman Islands
+        "DM", // Dominica
+        "DO", // Dominican Republic
+        "GD", // Grenada
+        "GU", // Guam
+        "JM", // Jamaica
+        "PR", // Puerto Rico
+        "MS", // Montserrat
+        "NP", // Northern Mariana Islands
+        "KN", // Saint Kitts and Nevis
+        "LC", // Saint Lucia
+        "VC", // Saint Vincent and the Grenadines
+        "TT", // Trinidad and Tobago
+        "TC", // Turks and Caicos Islands
+        "VI", // U.S. Virgin Islands
+    };
+
+    /**
+     * Breaks the given number down and formats it according to the rules
+     * for the country the number is from.
+     *
+     * @param source the phone number to format
+     * @return a locally acceptable formatting of the input, or the raw input if
+     *  formatting rules aren't known for the number
+     */
+    public static String formatNumber(String source) {
+        SpannableStringBuilder text = new SpannableStringBuilder(source);
+        formatNumber(text, getFormatTypeForLocale(Locale.getDefault()));
+        return text.toString();
+    }
+
+    /**
+     * Returns the phone number formatting type for the given locale.
+     *
+     * @param locale The locale of interest, usually {@link Locale#getDefault()}
+     * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formatting
+     * rules are not known for the given locale
+     */
+    public static int getFormatTypeForLocale(Locale locale) {
+        String country = locale.getCountry();
+
+        // Check for the NANP countries
+        int length = NANP_COUNTRIES.length;
+        for (int i = 0; i < length; i++) {
+            if (NANP_COUNTRIES[i].equals(country)) {
+                return FORMAT_NANP;
+            }
+        }
+        if (locale.equals(Locale.JAPAN)) {
+            return FORMAT_JAPAN;
+        }
+        return FORMAT_UNKNOWN;
+    }
+
+    /**
+     * Formats a phone number in-place. Currently only supports NANP formatting.
+     *
+     * @param text The number to be formatted, will be modified with the formatting
+     * @param defaultFormattingType The default formatting rules to apply if the number does
+     * not begin with +<country_code>
+     */
+    public static void formatNumber(Editable text, int defaultFormattingType) {
+        int formatType = defaultFormattingType;
+
+        if (text.length() > 2 && text.charAt(0) == '+') {
+            if (text.charAt(1) == '1') {
+                formatType = FORMAT_NANP;
+            } else if (text.length() >= 3 && text.charAt(1) == '8'
+                && text.charAt(2) == '1') {
+                formatType = FORMAT_JAPAN;
+            } else {
+                return;
+            }
+        }
+
+        switch (formatType) {
+            case FORMAT_NANP:
+                formatNanpNumber(text);
+                return;
+            case FORMAT_JAPAN:
+                formatJapaneseNumber(text);
+                return;
+        }
+    }
+
+    private static final int NANP_STATE_DIGIT = 1;
+    private static final int NANP_STATE_PLUS = 2;
+    private static final int NANP_STATE_ONE = 3;
+    private static final int NANP_STATE_DASH = 4;
+
+    /**
+     * Formats a phone number in-place using the NANP formatting rules. Numbers will be formatted
+     * as:
+     *
+     * <p><code>
+     * xxx-xxxx
+     * xxx-xxx-xxxx
+     * 1-xxx-xxx-xxxx
+     * +1-xxx-xxx-xxxx
+     * </code></p>
+     *
+     * @param text the number to be formatted, will be modified with the formatting
+     */
+    public static void formatNanpNumber(Editable text) {
+        int length = text.length();
+        if (length > "+1-nnn-nnn-nnnn".length()) {
+            // The string is too long to be formatted
+            return;
+        }
+        CharSequence saved = text.subSequence(0, length);
+
+        // Strip the dashes first, as we're going to add them back
+        int p = 0;
+        while (p < text.length()) {
+            if (text.charAt(p) == '-') {
+                text.delete(p, p + 1);
+            } else {
+                p++;
+            }
+        }
+        length = text.length();
+
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[3];
+        int numDashes = 0;
+
+        int state = NANP_STATE_DIGIT;
+        int numDigits = 0;
+        for (int i = 0; i < length; i++) {
+            char c = text.charAt(i);
+            switch (c) {
+                case '1':
+                    if (numDigits == 0 || state == NANP_STATE_PLUS) {
+                        state = NANP_STATE_ONE;
+                        break;
+                    }
+                    // fall through
+                case '2':
+                case '3':
+                case '4':
+                case '5':
+                case '6':
+                case '7':
+                case '8':
+                case '9':
+                case '0':
+                    if (state == NANP_STATE_PLUS) {
+                        // Only NANP number supported for now
+                        text.replace(0, length, saved);
+                        return;
+                    } else if (state == NANP_STATE_ONE) {
+                        // Found either +1 or 1, follow it up with a dash
+                        dashPositions[numDashes++] = i;
+                    } else if (state != NANP_STATE_DASH && (numDigits == 3 || numDigits == 6)) {
+                        // Found a digit that should be after a dash that isn't
+                        dashPositions[numDashes++] = i;
+                    }
+                    state = NANP_STATE_DIGIT;
+                    numDigits++;
+                    break;
+
+                case '-':
+                    state = NANP_STATE_DASH;
+                    break;
+
+                case '+':
+                    if (i == 0) {
+                        // Plus is only allowed as the first character
+                        state = NANP_STATE_PLUS;
+                        break;
+                    }
+                    // Fall through
+                default:
+                    // Unknown character, bail on formatting
+                    text.replace(0, length, saved);
+                    return;
+            }
+        }
+
+        if (numDigits == 7) {
+            // With 7 digits we want xxx-xxxx, not xxx-xxx-x
+            numDashes--;
+        }
+
+        // Actually put the dashes in place
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            text.replace(pos + i, pos + i, "-");
+        }
+
+        // Remove trailing dashes
+        int len = text.length();
+        while (len > 0) {
+            if (text.charAt(len - 1) == '-') {
+                text.delete(len - 1, len);
+                len--;
+            } else {
+                break;
+            }
+        }
+    }
+
+    /**
+     * Formats a phone number in-place using the Japanese formatting rules.
+     * Numbers will be formatted as:
+     *
+     * <p><code>
+     * 03-xxxx-xxxx
+     * 090-xxxx-xxxx
+     * 0120-xxx-xxx
+     * +81-3-xxxx-xxxx
+     * +81-90-xxxx-xxxx
+     * </code></p>
+     *
+     * @param text the number to be formatted, will be modified with
+     * the formatting
+     */
+    public static void formatJapaneseNumber(Editable text) {
+        JapanesePhoneNumberFormatter.format(text);
+    }
+//
+//    // Three and four digit phone numbers for either special services
+//    // or from the network (eg carrier-originated SMS messages) should
+//    // not match
+//    static final int MIN_MATCH = 5;
+//
+//    /**
+//     * isEmergencyNumber: checks a given number against the list of
+//     *   emergency numbers provided by the RIL and SIM card.
+//     *
+//     * @param number the number to look up.
+//     * @return if the number is in the list of emergency numbers
+//     * listed in the ril / sim, then return true, otherwise false.
+//     */
+//    public static boolean isEmergencyNumber(String number) {
+//        // Strip the separators from the number before comparing it
+//        // to the list.
+//        number = extractNetworkPortion(number);
+//
+//        // retrieve the list of emergency numbers
+//        String numbers = SystemProperties.get("ro.ril.ecclist");
+//
+//        if (!TextUtils.isEmpty(numbers)) {
+//            // searches through the comma-separated list for a match,
+//            // return true if one is found.
+//            for (String emergencyNum : numbers.split(",")) {
+//                if (emergencyNum.equals(number)) {
+//                    return true;
+//                }
+//            }
+//            // no matches found against the list!
+//            return false;
+//        }
+//
+//        //no ecclist system property, so use our own list.
+//        return (number.equals("112") || number.equals("911"));
+//    }
+//
+//    /**
+//     * Translates any alphabetic letters (i.e. [A-Za-z]) in the
+//     * specified phone number into the equivalent numeric digits,
+//     * according to the phone keypad letter mapping described in
+//     * ITU E.161 and ISO/IEC 9995-8.
+//     *
+//     * @return the input string, with alpha letters converted to numeric
+//     *         digits using the phone keypad letter mapping.  For example,
+//     *         an input of "1-800-GOOG-411" will return "1-800-4664-411".
+//     */
+//    public static String convertKeypadLettersToDigits(String input) {
+//        if (input == null) {
+//            return input;
+//        }
+//        int len = input.length();
+//        if (len == 0) {
+//            return input;
+//        }
+//
+//        char[] out = input.toCharArray();
+//
+//        for (int i = 0; i < len; i++) {
+//            char c = out[i];
+//            // If this char isn't in KEYPAD_MAP at all, just leave it alone.
+//            out[i] = (char) KEYPAD_MAP.get(c, c);
+//        }
+//
+//        return new String(out);
+//    }
+//
+//    /**
+//     * The phone keypad letter mapping (see ITU E.161 or ISO/IEC 9995-8.)
+//     * TODO: This should come from a resource.
+//     */
+//    private static final SparseIntArray KEYPAD_MAP = new SparseIntArray();
+//    static {
+//        KEYPAD_MAP.put('a', '2'); KEYPAD_MAP.put('b', '2'); KEYPAD_MAP.put('c', '2');
+//        KEYPAD_MAP.put('A', '2'); KEYPAD_MAP.put('B', '2'); KEYPAD_MAP.put('C', '2');
+//
+//        KEYPAD_MAP.put('d', '3'); KEYPAD_MAP.put('e', '3'); KEYPAD_MAP.put('f', '3');
+//        KEYPAD_MAP.put('D', '3'); KEYPAD_MAP.put('E', '3'); KEYPAD_MAP.put('F', '3');
+//
+//        KEYPAD_MAP.put('g', '4'); KEYPAD_MAP.put('h', '4'); KEYPAD_MAP.put('i', '4');
+//        KEYPAD_MAP.put('G', '4'); KEYPAD_MAP.put('H', '4'); KEYPAD_MAP.put('I', '4');
+//
+//        KEYPAD_MAP.put('j', '5'); KEYPAD_MAP.put('k', '5'); KEYPAD_MAP.put('l', '5');
+//        KEYPAD_MAP.put('J', '5'); KEYPAD_MAP.put('K', '5'); KEYPAD_MAP.put('L', '5');
+//
+//        KEYPAD_MAP.put('m', '6'); KEYPAD_MAP.put('n', '6'); KEYPAD_MAP.put('o', '6');
+//        KEYPAD_MAP.put('M', '6'); KEYPAD_MAP.put('N', '6'); KEYPAD_MAP.put('O', '6');
+//
+//        KEYPAD_MAP.put('p', '7'); KEYPAD_MAP.put('q', '7'); KEYPAD_MAP.put('r', '7'); KEYPAD_MAP.put('s', '7');
+//        KEYPAD_MAP.put('P', '7'); KEYPAD_MAP.put('Q', '7'); KEYPAD_MAP.put('R', '7'); KEYPAD_MAP.put('S', '7');
+//
+//        KEYPAD_MAP.put('t', '8'); KEYPAD_MAP.put('u', '8'); KEYPAD_MAP.put('v', '8');
+//        KEYPAD_MAP.put('T', '8'); KEYPAD_MAP.put('U', '8'); KEYPAD_MAP.put('V', '8');
+//
+//        KEYPAD_MAP.put('w', '9'); KEYPAD_MAP.put('x', '9'); KEYPAD_MAP.put('y', '9'); KEYPAD_MAP.put('z', '9');
+//        KEYPAD_MAP.put('W', '9'); KEYPAD_MAP.put('X', '9'); KEYPAD_MAP.put('Y', '9'); KEYPAD_MAP.put('Z', '9');
+//    }
+}
diff --git a/src/com/transage/privatespace/vcard/text/Editable.java b/src/com/transage/privatespace/vcard/text/Editable.java
new file mode 100755
index 0000000..3364131
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/Editable.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * This is the interface for text whose content and markup
+ * can be changed (as opposed
+ * to immutable text like Strings).  If you make a {@link DynamicLayout}
+ * of an Editable, the layout will be reflowed as the text is changed.
+ */
+public interface Editable
+extends CharSequence, GetChars, /*Spannable,*/ Appendable
+{
+    /**
+     * Replaces the specified range (<code>st&hellip;en</code>) of text in this
+     * Editable with a copy of the slice <code>start&hellip;end</code> from
+     * <code>source</code>.  The destination slice may be empty, in which case
+     * the operation is an insertion, or the source slice may be empty,
+     * in which case the operation is a deletion.
+     * <p>
+     * Before the change is committed, each filter that was set with
+     * {@link #setFilters} is given the opportunity to modify the
+     * <code>source</code> text.
+     * <p>
+     * If <code>source</code>
+     * is Spanned, the spans from it are preserved into the Editable.
+     * Existing spans within the Editable that entirely cover the replaced
+     * range are retained, but any that were strictly within the range
+     * that was replaced are removed.  As a special case, the cursor
+     * position is preserved even when the entire range where it is
+     * located is replaced.
+     * @return  a reference to this object.
+     */
+    public Editable replace(int st, int en, CharSequence source, int start, int end);
+
+    /**
+     * Convenience for replace(st, en, text, 0, text.length())
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable replace(int st, int en, CharSequence text);
+
+    /**
+     * Convenience for replace(where, where, text, start, end)
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable insert(int where, CharSequence text, int start, int end);
+
+    /**
+     * Convenience for replace(where, where, text, 0, text.length());
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable insert(int where, CharSequence text);
+
+    /**
+     * Convenience for replace(st, en, "", 0, 0)
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable delete(int st, int en);
+
+    /**
+     * Convenience for replace(length(), length(), text, 0, text.length())
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable append(CharSequence text);
+
+    /**
+     * Convenience for replace(length(), length(), text, start, end)
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable append(CharSequence text, int start, int end);
+
+    /**
+     * Convenience for append(String.valueOf(text)).
+     * @see #replace(int, int, CharSequence, int, int)
+     */
+    public Editable append(char text);
+
+    /**
+     * Convenience for replace(0, length(), "", 0, 0)
+     * @see #replace(int, int, CharSequence, int, int)
+     * Note that this clears the text, not the spans;
+     * use {@link #clearSpans} if you need that.
+     */
+    public void clear();
+
+    /**
+     * Removes all spans from the Editable, as if by calling
+     * {@link #removeSpan} on each of them.
+     */
+    public void clearSpans();
+
+    /**
+     * Sets the series of filters that will be called in succession
+     * whenever the text of this Editable is changed, each of which has
+     * the opportunity to limit or transform the text that is being inserted.
+     */
+    public void setFilters(InputFilter[] filters);
+
+    /**
+     * Returns the array of input filters that are currently applied
+     * to changes to this Editable.
+     */
+    public InputFilter[] getFilters();
+
+    /**
+     * Factory used by TextView to create new Editables.  You can subclass
+     * it to provide something other than SpannableStringBuilder.
+     */
+    public static class Factory {
+        private static Factory sInstance = new Factory();
+
+        /**
+         * Returns the standard Editable Factory.
+         */
+        public static Factory getInstance() {
+            return sInstance;
+        }
+
+        /**
+         * Returns a new SpannedStringBuilder from the specified
+         * CharSequence.  You can override this to provide
+         * a different kind of Spanned.
+         */
+        public Editable newEditable(CharSequence source) {
+            return new SpannableStringBuilder(source);
+        }
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/text/GetChars.java b/src/com/transage/privatespace/vcard/text/GetChars.java
new file mode 100755
index 0000000..0f070d0
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/GetChars.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * Please implement this interface if your CharSequence has a
+ * getChars() method like the one in String that is faster than
+ * calling charAt() multiple times.
+ */
+public interface GetChars
+extends CharSequence
+{
+    /**
+     * Exactly like String.getChars(): copy chars <code>start</code>
+     * through <code>end - 1</code> from this CharSequence into <code>dest</code>
+     * beginning at offset <code>destoff</code>.
+     */
+    public void getChars(int start, int end, char[] dest, int destoff);
+}
diff --git a/src/com/transage/privatespace/vcard/text/InputFilter.java b/src/com/transage/privatespace/vcard/text/InputFilter.java
new file mode 100755
index 0000000..d62bdb7
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/InputFilter.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * InputFilters can be attached to {@link Editable}s to constrain the
+ * changes that can be made to them.
+ */
+public interface InputFilter
+{
+    /**
+     * This method is called when the buffer is going to replace the
+     * range <code>dstart &hellip; dend</code> of <code>dest</code>
+     * with the new text from the range <code>start &hellip; end</code>
+     * of <code>source</code>.  Return the CharSequence that you would
+     * like to have placed there instead, including an empty string
+     * if appropriate, or <code>null</code> to accept the original
+     * replacement.  Be careful to not to reject 0-length replacements,
+     * as this is what happens when you delete text.  Also beware that
+     * you should not attempt to make any changes to <code>dest</code>
+     * from this method; you may only examine it for context.
+     * 
+     * Note: If <var>source</var> is an instance of {@link Spanned} or
+     * {@link Spannable}, the span objects in the <var>source</var> should be 
+     * copied into the filtered result (i.e. the non-null return value). 
+     * {@link TextUtils#copySpansFrom} can be used for convenience.
+     */
+    public CharSequence filter(CharSequence source, int start, int end,
+                               Spanned dest, int dstart, int dend);
+
+//    /**
+//     * This filter will capitalize all the lower case letters that are added
+//     * through edits.
+//     */
+//    public static class AllCaps implements InputFilter {
+//        public CharSequence filter(CharSequence source, int start, int end,
+//                                   Spanned dest, int dstart, int dend) {
+//            for (int i = start; i < end; i++) {
+//                if (Character.isLowerCase(source.charAt(i))) {
+//                    char[] v = new char[end - start];
+//                    TextUtils.getChars(source, start, end, v, 0);
+//                    String s = new String(v).toUpperCase();
+//
+//                    if (source instanceof Spanned) {
+//                        SpannableString sp = new SpannableString(s);
+//                        TextUtils.copySpansFrom((Spanned) source,
+//                                                start, end, null, sp, 0);
+//                        return sp;
+//                    } else {
+//                        return s;
+//                    }
+//                }
+//            }
+//
+//            return null; // keep original
+//        }
+//    }
+
+    /**
+     * This filter will constrain edits not to make the length of the text
+     * greater than the specified length.
+     */
+    public static class LengthFilter implements InputFilter {
+        public LengthFilter(int max) {
+            mMax = max;
+        }
+
+        public CharSequence filter(CharSequence source, int start, int end,
+                                   Spanned dest, int dstart, int dend) {
+            int keep = mMax - (dest.length() - (dend - dstart));
+
+            if (keep <= 0) {
+                return "";
+            } else if (keep >= end - start) {
+                return null; // keep original
+            } else {
+                return source.subSequence(start, start + keep);
+            }
+        }
+
+        private int mMax;
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/text/NoCopySpan.java b/src/com/transage/privatespace/vcard/text/NoCopySpan.java
new file mode 100755
index 0000000..ca715c4
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/NoCopySpan.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * This interface should be added to a span object that should not be copied
+ * into a new Spenned when performing a slice or copy operation on the original
+ * Spanned it was placed in.
+ */
+public interface NoCopySpan {
+    /**
+     * Convenience equivalent for when you would just want a new Object() for
+     * a span but want it to be no-copy.  Use this instead.
+     */
+    public class Concrete implements NoCopySpan {
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/text/Selection.java b/src/com/transage/privatespace/vcard/text/Selection.java
new file mode 100755
index 0000000..fc2ae60
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/Selection.java
@@ -0,0 +1,429 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+
+/**
+ * Utility class for manipulating cursors and selections in CharSequences.
+ * A cursor is a selection where the start and end are at the same offset.
+ */
+public class Selection {
+    private Selection() { /* cannot be instantiated */ }
+
+    /*
+     * Retrieving the selection
+     */
+
+    /**
+     * Return the offset of the selection anchor or cursor, or -1 if
+     * there is no selection or cursor.
+     */
+    public static final int getSelectionStart(CharSequence text) {
+        if (text instanceof Spanned)
+            return ((Spanned) text).getSpanStart(SELECTION_START);
+        else
+            return -1;
+    }
+   
+    /**
+     * Return the offset of the selection edge or cursor, or -1 if
+     * there is no selection or cursor.
+     */
+    public static final int getSelectionEnd(CharSequence text) {
+        if (text instanceof Spanned)
+            return ((Spanned) text).getSpanStart(SELECTION_END);
+        else
+            return -1;
+    }
+
+    /*
+     * Setting the selection
+     */
+
+    // private static int pin(int value, int min, int max) {
+    //     return value < min ? 0 : (value > max ? max : value);
+    // }
+   
+    /**
+     * Set the selection anchor to <code>start</code> and the selection edge
+     * to <code>stop</code>.
+     */
+    public static void setSelection(Spannable text, int start, int stop) {
+        // int len = text.length();
+        // start = pin(start, 0, len);  XXX remove unless we really need it
+        // stop = pin(stop, 0, len);
+
+        int ostart = getSelectionStart(text);
+        int oend = getSelectionEnd(text);
+    
+        if (ostart != start || oend != stop) {
+            text.setSpan(SELECTION_START, start, start,
+                         Spanned.SPAN_POINT_POINT|Spanned.SPAN_INTERMEDIATE);
+            text.setSpan(SELECTION_END, stop, stop,
+                         Spanned.SPAN_POINT_POINT);
+        }
+    }
+
+    /**
+     * Move the cursor to offset <code>index</code>.
+     */
+    public static final void setSelection(Spannable text, int index) {
+        setSelection(text, index, index);
+    }
+
+    /**
+     * Select the entire text.
+     */
+    public static final void selectAll(Spannable text) {
+        setSelection(text, 0, text.length());
+    }
+
+    /**
+     * Move the selection edge to offset <code>index</code>.
+     */
+    public static final void extendSelection(Spannable text, int index) {
+        if (text.getSpanStart(SELECTION_END) != index)
+            text.setSpan(SELECTION_END, index, index, Spanned.SPAN_POINT_POINT);
+    }
+
+    /**
+     * Remove the selection or cursor, if any, from the text.
+     */
+    public static final void removeSelection(Spannable text) {
+        text.removeSpan(SELECTION_START);
+        text.removeSpan(SELECTION_END);
+    }
+
+    /*
+     * Moving the selection within the layout
+     */
+
+//    /**
+//     * Move the cursor to the buffer offset physically above the current
+//     * offset, or return false if the cursor is already on the top line.
+//     */
+//    public static boolean moveUp(Spannable text, Layout layout) {
+//        int start = getSelectionStart(text);
+//        int end = getSelectionEnd(text);
+//
+//        if (start != end) {
+//            int min = Math.min(start, end);
+//            int max = Math.max(start, end);
+//
+//            setSelection(text, min);
+//
+//            if (min == 0 && max == text.length()) {
+//                return false;
+//            }
+//
+//            return true;
+//        } else {
+//            int line = layout.getLineForOffset(end);
+//
+//            if (line > 0) {
+//                int move;
+//
+//                if (layout.getParagraphDirection(line) ==
+//                    layout.getParagraphDirection(line - 1)) {
+//                    float h = layout.getPrimaryHorizontal(end);
+//                    move = layout.getOffsetForHorizontal(line - 1, h);
+//                } else {
+//                    move = layout.getLineStart(line - 1);
+//                }
+//
+//                setSelection(text, move);
+//                return true;
+//            }
+//        }
+//
+//        return false;
+//    }
+//
+//    /**
+//     * Move the cursor to the buffer offset physically below the current
+//     * offset, or return false if the cursor is already on the bottom line.
+//     */
+//    public static boolean moveDown(Spannable text, Layout layout) {
+//        int start = getSelectionStart(text);
+//        int end = getSelectionEnd(text);
+//
+//        if (start != end) {
+//            int min = Math.min(start, end);
+//            int max = Math.max(start, end);
+//
+//            setSelection(text, max);
+//
+//            if (min == 0 && max == text.length()) {
+//                return false;
+//            }
+//
+//            return true;
+//        } else {
+//            int line = layout.getLineForOffset(end);
+//
+//            if (line < layout.getLineCount() - 1) {
+//                int move;
+//
+//                if (layout.getParagraphDirection(line) ==
+//                    layout.getParagraphDirection(line + 1)) {
+//                    float h = layout.getPrimaryHorizontal(end);
+//                    move = layout.getOffsetForHorizontal(line + 1, h);
+//                } else {
+//                    move = layout.getLineStart(line + 1);
+//                }
+//
+//                setSelection(text, move);
+//                return true;
+//            }
+//        }
+//
+//        return false;
+//    }
+//
+//    /**
+//     * Move the cursor to the buffer offset physically to the left of
+//     * the current offset, or return false if the cursor is already
+//     * at the left edge of the line and there is not another line to move it to.
+//     */
+//    public static boolean moveLeft(Spannable text, Layout layout) {
+//        int start = getSelectionStart(text);
+//        int end = getSelectionEnd(text);
+//
+//        if (start != end) {
+//            setSelection(text, chooseHorizontal(layout, -1, start, end));
+//            return true;
+//        } else {
+//            int to = layout.getOffsetToLeftOf(end);
+//
+//            if (to != end) {
+//                setSelection(text, to);
+//                return true;
+//            }
+//        }
+//
+//        return false;
+//    }
+//
+//    /**
+//     * Move the cursor to the buffer offset physically to the right of
+//     * the current offset, or return false if the cursor is already at
+//     * at the right edge of the line and there is not another line
+//     * to move it to.
+//     */
+//    public static boolean moveRight(Spannable text, Layout layout) {
+//        int start = getSelectionStart(text);
+//        int end = getSelectionEnd(text);
+//
+//        if (start != end) {
+//            setSelection(text, chooseHorizontal(layout, 1, start, end));
+//            return true;
+//        } else {
+//            int to = layout.getOffsetToRightOf(end);
+//
+//            if (to != end) {
+//                setSelection(text, to);
+//                return true;
+//            }
+//        }
+//
+//        return false;
+//    }
+//
+//    /**
+//     * Move the selection end to the buffer offset physically above
+//     * the current selection end.
+//     */
+//    public static boolean extendUp(Spannable text, Layout layout) {
+//        int end = getSelectionEnd(text);
+//        int line = layout.getLineForOffset(end);
+//
+//        if (line > 0) {
+//            int move;
+//
+//            if (layout.getParagraphDirection(line) ==
+//                layout.getParagraphDirection(line - 1)) {
+//                float h = layout.getPrimaryHorizontal(end);
+//                move = layout.getOffsetForHorizontal(line - 1, h);
+//            } else {
+//                move = layout.getLineStart(line - 1);
+//            }
+//
+//            extendSelection(text, move);
+//            return true;
+//        } else if (end != 0) {
+//            extendSelection(text, 0);
+//            return true;
+//        }
+//
+//        return true;
+//    }
+//
+//    /**
+//     * Move the selection end to the buffer offset physically below
+//     * the current selection end.
+//     */
+//    public static boolean extendDown(Spannable text, Layout layout) {
+//        int end = getSelectionEnd(text);
+//        int line = layout.getLineForOffset(end);
+//
+//        if (line < layout.getLineCount() - 1) {
+//            int move;
+//
+//            if (layout.getParagraphDirection(line) ==
+//                layout.getParagraphDirection(line + 1)) {
+//                float h = layout.getPrimaryHorizontal(end);
+//                move = layout.getOffsetForHorizontal(line + 1, h);
+//            } else {
+//                move = layout.getLineStart(line + 1);
+//            }
+//
+//            extendSelection(text, move);
+//            return true;
+//        } else if (end != text.length()) {
+//            extendSelection(text, text.length());
+//            return true;
+//        }
+//
+//        return true;
+//    }
+//
+//    /**
+//     * Move the selection end to the buffer offset physically to the left of
+//     * the current selection end.
+//     */
+//    public static boolean extendLeft(Spannable text, Layout layout) {
+//        int end = getSelectionEnd(text);
+//        int to = layout.getOffsetToLeftOf(end);
+//
+//        if (to != end) {
+//            extendSelection(text, to);
+//            return true;
+//        }
+//
+//        return true;
+//    }
+//
+//    /**
+//     * Move the selection end to the buffer offset physically to the right of
+//     * the current selection end.
+//     */
+//    public static boolean extendRight(Spannable text, Layout layout) {
+//        int end = getSelectionEnd(text);
+//        int to = layout.getOffsetToRightOf(end);
+//
+//        if (to != end) {
+//            extendSelection(text, to);
+//            return true;
+//        }
+//
+//        return true;
+//    }
+//
+//    public static boolean extendToLeftEdge(Spannable text, Layout layout) {
+//        int where = findEdge(text, layout, -1);
+//        extendSelection(text, where);
+//        return true;
+//    }
+//
+//    public static boolean extendToRightEdge(Spannable text, Layout layout) {
+//        int where = findEdge(text, layout, 1);
+//        extendSelection(text, where);
+//        return true;
+//    }
+//
+//    public static boolean moveToLeftEdge(Spannable text, Layout layout) {
+//        int where = findEdge(text, layout, -1);
+//        setSelection(text, where);
+//        return true;
+//    }
+//
+//    public static boolean moveToRightEdge(Spannable text, Layout layout) {
+//        int where = findEdge(text, layout, 1);
+//        setSelection(text, where);
+//        return true;
+//    }
+//
+//    private static int findEdge(Spannable text, Layout layout, int dir) {
+//        int pt = getSelectionEnd(text);
+//        int line = layout.getLineForOffset(pt);
+//        int pdir = layout.getParagraphDirection(line);
+//
+//        if (dir * pdir < 0) {
+//            return layout.getLineStart(line);
+//        } else {
+//            int end = layout.getLineEnd(line);
+//
+//            if (line == layout.getLineCount() - 1)
+//                return end;
+//            else
+//                return end - 1;
+//        }
+//    }
+//
+//    private static int chooseHorizontal(Layout layout, int direction,
+//                                        int off1, int off2) {
+//        int line1 = layout.getLineForOffset(off1);
+//        int line2 = layout.getLineForOffset(off2);
+//
+//        if (line1 == line2) {
+//            // same line, so it goes by pure physical direction
+//
+//            float h1 = layout.getPrimaryHorizontal(off1);
+//            float h2 = layout.getPrimaryHorizontal(off2);
+//
+//            if (direction < 0) {
+//                // to left
+//
+//                if (h1 < h2)
+//                    return off1;
+//                else
+//                    return off2;
+//            } else {
+//                // to right
+//
+//                if (h1 > h2)
+//                    return off1;
+//                else
+//                    return off2;
+//            }
+//        } else {
+//            // different line, so which line is "left" and which is "right"
+//            // depends upon the directionality of the text
+//
+//            // This only checks at one end, but it's not clear what the
+//            // right thing to do is if the ends don't agree.  Even if it
+//            // is wrong it should still not be too bad.
+//            int line = layout.getLineForOffset(off1);
+//            int textdir = layout.getParagraphDirection(line);
+//
+//            if (textdir == direction)
+//                return Math.max(off1, off2);
+//            else
+//                return Math.min(off1, off2);
+//        }
+//    }
+
+    private static final class START implements NoCopySpan { };
+    private static final class END implements NoCopySpan { };
+    
+    /*
+     * Public constants
+     */
+
+    public static final Object SELECTION_START = new START();
+    public static final Object SELECTION_END = new END();
+}
diff --git a/src/com/transage/privatespace/vcard/text/SpanWatcher.java b/src/com/transage/privatespace/vcard/text/SpanWatcher.java
new file mode 100755
index 0000000..5ac5b5e
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/SpanWatcher.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * When an object of this type is attached to a Spannable, its methods
+ * will be called to notify it that other markup objects have been
+ * added, changed, or removed.
+ */
+public interface SpanWatcher extends NoCopySpan {
+    /**
+     * This method is called to notify you that the specified object
+     * has been attached to the specified range of the text.
+     */
+    public void onSpanAdded(Spannable text, Object what, int start, int end);
+    /**
+     * This method is called to notify you that the specified object
+     * has been detached from the specified range of the text.
+     */
+    public void onSpanRemoved(Spannable text, Object what, int start, int end); 
+    /**
+     * This method is called to notify you that the specified object
+     * has been relocated from the range <code>ostart&hellip;oend</code>
+     * to the new range <code>nstart&hellip;nend</code> of the text.
+     */
+    public void onSpanChanged(Spannable text, Object what, int ostart, int oend,
+                              int nstart, int nend);
+}
diff --git a/src/com/transage/privatespace/vcard/text/Spannable.java b/src/com/transage/privatespace/vcard/text/Spannable.java
new file mode 100755
index 0000000..a7ecf7f
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/Spannable.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * This is the interface for text to which markup objects can be
+ * attached and detached.  Not all Spannable classes have mutable text;
+ * see {@link Editable} for that.
+ */
+public interface Spannable
+extends Spanned
+{
+    /**
+     * Attach the specified markup object to the range <code>start&hellip;end</code>
+     * of the text, or move the object to that range if it was already
+     * attached elsewhere.  See {@link Spanned} for an explanation of
+     * what the flags mean.  The object can be one that has meaning only
+     * within your application, or it can be one that the text system will
+     * use to affect text display or behavior.  Some noteworthy ones are
+     * the subclasses of {@link android.text.style.CharacterStyle} and
+     * {@link android.text.style.ParagraphStyle}, and
+     * {@link android.text.TextWatcher} and
+     * {@link android.text.SpanWatcher}.
+     */
+    public void setSpan(Object what, int start, int end, int flags);
+
+    /**
+     * Remove the specified object from the range of text to which it
+     * was attached, if any.  It is OK to remove an object that was never
+     * attached in the first place.
+     */
+    public void removeSpan(Object what);
+
+//    /**
+//     * Factory used by TextView to create new Spannables.  You can subclass
+//     * it to provide something other than SpannableString.
+//     */
+//    public static class Factory {
+//        private static Spannable.Factory sInstance = new Spannable.Factory();
+//
+//        /**
+//         * Returns the standard Spannable Factory.
+//         */
+//        public static Spannable.Factory getInstance() {
+//            return sInstance;
+//        }
+//
+//        /**
+//         * Returns a new SpannableString from the specified CharSequence.
+//         * You can override this to provide a different kind of Spannable.
+//         */
+//        public Spannable newSpannable(CharSequence source) {
+//            return new SpannableString(source);
+//        }
+//    }
+}
diff --git a/src/com/transage/privatespace/vcard/text/SpannableStringBuilder.java b/src/com/transage/privatespace/vcard/text/SpannableStringBuilder.java
new file mode 100755
index 0000000..6a2aa7c
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/SpannableStringBuilder.java
@@ -0,0 +1,1140 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+import com.transage.privatespace.vcard.util.ArrayUtils;
+//import android.graphics.Paint;
+//import android.graphics.Canvas;
+
+import java.lang.reflect.Array;
+
+/**
+ * This is the class for text whose content and markup can both be changed.
+ */
+public class SpannableStringBuilder
+implements /*CharSequence, GetChars,*/ Spannable, Editable//, Appendable,
+//           GraphicsOperations
+{
+    /**
+     * Create a new SpannableStringBuilder with empty contents
+     */
+    public SpannableStringBuilder() {
+        this("");
+    }
+
+    /**
+     * Create a new SpannableStringBuilder containing a copy of the
+     * specified text, including its spans if any.
+     */
+    public SpannableStringBuilder(CharSequence text) {
+        this(text, 0, text.length());
+    }
+
+    /**
+     * Create a new SpannableStringBuilder containing a copy of the
+     * specified slice of the specified text, including its spans if any.
+     */
+    public SpannableStringBuilder(CharSequence text, int start, int end) {
+        int srclen = end - start;
+
+        int len = ArrayUtils.idealCharArraySize(srclen + 1);
+        mText = new char[len];
+        mGapStart = srclen;
+        mGapLength = len - srclen;
+
+        TextUtils.getChars(text, start, end, mText, 0);
+
+        mSpanCount = 0;
+        int alloc = ArrayUtils.idealIntArraySize(0);
+        mSpans = new Object[alloc];
+        mSpanStarts = new int[alloc];
+        mSpanEnds = new int[alloc];
+        mSpanFlags = new int[alloc];
+
+        if (text instanceof Spanned) {
+            Spanned sp = (Spanned) text;
+            Object[] spans = sp.getSpans(start, end, Object.class);
+
+            for (int i = 0; i < spans.length; i++) {
+                if (spans[i] instanceof NoCopySpan) {
+                    continue;
+                }
+                
+                int st = sp.getSpanStart(spans[i]) - start;
+                int en = sp.getSpanEnd(spans[i]) - start;
+                int fl = sp.getSpanFlags(spans[i]);
+
+                if (st < 0)
+                    st = 0;
+                if (st > end - start)
+                    st = end - start;
+
+                if (en < 0)
+                    en = 0;
+                if (en > end - start)
+                    en = end - start;
+
+                setSpan(spans[i], st, en, fl);
+            }
+        }
+    }
+
+    public static SpannableStringBuilder valueOf(CharSequence source) {
+        if (source instanceof SpannableStringBuilder) {
+            return (SpannableStringBuilder) source;
+        } else {
+            return new SpannableStringBuilder(source);
+        }
+    }
+
+    /**
+     * Return the char at the specified offset within the buffer.
+     */
+    public char charAt(int where) {
+        int len = length();
+        if (where < 0) {
+            throw new IndexOutOfBoundsException("charAt: " + where + " < 0");
+        } else if (where >= len) {
+            throw new IndexOutOfBoundsException("charAt: " + where +
+                                                " >= length " + len);
+        }
+
+        if (where >= mGapStart)
+            return mText[where + mGapLength];
+        else
+            return mText[where];
+    }
+
+    /**
+     * Return the number of chars in the buffer.
+     */
+    public int length() {
+        return mText.length - mGapLength;
+    }
+
+    private void resizeFor(int size) {
+        int newlen = ArrayUtils.idealCharArraySize(size + 1);
+        char[] newtext = new char[newlen];
+
+        int after = mText.length - (mGapStart + mGapLength);
+
+        System.arraycopy(mText, 0, newtext, 0, mGapStart);
+        System.arraycopy(mText, mText.length - after,
+                         newtext, newlen - after, after);
+
+        for (int i = 0; i < mSpanCount; i++) {
+            if (mSpanStarts[i] > mGapStart)
+                mSpanStarts[i] += newlen - mText.length;
+            if (mSpanEnds[i] > mGapStart)
+                mSpanEnds[i] += newlen - mText.length;
+        }
+
+        int oldlen = mText.length;
+        mText = newtext;
+        mGapLength += mText.length - oldlen;
+
+        if (mGapLength < 1)
+            new Exception("mGapLength < 1").printStackTrace();
+    }
+
+    private void moveGapTo(int where) {
+        if (where == mGapStart)
+            return;
+
+        boolean atend = (where == length());
+
+        if (where < mGapStart) {
+            int overlap = mGapStart - where;
+
+            System.arraycopy(mText, where,
+                             mText, mGapStart + mGapLength - overlap, overlap);
+        } else /* where > mGapStart */ {
+            int overlap = where - mGapStart;
+
+            System.arraycopy(mText, where + mGapLength - overlap,
+                             mText, mGapStart, overlap);
+        }
+
+        // XXX be more clever
+        for (int i = 0; i < mSpanCount; i++) {
+            int start = mSpanStarts[i];
+            int end = mSpanEnds[i];
+
+            if (start > mGapStart)
+                start -= mGapLength;
+            if (start > where)
+                start += mGapLength;
+            else if (start == where) {
+                int flag = (mSpanFlags[i] & START_MASK) >> START_SHIFT;
+
+                if (flag == POINT || (atend && flag == PARAGRAPH))
+                    start += mGapLength;
+            }
+
+            if (end > mGapStart)
+                end -= mGapLength;
+            if (end > where)
+                end += mGapLength;
+            else if (end == where) {
+                int flag = (mSpanFlags[i] & END_MASK);
+
+                if (flag == POINT || (atend && flag == PARAGRAPH))
+                    end += mGapLength;
+            }
+
+            mSpanStarts[i] = start;
+            mSpanEnds[i] = end;
+        }
+
+        mGapStart = where;
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder insert(int where, CharSequence tb, int start, int end) {
+        return replace(where, where, tb, start, end);
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder insert(int where, CharSequence tb) {
+        return replace(where, where, tb, 0, tb.length());
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder delete(int start, int end) {
+        SpannableStringBuilder ret = replace(start, end, "", 0, 0);
+
+        if (mGapLength > 2 * length())
+            resizeFor(length());
+
+        return ret; // == this
+    }
+
+    // Documentation from interface
+    public void clear() {
+        replace(0, length(), "", 0, 0);
+    }
+
+    // Documentation from interface
+    public void clearSpans() {
+        for (int i = mSpanCount - 1; i >= 0; i--) {
+            Object what = mSpans[i];
+            int ostart = mSpanStarts[i];
+            int oend = mSpanEnds[i];
+
+            if (ostart > mGapStart)
+                ostart -= mGapLength;
+            if (oend > mGapStart)
+                oend -= mGapLength;
+
+            mSpanCount = i;
+            mSpans[i] = null;
+
+            sendSpanRemoved(what, ostart, oend);
+        }
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder append(CharSequence text) {
+        int length = length();
+        return replace(length, length, text, 0, text.length());
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder append(CharSequence text, int start, int end) {
+        int length = length();
+        return replace(length, length, text, start, end);
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder append(char text) {
+        return append(String.valueOf(text));
+    }
+
+    private int change(int start, int end,
+                       CharSequence tb, int tbstart, int tbend) {
+        return change(true, start, end, tb, tbstart, tbend);
+    }
+
+    private int change(boolean notify, int start, int end,
+                       CharSequence tb, int tbstart, int tbend) {
+        checkRange("replace", start, end);
+        int ret = tbend - tbstart;
+        TextWatcher[] recipients = null;
+
+        if (notify)
+            recipients = sendTextWillChange(start, end - start,
+                                            tbend - tbstart);
+
+        for (int i = mSpanCount - 1; i >= 0; i--) {
+            if ((mSpanFlags[i] & SPAN_PARAGRAPH) == SPAN_PARAGRAPH) {
+                int st = mSpanStarts[i];
+                if (st > mGapStart)
+                    st -= mGapLength;
+
+                int en = mSpanEnds[i];
+                if (en > mGapStart)
+                    en -= mGapLength;
+
+                int ost = st;
+                int oen = en;
+                int clen = length();
+
+                if (st > start && st <= end) {
+                    for (st = end; st < clen; st++)
+                        if (st > end && charAt(st - 1) == '\n')
+                            break;
+                }
+
+                if (en > start && en <= end) {
+                    for (en = end; en < clen; en++)
+                        if (en > end && charAt(en - 1) == '\n')
+                            break;
+                }
+
+                if (st != ost || en != oen)
+                    setSpan(mSpans[i], st, en, mSpanFlags[i]);
+            }
+        }
+
+        moveGapTo(end);
+
+        if (tbend - tbstart >= mGapLength + (end - start))
+            resizeFor(mText.length - mGapLength +
+                      tbend - tbstart - (end - start));
+
+        mGapStart += tbend - tbstart - (end - start);
+        mGapLength -= tbend - tbstart - (end - start);
+
+        if (mGapLength < 1)
+            new Exception("mGapLength < 1").printStackTrace();
+
+        TextUtils.getChars(tb, tbstart, tbend, mText, start);
+
+        if (tb instanceof Spanned) {
+            Spanned sp = (Spanned) tb;
+            Object[] spans = sp.getSpans(tbstart, tbend, Object.class);
+
+            for (int i = 0; i < spans.length; i++) {
+                int st = sp.getSpanStart(spans[i]);
+                int en = sp.getSpanEnd(spans[i]);
+
+                if (st < tbstart)
+                    st = tbstart;
+                if (en > tbend)
+                    en = tbend;
+
+                if (getSpanStart(spans[i]) < 0) {
+                    setSpan(false, spans[i],
+                            st - tbstart + start,
+                            en - tbstart + start,
+                            sp.getSpanFlags(spans[i]));
+                }
+            }
+        }
+
+        // no need for span fixup on pure insertion
+        if (tbend > tbstart && end - start == 0) {
+            if (notify) {
+                sendTextChange(recipients, start, end - start, tbend - tbstart);
+                sendTextHasChanged(recipients);
+            }
+
+            return ret;
+        }
+
+        boolean atend = (mGapStart + mGapLength == mText.length);
+
+        for (int i = mSpanCount - 1; i >= 0; i--) {
+            if (mSpanStarts[i] >= start &&
+                mSpanStarts[i] < mGapStart + mGapLength) {
+                int flag = (mSpanFlags[i] & START_MASK) >> START_SHIFT;
+
+                if (flag == POINT || (flag == PARAGRAPH && atend))
+                    mSpanStarts[i] = mGapStart + mGapLength;
+                else
+                    mSpanStarts[i] = start;
+            }
+
+            if (mSpanEnds[i] >= start &&
+                mSpanEnds[i] < mGapStart + mGapLength) {
+                int flag = (mSpanFlags[i] & END_MASK);
+
+                if (flag == POINT || (flag == PARAGRAPH && atend))
+                    mSpanEnds[i] = mGapStart + mGapLength;
+                else
+                    mSpanEnds[i] = start;
+            }
+
+            // remove 0-length SPAN_EXCLUSIVE_EXCLUSIVE
+            // XXX send notification on removal
+
+            if (mSpanEnds[i] < mSpanStarts[i]) {
+                System.arraycopy(mSpans, i + 1,
+                                 mSpans, i, mSpanCount - (i + 1));
+                System.arraycopy(mSpanStarts, i + 1,
+                                 mSpanStarts, i, mSpanCount - (i + 1));
+                System.arraycopy(mSpanEnds, i + 1,
+                                 mSpanEnds, i, mSpanCount - (i + 1));
+                System.arraycopy(mSpanFlags, i + 1,
+                                 mSpanFlags, i, mSpanCount - (i + 1));
+
+                mSpanCount--;
+            }
+        }
+
+        if (notify) {
+            sendTextChange(recipients, start, end - start, tbend - tbstart);
+            sendTextHasChanged(recipients);
+        }
+
+        return ret;
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder replace(int start, int end, CharSequence tb) {
+        return replace(start, end, tb, 0, tb.length());
+    }
+
+    // Documentation from interface
+    public SpannableStringBuilder replace(final int start, final int end,
+                        CharSequence tb, int tbstart, int tbend) {
+        int filtercount = mFilters.length;
+        for (int i = 0; i < filtercount; i++) {
+            CharSequence repl = mFilters[i].filter(tb, tbstart, tbend,
+                                                   this, start, end);
+
+            if (repl != null) {
+                tb = repl;
+                tbstart = 0;
+                tbend = repl.length();
+            }
+        }
+
+        if (end == start && tbstart == tbend) {
+            return this;
+        }
+
+        if (end == start || tbstart == tbend) {
+            change(start, end, tb, tbstart, tbend);
+        } else {
+            int selstart = Selection.getSelectionStart(this);
+            int selend = Selection.getSelectionEnd(this);
+
+            // XXX just make the span fixups in change() do the right thing
+            // instead of this madness!
+
+            checkRange("replace", start, end);
+            moveGapTo(end);
+            TextWatcher[] recipients;
+
+            recipients = sendTextWillChange(start, end - start,
+                                            tbend - tbstart);
+
+            int origlen = end - start;
+
+            if (mGapLength < 2)
+                resizeFor(length() + 1);
+
+            for (int i = mSpanCount - 1; i >= 0; i--) {
+                if (mSpanStarts[i] == mGapStart)
+                    mSpanStarts[i]++;
+
+                if (mSpanEnds[i] == mGapStart)
+                    mSpanEnds[i]++;
+            }
+
+            mText[mGapStart] = ' ';
+            mGapStart++;
+            mGapLength--;
+
+            if (mGapLength < 1)
+                new Exception("mGapLength < 1").printStackTrace();
+
+            int oldlen = (end + 1) - start;
+
+            int inserted = change(false, start + 1, start + 1,
+                                  tb, tbstart, tbend);
+            change(false, start, start + 1, "", 0, 0);
+            change(false, start + inserted, start + inserted + oldlen - 1,
+                   "", 0, 0);
+
+            /*
+             * Special case to keep the cursor in the same position
+             * if it was somewhere in the middle of the replaced region.
+             * If it was at the start or the end or crossing the whole
+             * replacement, it should already be where it belongs.
+             * TODO: Is there some more general mechanism that could
+             * accomplish this?
+             */
+            if (selstart > start && selstart < end) {
+                long off = selstart - start;
+
+                off = off * inserted / (end - start);
+                selstart = (int) off + start;
+
+                setSpan(false, Selection.SELECTION_START, selstart, selstart,
+                        Spanned.SPAN_POINT_POINT);
+            }
+            if (selend > start && selend < end) {
+                long off = selend - start;
+
+                off = off * inserted / (end - start);
+                selend = (int) off + start;
+
+                setSpan(false, Selection.SELECTION_END, selend, selend,
+                        Spanned.SPAN_POINT_POINT);
+            }
+
+            sendTextChange(recipients, start, origlen, inserted);
+            sendTextHasChanged(recipients);
+        }
+        return this;
+    }
+
+    /**
+     * Mark the specified range of text with the specified object.
+     * The flags determine how the span will behave when text is
+     * inserted at the start or end of the span's range.
+     */
+    public void setSpan(Object what, int start, int end, int flags) {
+        setSpan(true, what, start, end, flags);
+    }
+
+    private void setSpan(boolean send,
+                         Object what, int start, int end, int flags) {
+        int nstart = start;
+        int nend = end;
+
+        checkRange("setSpan", start, end);
+
+        if ((flags & START_MASK) == (PARAGRAPH << START_SHIFT)) {
+            if (start != 0 && start != length()) {
+                char c = charAt(start - 1);
+
+                if (c != '\n')
+                    throw new RuntimeException(
+                            "PARAGRAPH span must start at paragraph boundary");
+            }
+        }
+
+        if ((flags & END_MASK) == PARAGRAPH) {
+            if (end != 0 && end != length()) {
+                char c = charAt(end - 1);
+
+                if (c != '\n')
+                    throw new RuntimeException(
+                            "PARAGRAPH span must end at paragraph boundary");
+            }
+        }
+
+        if (start > mGapStart)
+            start += mGapLength;
+        else if (start == mGapStart) {
+            int flag = (flags & START_MASK) >> START_SHIFT;
+
+            if (flag == POINT || (flag == PARAGRAPH && start == length()))
+                start += mGapLength;
+        }
+
+        if (end > mGapStart)
+            end += mGapLength;
+        else if (end == mGapStart) {
+            int flag = (flags & END_MASK);
+
+            if (flag == POINT || (flag == PARAGRAPH && end == length()))
+                end += mGapLength;
+        }
+
+        int count = mSpanCount;
+        Object[] spans = mSpans;
+
+        for (int i = 0; i < count; i++) {
+            if (spans[i] == what) {
+                int ostart = mSpanStarts[i];
+                int oend = mSpanEnds[i];
+
+                if (ostart > mGapStart)
+                    ostart -= mGapLength;
+                if (oend > mGapStart)
+                    oend -= mGapLength;
+
+                mSpanStarts[i] = start;
+                mSpanEnds[i] = end;
+                mSpanFlags[i] = flags;
+
+                if (send)
+                    sendSpanChanged(what, ostart, oend, nstart, nend);
+
+                return;
+            }
+        }
+
+        if (mSpanCount + 1 >= mSpans.length) {
+            int newsize = ArrayUtils.idealIntArraySize(mSpanCount + 1);
+            Object[] newspans = new Object[newsize];
+            int[] newspanstarts = new int[newsize];
+            int[] newspanends = new int[newsize];
+            int[] newspanflags = new int[newsize];
+
+            System.arraycopy(mSpans, 0, newspans, 0, mSpanCount);
+            System.arraycopy(mSpanStarts, 0, newspanstarts, 0, mSpanCount);
+            System.arraycopy(mSpanEnds, 0, newspanends, 0, mSpanCount);
+            System.arraycopy(mSpanFlags, 0, newspanflags, 0, mSpanCount);
+
+            mSpans = newspans;
+            mSpanStarts = newspanstarts;
+            mSpanEnds = newspanends;
+            mSpanFlags = newspanflags;
+        }
+
+        mSpans[mSpanCount] = what;
+        mSpanStarts[mSpanCount] = start;
+        mSpanEnds[mSpanCount] = end;
+        mSpanFlags[mSpanCount] = flags;
+        mSpanCount++;
+
+        if (send)
+            sendSpanAdded(what, nstart, nend);
+    }
+
+    /**
+     * Remove the specified markup object from the buffer.
+     */
+    public void removeSpan(Object what) {
+        for (int i = mSpanCount - 1; i >= 0; i--) {
+            if (mSpans[i] == what) {
+                int ostart = mSpanStarts[i];
+                int oend = mSpanEnds[i];
+
+                if (ostart > mGapStart)
+                    ostart -= mGapLength;
+                if (oend > mGapStart)
+                    oend -= mGapLength;
+
+                int count = mSpanCount - (i + 1);
+
+                System.arraycopy(mSpans, i + 1, mSpans, i, count);
+                System.arraycopy(mSpanStarts, i + 1, mSpanStarts, i, count);
+                System.arraycopy(mSpanEnds, i + 1, mSpanEnds, i, count);
+                System.arraycopy(mSpanFlags, i + 1, mSpanFlags, i, count);
+
+                mSpanCount--;
+                mSpans[mSpanCount] = null;
+
+                sendSpanRemoved(what, ostart, oend);
+                return;
+            }
+        }
+    }
+
+    /**
+     * Return the buffer offset of the beginning of the specified
+     * markup object, or -1 if it is not attached to this buffer.
+     */
+    public int getSpanStart(Object what) {
+        int count = mSpanCount;
+        Object[] spans = mSpans;
+
+        for (int i = count - 1; i >= 0; i--) {
+            if (spans[i] == what) {
+                int where = mSpanStarts[i];
+
+                if (where > mGapStart)
+                    where -= mGapLength;
+
+                return where;
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * Return the buffer offset of the end of the specified
+     * markup object, or -1 if it is not attached to this buffer.
+     */
+    public int getSpanEnd(Object what) {
+        int count = mSpanCount;
+        Object[] spans = mSpans;
+
+        for (int i = count - 1; i >= 0; i--) {
+            if (spans[i] == what) {
+                int where = mSpanEnds[i];
+
+                if (where > mGapStart)
+                    where -= mGapLength;
+
+                return where;
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * Return the flags of the end of the specified
+     * markup object, or 0 if it is not attached to this buffer.
+     */
+    public int getSpanFlags(Object what) {
+        int count = mSpanCount;
+        Object[] spans = mSpans;
+
+        for (int i = count - 1; i >= 0; i--) {
+            if (spans[i] == what) {
+                return mSpanFlags[i];
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Return an array of the spans of the specified type that overlap
+     * the specified range of the buffer.  The kind may be Object.class to get
+     * a list of all the spans regardless of type.
+     */
+    public <T> T[] getSpans(int queryStart, int queryEnd, Class<T> kind) {
+        int spanCount = mSpanCount;
+        Object[] spans = mSpans;
+        int[] starts = mSpanStarts;
+        int[] ends = mSpanEnds;
+        int[] flags = mSpanFlags;
+        int gapstart = mGapStart;
+        int gaplen = mGapLength;
+
+        int count = 0;
+        Object[] ret = null;
+        Object ret1 = null;
+
+        for (int i = 0; i < spanCount; i++) {
+            int spanStart = starts[i];
+            int spanEnd = ends[i];
+
+            if (spanStart > gapstart) {
+                spanStart -= gaplen;
+            }
+            if (spanEnd > gapstart) {
+                spanEnd -= gaplen;
+            }
+
+            if (spanStart > queryEnd) {
+                continue;
+            }
+            if (spanEnd < queryStart) {
+                continue;
+            }
+
+            if (spanStart != spanEnd && queryStart != queryEnd) {
+                if (spanStart == queryEnd)
+                    continue;
+                if (spanEnd == queryStart)
+                    continue;
+            }
+
+            if (kind != null && !kind.isInstance(spans[i])) {
+                continue;
+            }
+
+            if (count == 0) {
+                ret1 = spans[i];
+                count++;
+            } else {
+                if (count == 1) {
+                    ret = (Object[]) Array.newInstance(kind, spanCount - i + 1);
+                    ret[0] = ret1;
+                }
+
+                int prio = flags[i] & SPAN_PRIORITY;
+                if (prio != 0) {
+                    int j;
+
+                    for (j = 0; j < count; j++) {
+                        int p = getSpanFlags(ret[j]) & SPAN_PRIORITY;
+
+                        if (prio > p) {
+                            break;
+                        }
+                    }
+
+                    System.arraycopy(ret, j, ret, j + 1, count - j);
+                    ret[j] = spans[i];
+                    count++;
+                } else {
+                    ret[count++] = spans[i];
+                }
+            }
+        }
+
+        if (count == 0) {
+            return (T[]) ArrayUtils.emptyArray(kind);
+        }
+        if (count == 1) {
+            ret = (Object[]) Array.newInstance(kind, 1);
+            ret[0] = ret1;
+            return (T[]) ret;
+        }
+        if (count == ret.length) {
+            return (T[]) ret;
+        }
+
+        Object[] nret = (Object[]) Array.newInstance(kind, count);
+        System.arraycopy(ret, 0, nret, 0, count);
+        return (T[]) nret;
+    }
+
+    /**
+     * Return the next offset after <code>start</code> but less than or
+     * equal to <code>limit</code> where a span of the specified type
+     * begins or ends.
+     */
+    public int nextSpanTransition(int start, int limit, Class kind) {
+        int count = mSpanCount;
+        Object[] spans = mSpans;
+        int[] starts = mSpanStarts;
+        int[] ends = mSpanEnds;
+        int gapstart = mGapStart;
+        int gaplen = mGapLength;
+
+        if (kind == null) {
+            kind = Object.class;
+        }
+
+        for (int i = 0; i < count; i++) {
+            int st = starts[i];
+            int en = ends[i];
+
+            if (st > gapstart)
+                st -= gaplen;
+            if (en > gapstart)
+                en -= gaplen;
+
+            if (st > start && st < limit && kind.isInstance(spans[i]))
+                limit = st;
+            if (en > start && en < limit && kind.isInstance(spans[i]))
+                limit = en;
+        }
+
+        return limit;
+    }
+
+    /**
+     * Return a new CharSequence containing a copy of the specified
+     * range of this buffer, including the overlapping spans.
+     */
+    public CharSequence subSequence(int start, int end) {
+        return new SpannableStringBuilder(this, start, end);
+    }
+
+    /**
+     * Copy the specified range of chars from this buffer into the
+     * specified array, beginning at the specified offset.
+     */
+    public void getChars(int start, int end, char[] dest, int destoff) {
+        checkRange("getChars", start, end);
+
+        if (end <= mGapStart) {
+            System.arraycopy(mText, start, dest, destoff, end - start);
+        } else if (start >= mGapStart) {
+            System.arraycopy(mText, start + mGapLength,
+                             dest, destoff, end - start);
+        } else {
+            System.arraycopy(mText, start, dest, destoff, mGapStart - start);
+            System.arraycopy(mText, mGapStart + mGapLength,
+                             dest, destoff + (mGapStart - start),
+                             end - mGapStart);
+        }
+    }
+
+    /**
+     * Return a String containing a copy of the chars in this buffer.
+     */
+    public String toString() {
+        int len = length();
+        char[] buf = new char[len];
+
+        getChars(0, len, buf, 0);
+        return new String(buf);
+    }
+
+    private TextWatcher[] sendTextWillChange(int start, int before, int after) {
+        TextWatcher[] recip = getSpans(start, start + before, TextWatcher.class);
+        int n = recip.length;
+
+        for (int i = 0; i < n; i++) {
+            recip[i].beforeTextChanged(this, start, before, after);
+        }
+
+        return recip;
+    }
+
+    private void sendTextChange(TextWatcher[] recip, int start, int before,
+                                int after) {
+        int n = recip.length;
+
+        for (int i = 0; i < n; i++) {
+            recip[i].onTextChanged(this, start, before, after);
+        }
+    }
+
+    private void sendTextHasChanged(TextWatcher[] recip) {
+        int n = recip.length;
+
+        for (int i = 0; i < n; i++) {
+            recip[i].afterTextChanged(this);
+        }
+    }
+
+    private void sendSpanAdded(Object what, int start, int end) {
+        SpanWatcher[] recip = getSpans(start, end, SpanWatcher.class);
+        int n = recip.length;
+
+        for (int i = 0; i < n; i++) {
+            recip[i].onSpanAdded(this, what, start, end);
+        }
+    }
+
+    private void sendSpanRemoved(Object what, int start, int end) {
+        SpanWatcher[] recip = getSpans(start, end, SpanWatcher.class);
+        int n = recip.length;
+
+        for (int i = 0; i < n; i++) {
+            recip[i].onSpanRemoved(this, what, start, end);
+        }
+    }
+
+    private void sendSpanChanged(Object what, int s, int e, int st, int en) {
+        SpanWatcher[] recip = getSpans(Math.min(s, st), Math.max(e, en),
+                                  SpanWatcher.class);
+        int n = recip.length;
+
+        for (int i = 0; i < n; i++) {
+            recip[i].onSpanChanged(this, what, s, e, st, en);
+        }
+    }
+
+    private static String region(int start, int end) {
+        return "(" + start + " ... " + end + ")";
+    }
+
+    private void checkRange(final String operation, int start, int end) {
+        if (end < start) {
+            throw new IndexOutOfBoundsException(operation + " " +
+                                                region(start, end) +
+                                                " has end before start");
+        }
+
+        int len = length();
+
+        if (start > len || end > len) {
+            throw new IndexOutOfBoundsException(operation + " " +
+                                                region(start, end) +
+                                                " ends beyond length " + len);
+        }
+
+        if (start < 0 || end < 0) {
+            throw new IndexOutOfBoundsException(operation + " " +
+                                                region(start, end) +
+                                                " starts before 0");
+        }
+    }
+
+    private boolean isprint(char c) { // XXX
+        if (c >= ' ' && c <= '~')
+            return true;
+        else
+            return false;
+    }
+
+/*
+    private static final int startFlag(int flag) {
+        return (flag >> 4) & 0x0F;
+    }
+
+    private static final int endFlag(int flag) {
+        return flag & 0x0F;
+    }
+
+    public void dump() { // XXX
+        for (int i = 0; i < mGapStart; i++) {
+            System.out.print('|');
+            System.out.print(' ');
+            System.out.print(isprint(mText[i]) ? mText[i] : '.');
+            System.out.print(' ');
+        }
+
+        for (int i = mGapStart; i < mGapStart + mGapLength; i++) {
+            System.out.print('|');
+            System.out.print('(');
+            System.out.print(isprint(mText[i]) ? mText[i] : '.');
+            System.out.print(')');
+        }
+
+        for (int i = mGapStart + mGapLength; i < mText.length; i++) {
+            System.out.print('|');
+            System.out.print(' ');
+            System.out.print(isprint(mText[i]) ? mText[i] : '.');
+            System.out.print(' ');
+        }
+
+        System.out.print('\n');
+
+        for (int i = 0; i < mText.length + 1; i++) {
+            int found = 0;
+            int wfound = 0;
+
+            for (int j = 0; j < mSpanCount; j++) {
+                if (mSpanStarts[j] == i) {
+                    found = 1;
+                    wfound = j;
+                    break;
+                }
+
+                if (mSpanEnds[j] == i) {
+                    found = 2;
+                    wfound = j;
+                    break;
+                }
+            }
+
+            if (found == 1) {
+                if (startFlag(mSpanFlags[wfound]) == MARK)
+                    System.out.print("(   ");
+                if (startFlag(mSpanFlags[wfound]) == PARAGRAPH)
+                    System.out.print("<   ");
+                else
+                    System.out.print("[   ");
+            } else if (found == 2) {
+                if (endFlag(mSpanFlags[wfound]) == POINT)
+                    System.out.print(")   ");
+                if (endFlag(mSpanFlags[wfound]) == PARAGRAPH)
+                    System.out.print(">   ");
+                else
+                    System.out.print("]   ");
+            } else {
+                System.out.print("    ");
+            }
+        }
+
+        System.out.print("\n");
+    }
+*/
+//
+//    /**
+//     * Don't call this yourself -- exists for Canvas to use internally.
+//     * {@hide}
+//     */
+//    public void drawText(Canvas c, int start, int end,
+//                         float x, float y, Paint p) {
+//        checkRange("drawText", start, end);
+//
+//        if (end <= mGapStart) {
+//            c.drawText(mText, start, end - start, x, y, p);
+//        } else if (start >= mGapStart) {
+//            c.drawText(mText, start + mGapLength, end - start, x, y, p);
+//        } else {
+//            char[] buf = TextUtils.obtain(end - start);
+//
+//            getChars(start, end, buf, 0);
+//            c.drawText(buf, 0, end - start, x, y, p);
+//            TextUtils.recycle(buf);
+//        }
+//    }
+//
+//    /**
+//     * Don't call this yourself -- exists for Paint to use internally.
+//     * {@hide}
+//     */
+//    public float measureText(int start, int end, Paint p) {
+//        checkRange("measureText", start, end);
+//
+//        float ret;
+//
+//        if (end <= mGapStart) {
+//            ret = p.measureText(mText, start, end - start);
+//        } else if (start >= mGapStart) {
+//            ret = p.measureText(mText, start + mGapLength, end - start);
+//        } else {
+//            char[] buf = TextUtils.obtain(end - start);
+//
+//            getChars(start, end, buf, 0);
+//            ret = p.measureText(buf, 0, end - start);
+//            TextUtils.recycle(buf);
+//        }
+//
+//        return ret;
+//    }
+//
+//    /**
+//     * Don't call this yourself -- exists for Paint to use internally.
+//     * {@hide}
+//     */
+//    public int getTextWidths(int start, int end, float[] widths, Paint p) {
+//        checkRange("getTextWidths", start, end);
+//
+//        int ret;
+//
+//        if (end <= mGapStart) {
+//            ret = p.getTextWidths(mText, start, end - start, widths);
+//        } else if (start >= mGapStart) {
+//            ret = p.getTextWidths(mText, start + mGapLength, end - start,
+//                                  widths);
+//        } else {
+//            char[] buf = TextUtils.obtain(end - start);
+//
+//            getChars(start, end, buf, 0);
+//            ret = p.getTextWidths(buf, 0, end - start, widths);
+//            TextUtils.recycle(buf);
+//        }
+//
+//        return ret;
+//    }
+//
+    // Documentation from interface
+    public void setFilters(InputFilter[] filters) {
+        if (filters == null) {
+            throw new IllegalArgumentException();
+        }
+
+        mFilters = filters;
+    }
+
+    // Documentation from interface
+    public InputFilter[] getFilters() {
+        return mFilters;
+    }
+
+    private static final InputFilter[] NO_FILTERS = new InputFilter[0];
+    private InputFilter[] mFilters = NO_FILTERS;
+
+    private char[] mText;
+    private int mGapStart;
+    private int mGapLength;
+
+    private Object[] mSpans;
+    private int[] mSpanStarts;
+    private int[] mSpanEnds;
+    private int[] mSpanFlags;
+    private int mSpanCount;
+
+    private static final int MARK = 1;
+    private static final int POINT = 2;
+    private static final int PARAGRAPH = 3;
+
+    private static final int START_MASK = 0xF0;
+    private static final int END_MASK = 0x0F;
+    private static final int START_SHIFT = 4;
+}
diff --git a/src/com/transage/privatespace/vcard/text/Spanned.java b/src/com/transage/privatespace/vcard/text/Spanned.java
new file mode 100755
index 0000000..9786f77
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/Spanned.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * This is the interface for text that has markup objects attached to
+ * ranges of it.  Not all text classes have mutable markup or text;
+ * see {@link Spannable} for mutable markup and {@link Editable} for
+ * mutable text.
+ */
+public interface Spanned
+extends CharSequence
+{
+    /**
+     * Bitmask of bits that are relevent for controlling point/mark behavior
+     * of spans.
+     */
+    public static final int SPAN_POINT_MARK_MASK = 0x33;
+    
+    /**
+     * 0-length spans with type SPAN_MARK_MARK behave like text marks:
+     * they remain at their original offset when text is inserted
+     * at that offset.
+     */
+    public static final int SPAN_MARK_MARK =   0x11;
+    /**
+     * SPAN_MARK_POINT is a synonym for {@link #SPAN_INCLUSIVE_INCLUSIVE}.
+     */
+    public static final int SPAN_MARK_POINT =  0x12;
+    /**
+     * SPAN_POINT_MARK is a synonym for {@link #SPAN_EXCLUSIVE_EXCLUSIVE}.
+     */
+    public static final int SPAN_POINT_MARK =  0x21;
+
+    /**
+     * 0-length spans with type SPAN_POINT_POINT behave like cursors:
+     * they are pushed forward by the length of the insertion when text
+     * is inserted at their offset.
+     */
+    public static final int SPAN_POINT_POINT = 0x22;
+
+    /**
+     * SPAN_PARAGRAPH behaves like SPAN_INCLUSIVE_EXCLUSIVE
+     * (SPAN_MARK_MARK), except that if either end of the span is
+     * at the end of the buffer, that end behaves like _POINT
+     * instead (so SPAN_INCLUSIVE_INCLUSIVE if it starts in the
+     * middle and ends at the end, or SPAN_EXCLUSIVE_INCLUSIVE
+     * if it both starts and ends at the end).
+     * <p>
+     * Its endpoints must be the start or end of the buffer or
+     * immediately after a \n character, and if the \n
+     * that anchors it is deleted, the endpoint is pulled to the
+     * next \n that follows in the buffer (or to the end of
+     * the buffer).
+     */
+    public static final int SPAN_PARAGRAPH =   0x33;
+
+    /**
+     * Non-0-length spans of type SPAN_INCLUSIVE_EXCLUSIVE expand
+     * to include text inserted at their starting point but not at their
+     * ending point.  When 0-length, they behave like marks.
+     */
+    public static final int SPAN_INCLUSIVE_EXCLUSIVE = SPAN_MARK_MARK;
+
+    /**
+     * Spans of type SPAN_INCLUSIVE_INCLUSIVE expand
+     * to include text inserted at either their starting or ending point.
+     */
+    public static final int SPAN_INCLUSIVE_INCLUSIVE = SPAN_MARK_POINT;
+
+    /**
+     * Spans of type SPAN_EXCLUSIVE_EXCLUSIVE do not expand
+     * to include text inserted at either their starting or ending point.
+     * They can never have a length of 0 and are automatically removed
+     * from the buffer if all the text they cover is removed.
+     */
+    public static final int SPAN_EXCLUSIVE_EXCLUSIVE = SPAN_POINT_MARK;
+
+    /**
+     * Non-0-length spans of type SPAN_INCLUSIVE_EXCLUSIVE expand
+     * to include text inserted at their ending point but not at their
+     * starting point.  When 0-length, they behave like points.
+     */
+    public static final int SPAN_EXCLUSIVE_INCLUSIVE = SPAN_POINT_POINT;
+
+    /**
+     * This flag is set on spans that are being used to apply temporary
+     * styling information on the composing text of an input method, so that
+     * they can be found and removed when the composing text is being
+     * replaced.
+     */
+    public static final int SPAN_COMPOSING = 0x100;
+    
+    /**
+     * This flag will be set for intermediate span changes, meaning there
+     * is guaranteed to be another change following it.  Typically it is
+     * used for {@link Selection} which automatically uses this with the first
+     * offset it sets when updating the selection.
+     */
+    public static final int SPAN_INTERMEDIATE = 0x200;
+    
+    /**
+     * The bits numbered SPAN_USER_SHIFT and above are available
+     * for callers to use to store scalar data associated with their
+     * span object.
+     */
+    public static final int SPAN_USER_SHIFT = 24;
+    /**
+     * The bits specified by the SPAN_USER bitfield are available
+     * for callers to use to store scalar data associated with their
+     * span object.
+     */
+    public static final int SPAN_USER = 0xFFFFFFFF << SPAN_USER_SHIFT;
+
+    /**
+     * The bits numbered just above SPAN_PRIORITY_SHIFT determine the order
+     * of change notifications -- higher numbers go first.  You probably
+     * don't need to set this; it is used so that when text changes, the
+     * text layout gets the chance to update itself before any other
+     * callbacks can inquire about the layout of the text.
+     */
+    public static final int SPAN_PRIORITY_SHIFT = 16;
+    /**
+     * The bits specified by the SPAN_PRIORITY bitmap determine the order
+     * of change notifications -- higher numbers go first.  You probably
+     * don't need to set this; it is used so that when text changes, the
+     * text layout gets the chance to update itself before any other
+     * callbacks can inquire about the layout of the text.
+     */
+    public static final int SPAN_PRIORITY = 0xFF << SPAN_PRIORITY_SHIFT;
+
+    /**
+     * Return an array of the markup objects attached to the specified
+     * slice of this CharSequence and whose type is the specified type
+     * or a subclass of it.  Specify Object.class for the type if you
+     * want all the objects regardless of type.
+     */
+    public <T> T[] getSpans(int start, int end, Class<T> type);
+
+    /**
+     * Return the beginning of the range of text to which the specified
+     * markup object is attached, or -1 if the object is not attached.
+     */
+    public int getSpanStart(Object tag);
+
+    /**
+     * Return the end of the range of text to which the specified
+     * markup object is attached, or -1 if the object is not attached.
+     */
+    public int getSpanEnd(Object tag);
+
+    /**
+     * Return the flags that were specified when {@link Spannable#setSpan} was
+     * used to attach the specified markup object, or 0 if the specified
+     * object has not been attached.
+     */
+    public int getSpanFlags(Object tag);
+
+    /**
+     * Return the first offset greater than or equal to <code>start</code>
+     * where a markup object of class <code>type</code> begins or ends,
+     * or <code>limit</code> if there are no starts or ends greater than or
+     * equal to <code>start</code> but less than <code>limit</code>.  Specify
+     * <code>null</code> or Object.class for the type if you want every
+     * transition regardless of type.
+     */
+    public int nextSpanTransition(int start, int limit, Class type);
+}
diff --git a/src/com/transage/privatespace/vcard/text/TextUtils.java b/src/com/transage/privatespace/vcard/text/TextUtils.java
new file mode 100755
index 0000000..f72ecd9
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/TextUtils.java
@@ -0,0 +1,1628 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+//import com.android.internal.R;
+//
+//import android.content.res.ColorStateList;
+//import android.content.res.Resources;
+//import android.os.Parcel;
+//import android.os.Parcelable;
+//import android.text.method.TextKeyListener.Capitalize;
+//import android.text.style.AbsoluteSizeSpan;
+//import android.text.style.AlignmentSpan;
+//import android.text.style.BackgroundColorSpan;
+//import android.text.style.BulletSpan;
+//import android.text.style.CharacterStyle;
+//import android.text.style.ForegroundColorSpan;
+//import android.text.style.LeadingMarginSpan;
+//import android.text.style.MetricAffectingSpan;
+//import android.text.style.QuoteSpan;
+//import android.text.style.RelativeSizeSpan;
+//import android.text.style.ReplacementSpan;
+//import android.text.style.ScaleXSpan;
+//import android.text.style.StrikethroughSpan;
+//import android.text.style.StyleSpan;
+//import android.text.style.SubscriptSpan;
+//import android.text.style.SuperscriptSpan;
+//import android.text.style.TextAppearanceSpan;
+//import android.text.style.TypefaceSpan;
+//import android.text.style.URLSpan;
+//import android.text.style.UnderlineSpan;
+//import android.util.Printer;
+//
+//import com.android.internal.util.ArrayUtils;
+
+public class TextUtils {
+    private TextUtils() { /* cannot be instantiated */ }
+
+//    private static String[] EMPTY_STRING_ARRAY = new String[]{};
+//
+    public static void getChars(CharSequence s, int start, int end,
+                                char[] dest, int destoff) {
+        Class c = s.getClass();
+
+        if (c == String.class)
+            ((String) s).getChars(start, end, dest, destoff);
+        else if (c == StringBuffer.class)
+            ((StringBuffer) s).getChars(start, end, dest, destoff);
+        else if (c == StringBuilder.class)
+            ((StringBuilder) s).getChars(start, end, dest, destoff);
+        else if (s instanceof GetChars)
+            ((GetChars) s).getChars(start, end, dest, destoff);
+        else {
+            for (int i = start; i < end; i++)
+                dest[destoff++] = s.charAt(i);
+        }
+    }
+//
+//    public static int indexOf(CharSequence s, char ch) {
+//        return indexOf(s, ch, 0);
+//    }
+//
+//    public static int indexOf(CharSequence s, char ch, int start) {
+//        Class c = s.getClass();
+//
+//        if (c == String.class)
+//            return ((String) s).indexOf(ch, start);
+//
+//        return indexOf(s, ch, start, s.length());
+//    }
+//
+//    public static int indexOf(CharSequence s, char ch, int start, int end) {
+//        Class c = s.getClass();
+//
+//        if (s instanceof GetChars || c == StringBuffer.class ||
+//            c == StringBuilder.class || c == String.class) {
+//            final int INDEX_INCREMENT = 500;
+//            char[] temp = obtain(INDEX_INCREMENT);
+//
+//            while (start < end) {
+//                int segend = start + INDEX_INCREMENT;
+//                if (segend > end)
+//                    segend = end;
+//
+//                getChars(s, start, segend, temp, 0);
+//
+//                int count = segend - start;
+//                for (int i = 0; i < count; i++) {
+//                    if (temp[i] == ch) {
+//                        recycle(temp);
+//                        return i + start;
+//                    }
+//                }
+//
+//                start = segend;
+//            }
+//
+//            recycle(temp);
+//            return -1;
+//        }
+//
+//        for (int i = start; i < end; i++)
+//            if (s.charAt(i) == ch)
+//                return i;
+//
+//        return -1;
+//    }
+//
+//    public static int lastIndexOf(CharSequence s, char ch) {
+//        return lastIndexOf(s, ch, s.length() - 1);
+//    }
+//
+//    public static int lastIndexOf(CharSequence s, char ch, int last) {
+//        Class c = s.getClass();
+//
+//        if (c == String.class)
+//            return ((String) s).lastIndexOf(ch, last);
+//
+//        return lastIndexOf(s, ch, 0, last);
+//    }
+//
+//    public static int lastIndexOf(CharSequence s, char ch,
+//                                  int start, int last) {
+//        if (last < 0)
+//            return -1;
+//        if (last >= s.length())
+//            last = s.length() - 1;
+//
+//        int end = last + 1;
+//
+//        Class c = s.getClass();
+//
+//        if (s instanceof GetChars || c == StringBuffer.class ||
+//            c == StringBuilder.class || c == String.class) {
+//            final int INDEX_INCREMENT = 500;
+//            char[] temp = obtain(INDEX_INCREMENT);
+//
+//            while (start < end) {
+//                int segstart = end - INDEX_INCREMENT;
+//                if (segstart < start)
+//                    segstart = start;
+//
+//                getChars(s, segstart, end, temp, 0);
+//
+//                int count = end - segstart;
+//                for (int i = count - 1; i >= 0; i--) {
+//                    if (temp[i] == ch) {
+//                        recycle(temp);
+//                        return i + segstart;
+//                    }
+//                }
+//
+//                end = segstart;
+//            }
+//
+//            recycle(temp);
+//            return -1;
+//        }
+//
+//        for (int i = end - 1; i >= start; i--)
+//            if (s.charAt(i) == ch)
+//                return i;
+//
+//        return -1;
+//    }
+//
+//    public static int indexOf(CharSequence s, CharSequence needle) {
+//        return indexOf(s, needle, 0, s.length());
+//    }
+//
+//    public static int indexOf(CharSequence s, CharSequence needle, int start) {
+//        return indexOf(s, needle, start, s.length());
+//    }
+//
+//    public static int indexOf(CharSequence s, CharSequence needle,
+//                              int start, int end) {
+//        int nlen = needle.length();
+//        if (nlen == 0)
+//            return start;
+//
+//        char c = needle.charAt(0);
+//
+//        for (;;) {
+//            start = indexOf(s, c, start);
+//            if (start > end - nlen) {
+//                break;
+//            }
+//
+//            if (start < 0) {
+//                return -1;
+//            }
+//
+//            if (regionMatches(s, start, needle, 0, nlen)) {
+//                return start;
+//            }
+//
+//            start++;
+//        }
+//        return -1;
+//    }
+//
+//    public static boolean regionMatches(CharSequence one, int toffset,
+//                                        CharSequence two, int ooffset,
+//                                        int len) {
+//        char[] temp = obtain(2 * len);
+//
+//        getChars(one, toffset, toffset + len, temp, 0);
+//        getChars(two, ooffset, ooffset + len, temp, len);
+//
+//        boolean match = true;
+//        for (int i = 0; i < len; i++) {
+//            if (temp[i] != temp[i + len]) {
+//                match = false;
+//                break;
+//            }
+//        }
+//
+//        recycle(temp);
+//        return match;
+//    }
+//
+//    /**
+//     * Create a new String object containing the given range of characters
+//     * from the source string.  This is different than simply calling
+//     * {@link CharSequence#subSequence(int, int) CharSequence.subSequence}
+//     * in that it does not preserve any style runs in the source sequence,
+//     * allowing a more efficient implementation.
+//     */
+//    public static String substring(CharSequence source, int start, int end) {
+//        if (source instanceof String)
+//            return ((String) source).substring(start, end);
+//        if (source instanceof StringBuilder)
+//            return ((StringBuilder) source).substring(start, end);
+//        if (source instanceof StringBuffer)
+//            return ((StringBuffer) source).substring(start, end);
+//
+//        char[] temp = obtain(end - start);
+//        getChars(source, start, end, temp, 0);
+//        String ret = new String(temp, 0, end - start);
+//        recycle(temp);
+//
+//        return ret;
+//    }
+//
+//    /**
+//     * Returns a string containing the tokens joined by delimiters.
+//     * @param tokens an array objects to be joined. Strings will be formed from
+//     *     the objects by calling object.toString().
+//     */
+//    public static String join(CharSequence delimiter, Object[] tokens) {
+//        StringBuilder sb = new StringBuilder();
+//        boolean firstTime = true;
+//        for (Object token: tokens) {
+//            if (firstTime) {
+//                firstTime = false;
+//            } else {
+//                sb.append(delimiter);
+//            }
+//            sb.append(token);
+//        }
+//        return sb.toString();
+//    }
+//
+//    /**
+//     * Returns a string containing the tokens joined by delimiters.
+//     * @param tokens an array objects to be joined. Strings will be formed from
+//     *     the objects by calling object.toString().
+//     */
+//    public static String join(CharSequence delimiter, Iterable tokens) {
+//        StringBuilder sb = new StringBuilder();
+//        boolean firstTime = true;
+//        for (Object token: tokens) {
+//            if (firstTime) {
+//                firstTime = false;
+//            } else {
+//                sb.append(delimiter);
+//            }
+//            sb.append(token);
+//        }
+//        return sb.toString();
+//    }
+//
+//    /**
+//     * String.split() returns [''] when the string to be split is empty. This returns []. This does
+//     * not remove any empty strings from the result. For example split("a,", ","  ) returns {"a", ""}.
+//     *
+//     * @param text the string to split
+//     * @param expression the regular expression to match
+//     * @return an array of strings. The array will be empty if text is empty
+//     *
+//     * @throws NullPointerException if expression or text is null
+//     */
+//    public static String[] split(String text, String expression) {
+//        if (text.length() == 0) {
+//            return EMPTY_STRING_ARRAY;
+//        } else {
+//            return text.split(expression, -1);
+//        }
+//    }
+//
+//    /**
+//     * Splits a string on a pattern. String.split() returns [''] when the string to be
+//     * split is empty. This returns []. This does not remove any empty strings from the result.
+//     * @param text the string to split
+//     * @param pattern the regular expression to match
+//     * @return an array of strings. The array will be empty if text is empty
+//     *
+//     * @throws NullPointerException if expression or text is null
+//     */
+//    public static String[] split(String text, Pattern pattern) {
+//        if (text.length() == 0) {
+//            return EMPTY_STRING_ARRAY;
+//        } else {
+//            return pattern.split(text, -1);
+//        }
+//    }
+//
+//    /**
+//     * An interface for splitting strings according to rules that are opaque to the user of this
+//     * interface. This also has less overhead than split, which uses regular expressions and
+//     * allocates an array to hold the results.
+//     *
+//     * <p>The most efficient way to use this class is:
+//     *
+//     * <pre>
+//     * // Once
+//     * TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(delimiter);
+//     *
+//     * // Once per string to split
+//     * splitter.setString(string);
+//     * for (String s : splitter) {
+//     *     ...
+//     * }
+//     * </pre>
+//     */
+//    public interface StringSplitter extends Iterable<String> {
+//        public void setString(String string);
+//    }
+//
+//    /**
+//     * A simple string splitter.
+//     *
+//     * <p>If the final character in the string to split is the delimiter then no empty string will
+//     * be returned for the empty string after that delimeter. That is, splitting <tt>"a,b,"</tt> on
+//     * comma will return <tt>"a", "b"</tt>, not <tt>"a", "b", ""</tt>.
+//     */
+//    public static class SimpleStringSplitter implements StringSplitter, Iterator<String> {
+//        private String mString;
+//        private char mDelimiter;
+//        private int mPosition;
+//        private int mLength;
+//
+//        /**
+//         * Initializes the splitter. setString may be called later.
+//         * @param delimiter the delimeter on which to split
+//         */
+//        public SimpleStringSplitter(char delimiter) {
+//            mDelimiter = delimiter;
+//        }
+//
+//        /**
+//         * Sets the string to split
+//         * @param string the string to split
+//         */
+//        public void setString(String string) {
+//            mString = string;
+//            mPosition = 0;
+//            mLength = mString.length();
+//        }
+//
+//        public Iterator<String> iterator() {
+//            return this;
+//        }
+//
+//        public boolean hasNext() {
+//            return mPosition < mLength;
+//        }
+//
+//        public String next() {
+//            int end = mString.indexOf(mDelimiter, mPosition);
+//            if (end == -1) {
+//                end = mLength;
+//            }
+//            String nextString = mString.substring(mPosition, end);
+//            mPosition = end + 1; // Skip the delimiter.
+//            return nextString;
+//        }
+//
+//        public void remove() {
+//            throw new UnsupportedOperationException();
+//        }
+//    }
+//
+//    public static CharSequence stringOrSpannedString(CharSequence source) {
+//        if (source == null)
+//            return null;
+//        if (source instanceof SpannedString)
+//            return source;
+//        if (source instanceof Spanned)
+//            return new SpannedString(source);
+//
+//        return source.toString();
+//    }
+//
+    /**
+     * Returns true if the string is null or 0-length.
+     * @param str the string to be examined
+     * @return true if str is null or zero length
+     */
+    public static boolean isEmpty(CharSequence str) {
+        if (str == null || str.length() == 0)
+            return true;
+        else
+            return false;
+    }
+//
+//    /**
+//     * Returns the length that the specified CharSequence would have if
+//     * spaces and control characters were trimmed from the start and end,
+//     * as by {@link String#trim}.
+//     */
+//    public static int getTrimmedLength(CharSequence s) {
+//        int len = s.length();
+//
+//        int start = 0;
+//        while (start < len && s.charAt(start) <= ' ') {
+//            start++;
+//        }
+//
+//        int end = len;
+//        while (end > start && s.charAt(end - 1) <= ' ') {
+//            end--;
+//        }
+//
+//        return end - start;
+//    }
+//
+//    /**
+//     * Returns true if a and b are equal, including if they are both null.
+//     * <p><i>Note: In platform versions 1.1 and earlier, this method only worked well if
+//     * both the arguments were instances of String.</i></p>
+//     * @param a first CharSequence to check
+//     * @param b second CharSequence to check
+//     * @return true if a and b are equal
+//     */
+//    public static boolean equals(CharSequence a, CharSequence b) {
+//        if (a == b) return true;
+//        int length;
+//        if (a != null && b != null && (length = a.length()) == b.length()) {
+//            if (a instanceof String && b instanceof String) {
+//                return a.equals(b);
+//            } else {
+//                for (int i = 0; i < length; i++) {
+//                    if (a.charAt(i) != b.charAt(i)) return false;
+//                }
+//                return true;
+//            }
+//        }
+//        return false;
+//    }
+//
+//    // XXX currently this only reverses chars, not spans
+//    public static CharSequence getReverse(CharSequence source,
+//                                          int start, int end) {
+//        return new Reverser(source, start, end);
+//    }
+//
+//    private static class Reverser
+//    implements CharSequence, GetChars
+//    {
+//        public Reverser(CharSequence source, int start, int end) {
+//            mSource = source;
+//            mStart = start;
+//            mEnd = end;
+//        }
+//
+//        public int length() {
+//            return mEnd - mStart;
+//        }
+//
+//        public CharSequence subSequence(int start, int end) {
+//            char[] buf = new char[end - start];
+//
+//            getChars(start, end, buf, 0);
+//            return new String(buf);
+//        }
+//
+//        public String toString() {
+//            return subSequence(0, length()).toString();
+//        }
+//
+//        public char charAt(int off) {
+//            return AndroidCharacter.getMirror(mSource.charAt(mEnd - 1 - off));
+//        }
+//
+//        public void getChars(int start, int end, char[] dest, int destoff) {
+//            TextUtils.getChars(mSource, start + mStart, end + mStart,
+//                               dest, destoff);
+//            AndroidCharacter.mirror(dest, 0, end - start);
+//
+//            int len = end - start;
+//            int n = (end - start) / 2;
+//            for (int i = 0; i < n; i++) {
+//                char tmp = dest[destoff + i];
+//
+//                dest[destoff + i] = dest[destoff + len - i - 1];
+//                dest[destoff + len - i - 1] = tmp;
+//            }
+//        }
+//
+//        private CharSequence mSource;
+//        private int mStart;
+//        private int mEnd;
+//    }
+//
+//    /** @hide */
+//    public static final int ALIGNMENT_SPAN = 1;
+//    /** @hide */
+//    public static final int FOREGROUND_COLOR_SPAN = 2;
+//    /** @hide */
+//    public static final int RELATIVE_SIZE_SPAN = 3;
+//    /** @hide */
+//    public static final int SCALE_X_SPAN = 4;
+//    /** @hide */
+//    public static final int STRIKETHROUGH_SPAN = 5;
+//    /** @hide */
+//    public static final int UNDERLINE_SPAN = 6;
+//    /** @hide */
+//    public static final int STYLE_SPAN = 7;
+//    /** @hide */
+//    public static final int BULLET_SPAN = 8;
+//    /** @hide */
+//    public static final int QUOTE_SPAN = 9;
+//    /** @hide */
+//    public static final int LEADING_MARGIN_SPAN = 10;
+//    /** @hide */
+//    public static final int URL_SPAN = 11;
+//    /** @hide */
+//    public static final int BACKGROUND_COLOR_SPAN = 12;
+//    /** @hide */
+//    public static final int TYPEFACE_SPAN = 13;
+//    /** @hide */
+//    public static final int SUPERSCRIPT_SPAN = 14;
+//    /** @hide */
+//    public static final int SUBSCRIPT_SPAN = 15;
+//    /** @hide */
+//    public static final int ABSOLUTE_SIZE_SPAN = 16;
+//    /** @hide */
+//    public static final int TEXT_APPEARANCE_SPAN = 17;
+//    /** @hide */
+//    public static final int ANNOTATION = 18;
+//
+//    /**
+//     * Flatten a CharSequence and whatever styles can be copied across processes
+//     * into the parcel.
+//     */
+//    public static void writeToParcel(CharSequence cs, Parcel p,
+//            int parcelableFlags) {
+//        if (cs instanceof Spanned) {
+//            p.writeInt(0);
+//            p.writeString(cs.toString());
+//
+//            Spanned sp = (Spanned) cs;
+//            Object[] os = sp.getSpans(0, cs.length(), Object.class);
+//
+//            // note to people adding to this: check more specific types
+//            // before more generic types.  also notice that it uses
+//            // "if" instead of "else if" where there are interfaces
+//            // so one object can be several.
+//
+//            for (int i = 0; i < os.length; i++) {
+//                Object o = os[i];
+//                Object prop = os[i];
+//
+//                if (prop instanceof CharacterStyle) {
+//                    prop = ((CharacterStyle) prop).getUnderlying();
+//                }
+//
+//                if (prop instanceof ParcelableSpan) {
+//                    ParcelableSpan ps = (ParcelableSpan)prop;
+//                    p.writeInt(ps.getSpanTypeId());
+//                    ps.writeToParcel(p, parcelableFlags);
+//                    writeWhere(p, sp, o);
+//                }
+//            }
+//
+//            p.writeInt(0);
+//        } else {
+//            p.writeInt(1);
+//            if (cs != null) {
+//                p.writeString(cs.toString());
+//            } else {
+//                p.writeString(null);
+//            }
+//        }
+//    }
+//
+//    private static void writeWhere(Parcel p, Spanned sp, Object o) {
+//        p.writeInt(sp.getSpanStart(o));
+//        p.writeInt(sp.getSpanEnd(o));
+//        p.writeInt(sp.getSpanFlags(o));
+//    }
+//
+//    public static final Parcelable.Creator<CharSequence> CHAR_SEQUENCE_CREATOR
+//            = new Parcelable.Creator<CharSequence>() {
+//        /**
+//         * Read and return a new CharSequence, possibly with styles,
+//         * from the parcel.
+//         */
+//        public  CharSequence createFromParcel(Parcel p) {
+//            int kind = p.readInt();
+//
+//            if (kind == 1)
+//                return p.readString();
+//
+//            SpannableString sp = new SpannableString(p.readString());
+//
+//            while (true) {
+//                kind = p.readInt();
+//
+//                if (kind == 0)
+//                    break;
+//
+//                switch (kind) {
+//                case ALIGNMENT_SPAN:
+//                    readSpan(p, sp, new AlignmentSpan.Standard(p));
+//                    break;
+//
+//                case FOREGROUND_COLOR_SPAN:
+//                    readSpan(p, sp, new ForegroundColorSpan(p));
+//                    break;
+//
+//                case RELATIVE_SIZE_SPAN:
+//                    readSpan(p, sp, new RelativeSizeSpan(p));
+//                    break;
+//
+//                case SCALE_X_SPAN:
+//                    readSpan(p, sp, new ScaleXSpan(p));
+//                    break;
+//
+//                case STRIKETHROUGH_SPAN:
+//                    readSpan(p, sp, new StrikethroughSpan(p));
+//                    break;
+//
+//                case UNDERLINE_SPAN:
+//                    readSpan(p, sp, new UnderlineSpan(p));
+//                    break;
+//
+//                case STYLE_SPAN:
+//                    readSpan(p, sp, new StyleSpan(p));
+//                    break;
+//
+//                case BULLET_SPAN:
+//                    readSpan(p, sp, new BulletSpan(p));
+//                    break;
+//
+//                case QUOTE_SPAN:
+//                    readSpan(p, sp, new QuoteSpan(p));
+//                    break;
+//
+//                case LEADING_MARGIN_SPAN:
+//                    readSpan(p, sp, new LeadingMarginSpan.Standard(p));
+//                break;
+//
+//                case URL_SPAN:
+//                    readSpan(p, sp, new URLSpan(p));
+//                    break;
+//
+//                case BACKGROUND_COLOR_SPAN:
+//                    readSpan(p, sp, new BackgroundColorSpan(p));
+//                    break;
+//
+//                case TYPEFACE_SPAN:
+//                    readSpan(p, sp, new TypefaceSpan(p));
+//                    break;
+//
+//                case SUPERSCRIPT_SPAN:
+//                    readSpan(p, sp, new SuperscriptSpan(p));
+//                    break;
+//
+//                case SUBSCRIPT_SPAN:
+//                    readSpan(p, sp, new SubscriptSpan(p));
+//                    break;
+//
+//                case ABSOLUTE_SIZE_SPAN:
+//                    readSpan(p, sp, new AbsoluteSizeSpan(p));
+//                    break;
+//
+//                case TEXT_APPEARANCE_SPAN:
+//                    readSpan(p, sp, new TextAppearanceSpan(p));
+//                    break;
+//
+//                case ANNOTATION:
+//                    readSpan(p, sp, new Annotation(p));
+//                    break;
+//
+//                default:
+//                    throw new RuntimeException("bogus span encoding " + kind);
+//                }
+//            }
+//
+//            return sp;
+//        }
+//
+//        public CharSequence[] newArray(int size)
+//        {
+//            return new CharSequence[size];
+//        }
+//    };
+//
+//    /**
+//     * Debugging tool to print the spans in a CharSequence.  The output will
+//     * be printed one span per line.  If the CharSequence is not a Spanned,
+//     * then the entire string will be printed on a single line.
+//     */
+//    public static void dumpSpans(CharSequence cs, Printer printer, String prefix) {
+//        if (cs instanceof Spanned) {
+//            Spanned sp = (Spanned) cs;
+//            Object[] os = sp.getSpans(0, cs.length(), Object.class);
+//
+//            for (int i = 0; i < os.length; i++) {
+//                Object o = os[i];
+//                printer.println(prefix + cs.subSequence(sp.getSpanStart(o),
+//                        sp.getSpanEnd(o)) + ": "
+//                        + Integer.toHexString(System.identityHashCode(o))
+//                        + " " + o.getClass().getCanonicalName()
+//                         + " (" + sp.getSpanStart(o) + "-" + sp.getSpanEnd(o)
+//                         + ") fl=#" + sp.getSpanFlags(o));
+//            }
+//        } else {
+//            printer.println(prefix + cs + ": (no spans)");
+//        }
+//    }
+//
+//    /**
+//     * Return a new CharSequence in which each of the source strings is
+//     * replaced by the corresponding element of the destinations.
+//     */
+//    public static CharSequence replace(CharSequence template,
+//                                       String[] sources,
+//                                       CharSequence[] destinations) {
+//        SpannableStringBuilder tb = new SpannableStringBuilder(template);
+//
+//        for (int i = 0; i < sources.length; i++) {
+//            int where = indexOf(tb, sources[i]);
+//
+//            if (where >= 0)
+//                tb.setSpan(sources[i], where, where + sources[i].length(),
+//                           Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+//        }
+//
+//        for (int i = 0; i < sources.length; i++) {
+//            int start = tb.getSpanStart(sources[i]);
+//            int end = tb.getSpanEnd(sources[i]);
+//
+//            if (start >= 0) {
+//                tb.replace(start, end, destinations[i]);
+//            }
+//        }
+//
+//        return tb;
+//    }
+//
+//    /**
+//     * Replace instances of "^1", "^2", etc. in the
+//     * <code>template</code> CharSequence with the corresponding
+//     * <code>values</code>.  "^^" is used to produce a single caret in
+//     * the output.  Only up to 9 replacement values are supported,
+//     * "^10" will be produce the first replacement value followed by a
+//     * '0'.
+//     *
+//     * @param template the input text containing "^1"-style
+//     * placeholder values.  This object is not modified; a copy is
+//     * returned.
+//     *
+//     * @param values CharSequences substituted into the template.  The
+//     * first is substituted for "^1", the second for "^2", and so on.
+//     *
+//     * @return the new CharSequence produced by doing the replacement
+//     *
+//     * @throws IllegalArgumentException if the template requests a
+//     * value that was not provided, or if more than 9 values are
+//     * provided.
+//     */
+//    public static CharSequence expandTemplate(CharSequence template,
+//                                              CharSequence... values) {
+//        if (values.length > 9) {
+//            throw new IllegalArgumentException("max of 9 values are supported");
+//        }
+//
+//        SpannableStringBuilder ssb = new SpannableStringBuilder(template);
+//
+//        try {
+//            int i = 0;
+//            while (i < ssb.length()) {
+//                if (ssb.charAt(i) == '^') {
+//                    char next = ssb.charAt(i+1);
+//                    if (next == '^') {
+//                        ssb.delete(i+1, i+2);
+//                        ++i;
+//                        continue;
+//                    } else if (Character.isDigit(next)) {
+//                        int which = Character.getNumericValue(next) - 1;
+//                        if (which < 0) {
+//                            throw new IllegalArgumentException(
+//                                "template requests value ^" + (which+1));
+//                        }
+//                        if (which >= values.length) {
+//                            throw new IllegalArgumentException(
+//                                "template requests value ^" + (which+1) +
+//                                "; only " + values.length + " provided");
+//                        }
+//                        ssb.replace(i, i+2, values[which]);
+//                        i += values[which].length();
+//                        continue;
+//                    }
+//                }
+//                ++i;
+//            }
+//        } catch (IndexOutOfBoundsException ignore) {
+//            // happens when ^ is the last character in the string.
+//        }
+//        return ssb;
+//    }
+//
+//    public static int getOffsetBefore(CharSequence text, int offset) {
+//        if (offset == 0)
+//            return 0;
+//        if (offset == 1)
+//            return 0;
+//
+//        char c = text.charAt(offset - 1);
+//
+//        if (c >= '\uDC00' && c <= '\uDFFF') {
+//            char c1 = text.charAt(offset - 2);
+//
+//            if (c1 >= '\uD800' && c1 <= '\uDBFF')
+//                offset -= 2;
+//            else
+//                offset -= 1;
+//        } else {
+//            offset -= 1;
+//        }
+//
+//        if (text instanceof Spanned) {
+//            ReplacementSpan[] spans = ((Spanned) text).getSpans(offset, offset,
+//                                                       ReplacementSpan.class);
+//
+//            for (int i = 0; i < spans.length; i++) {
+//                int start = ((Spanned) text).getSpanStart(spans[i]);
+//                int end = ((Spanned) text).getSpanEnd(spans[i]);
+//
+//                if (start < offset && end > offset)
+//                    offset = start;
+//            }
+//        }
+//
+//        return offset;
+//    }
+//
+//    public static int getOffsetAfter(CharSequence text, int offset) {
+//        int len = text.length();
+//
+//        if (offset == len)
+//            return len;
+//        if (offset == len - 1)
+//            return len;
+//
+//        char c = text.charAt(offset);
+//
+//        if (c >= '\uD800' && c <= '\uDBFF') {
+//            char c1 = text.charAt(offset + 1);
+//
+//            if (c1 >= '\uDC00' && c1 <= '\uDFFF')
+//                offset += 2;
+//            else
+//                offset += 1;
+//        } else {
+//            offset += 1;
+//        }
+//
+//        if (text instanceof Spanned) {
+//            ReplacementSpan[] spans = ((Spanned) text).getSpans(offset, offset,
+//                                                       ReplacementSpan.class);
+//
+//            for (int i = 0; i < spans.length; i++) {
+//                int start = ((Spanned) text).getSpanStart(spans[i]);
+//                int end = ((Spanned) text).getSpanEnd(spans[i]);
+//
+//                if (start < offset && end > offset)
+//                    offset = end;
+//            }
+//        }
+//
+//        return offset;
+//    }
+//
+//    private static void readSpan(Parcel p, Spannable sp, Object o) {
+//        sp.setSpan(o, p.readInt(), p.readInt(), p.readInt());
+//    }
+//
+//    /**
+//     * Copies the spans from the region <code>start...end</code> in
+//     * <code>source</code> to the region
+//     * <code>destoff...destoff+end-start</code> in <code>dest</code>.
+//     * Spans in <code>source</code> that begin before <code>start</code>
+//     * or end after <code>end</code> but overlap this range are trimmed
+//     * as if they began at <code>start</code> or ended at <code>end</code>.
+//     *
+//     * @throws IndexOutOfBoundsException if any of the copied spans
+//     * are out of range in <code>dest</code>.
+//     */
+//    public static void copySpansFrom(Spanned source, int start, int end,
+//                                     Class kind,
+//                                     Spannable dest, int destoff) {
+//        if (kind == null) {
+//            kind = Object.class;
+//        }
+//
+//        Object[] spans = source.getSpans(start, end, kind);
+//
+//        for (int i = 0; i < spans.length; i++) {
+//            int st = source.getSpanStart(spans[i]);
+//            int en = source.getSpanEnd(spans[i]);
+//            int fl = source.getSpanFlags(spans[i]);
+//
+//            if (st < start)
+//                st = start;
+//            if (en > end)
+//                en = end;
+//
+//            dest.setSpan(spans[i], st - start + destoff, en - start + destoff,
+//                         fl);
+//        }
+//    }
+//
+//    public enum TruncateAt {
+//        START,
+//        MIDDLE,
+//        END,
+//        MARQUEE,
+//    }
+//
+//    public interface EllipsizeCallback {
+//        /**
+//         * This method is called to report that the specified region of
+//         * text was ellipsized away by a call to {@link #ellipsize}.
+//         */
+//        public void ellipsized(int start, int end);
+//    }
+//
+//    private static String sEllipsis = null;
+//
+//    /**
+//     * Returns the original text if it fits in the specified width
+//     * given the properties of the specified Paint,
+//     * or, if it does not fit, a truncated
+//     * copy with ellipsis character added at the specified edge or center.
+//     */
+//    public static CharSequence ellipsize(CharSequence text,
+//                                         TextPaint p,
+//                                         float avail, TruncateAt where) {
+//        return ellipsize(text, p, avail, where, false, null);
+//    }
+//
+//    /**
+//     * Returns the original text if it fits in the specified width
+//     * given the properties of the specified Paint,
+//     * or, if it does not fit, a copy with ellipsis character added
+//     * at the specified edge or center.
+//     * If <code>preserveLength</code> is specified, the returned copy
+//     * will be padded with zero-width spaces to preserve the original
+//     * length and offsets instead of truncating.
+//     * If <code>callback</code> is non-null, it will be called to
+//     * report the start and end of the ellipsized range.
+//     */
+//    public static CharSequence ellipsize(CharSequence text,
+//                                         TextPaint p,
+//                                         float avail, TruncateAt where,
+//                                         boolean preserveLength,
+//                                         EllipsizeCallback callback) {
+//        if (sEllipsis == null) {
+//            Resources r = Resources.getSystem();
+//            sEllipsis = r.getString(R.string.ellipsis);
+//        }
+//
+//        int len = text.length();
+//
+//        // Use Paint.breakText() for the non-Spanned case to avoid having
+//        // to allocate memory and accumulate the character widths ourselves.
+//
+//        if (!(text instanceof Spanned)) {
+//            float wid = p.measureText(text, 0, len);
+//
+//            if (wid <= avail) {
+//                if (callback != null) {
+//                    callback.ellipsized(0, 0);
+//                }
+//
+//                return text;
+//            }
+//
+//            float ellipsiswid = p.measureText(sEllipsis);
+//
+//            if (ellipsiswid > avail) {
+//                if (callback != null) {
+//                    callback.ellipsized(0, len);
+//                }
+//
+//                if (preserveLength) {
+//                    char[] buf = obtain(len);
+//                    for (int i = 0; i < len; i++) {
+//                        buf[i] = '\uFEFF';
+//                    }
+//                    String ret = new String(buf, 0, len);
+//                    recycle(buf);
+//                    return ret;
+//                } else {
+//                    return "";
+//                }
+//            }
+//
+//            if (where == TruncateAt.START) {
+//                int fit = p.breakText(text, 0, len, false,
+//                                      avail - ellipsiswid, null);
+//
+//                if (callback != null) {
+//                    callback.ellipsized(0, len - fit);
+//                }
+//
+//                if (preserveLength) {
+//                    return blank(text, 0, len - fit);
+//                } else {
+//                    return sEllipsis + text.toString().substring(len - fit, len);
+//                }
+//            } else if (where == TruncateAt.END) {
+//                int fit = p.breakText(text, 0, len, true,
+//                                      avail - ellipsiswid, null);
+//
+//                if (callback != null) {
+//                    callback.ellipsized(fit, len);
+//                }
+//
+//                if (preserveLength) {
+//                    return blank(text, fit, len);
+//                } else {
+//                    return text.toString().substring(0, fit) + sEllipsis;
+//                }
+//            } else /* where == TruncateAt.MIDDLE */ {
+//                int right = p.breakText(text, 0, len, false,
+//                                        (avail - ellipsiswid) / 2, null);
+//                float used = p.measureText(text, len - right, len);
+//                int left = p.breakText(text, 0, len - right, true,
+//                                       avail - ellipsiswid - used, null);
+//
+//                if (callback != null) {
+//                    callback.ellipsized(left, len - right);
+//                }
+//
+//                if (preserveLength) {
+//                    return blank(text, left, len - right);
+//                } else {
+//                    String s = text.toString();
+//                    return s.substring(0, left) + sEllipsis +
+//                           s.substring(len - right, len);
+//                }
+//            }
+//        }
+//
+//        // But do the Spanned cases by hand, because it's such a pain
+//        // to iterate the span transitions backwards and getTextWidths()
+//        // will give us the information we need.
+//
+//        // getTextWidths() always writes into the start of the array,
+//        // so measure each span into the first half and then copy the
+//        // results into the second half to use later.
+//
+//        float[] wid = new float[len * 2];
+//        TextPaint temppaint = new TextPaint();
+//        Spanned sp = (Spanned) text;
+//
+//        int next;
+//        for (int i = 0; i < len; i = next) {
+//            next = sp.nextSpanTransition(i, len, MetricAffectingSpan.class);
+//
+//            Styled.getTextWidths(p, temppaint, sp, i, next, wid, null);
+//            System.arraycopy(wid, 0, wid, len + i, next - i);
+//        }
+//
+//        float sum = 0;
+//        for (int i = 0; i < len; i++) {
+//            sum += wid[len + i];
+//        }
+//
+//        if (sum <= avail) {
+//            if (callback != null) {
+//                callback.ellipsized(0, 0);
+//            }
+//
+//            return text;
+//        }
+//
+//        float ellipsiswid = p.measureText(sEllipsis);
+//
+//        if (ellipsiswid > avail) {
+//            if (callback != null) {
+//                callback.ellipsized(0, len);
+//            }
+//
+//            if (preserveLength) {
+//                char[] buf = obtain(len);
+//                for (int i = 0; i < len; i++) {
+//                    buf[i] = '\uFEFF';
+//                }
+//                SpannableString ss = new SpannableString(new String(buf, 0, len));
+//                recycle(buf);
+//                copySpansFrom(sp, 0, len, Object.class, ss, 0);
+//                return ss;
+//            } else {
+//                return "";
+//            }
+//        }
+//
+//        if (where == TruncateAt.START) {
+//            sum = 0;
+//            int i;
+//
+//            for (i = len; i >= 0; i--) {
+//                float w = wid[len + i - 1];
+//
+//                if (w + sum + ellipsiswid > avail) {
+//                    break;
+//                }
+//
+//                sum += w;
+//            }
+//
+//            if (callback != null) {
+//                callback.ellipsized(0, i);
+//            }
+//
+//            if (preserveLength) {
+//                SpannableString ss = new SpannableString(blank(text, 0, i));
+//                copySpansFrom(sp, 0, len, Object.class, ss, 0);
+//                return ss;
+//            } else {
+//                SpannableStringBuilder out = new SpannableStringBuilder(sEllipsis);
+//                out.insert(1, text, i, len);
+//
+//                return out;
+//            }
+//        } else if (where == TruncateAt.END) {
+//            sum = 0;
+//            int i;
+//
+//            for (i = 0; i < len; i++) {
+//                float w = wid[len + i];
+//
+//                if (w + sum + ellipsiswid > avail) {
+//                    break;
+//                }
+//
+//                sum += w;
+//            }
+//
+//            if (callback != null) {
+//                callback.ellipsized(i, len);
+//            }
+//
+//            if (preserveLength) {
+//                SpannableString ss = new SpannableString(blank(text, i, len));
+//                copySpansFrom(sp, 0, len, Object.class, ss, 0);
+//                return ss;
+//            } else {
+//                SpannableStringBuilder out = new SpannableStringBuilder(sEllipsis);
+//                out.insert(0, text, 0, i);
+//
+//                return out;
+//            }
+//        } else /* where = TruncateAt.MIDDLE */ {
+//            float lsum = 0, rsum = 0;
+//            int left = 0, right = len;
+//
+//            float ravail = (avail - ellipsiswid) / 2;
+//            for (right = len; right >= 0; right--) {
+//                float w = wid[len + right - 1];
+//
+//                if (w + rsum > ravail) {
+//                    break;
+//                }
+//
+//                rsum += w;
+//            }
+//
+//            float lavail = avail - ellipsiswid - rsum;
+//            for (left = 0; left < right; left++) {
+//                float w = wid[len + left];
+//
+//                if (w + lsum > lavail) {
+//                    break;
+//                }
+//
+//                lsum += w;
+//            }
+//
+//            if (callback != null) {
+//                callback.ellipsized(left, right);
+//            }
+//
+//            if (preserveLength) {
+//                SpannableString ss = new SpannableString(blank(text, left, right));
+//                copySpansFrom(sp, 0, len, Object.class, ss, 0);
+//                return ss;
+//            } else {
+//                SpannableStringBuilder out = new SpannableStringBuilder(sEllipsis);
+//                out.insert(0, text, 0, left);
+//                out.insert(out.length(), text, right, len);
+//
+//                return out;
+//            }
+//        }
+//    }
+//
+//    private static String blank(CharSequence source, int start, int end) {
+//        int len = source.length();
+//        char[] buf = obtain(len);
+//
+//        if (start != 0) {
+//            getChars(source, 0, start, buf, 0);
+//        }
+//        if (end != len) {
+//            getChars(source, end, len, buf, end);
+//        }
+//
+//        if (start != end) {
+//            buf[start] = '\u2026';
+//
+//            for (int i = start + 1; i < end; i++) {
+//                buf[i] = '\uFEFF';
+//            }
+//        }
+//
+//        String ret = new String(buf, 0, len);
+//        recycle(buf);
+//
+//        return ret;
+//    }
+//
+//    /**
+//     * Converts a CharSequence of the comma-separated form "Andy, Bob,
+//     * Charles, David" that is too wide to fit into the specified width
+//     * into one like "Andy, Bob, 2 more".
+//     *
+//     * @param text the text to truncate
+//     * @param p the Paint with which to measure the text
+//     * @param avail the horizontal width available for the text
+//     * @param oneMore the string for "1 more" in the current locale
+//     * @param more the string for "%d more" in the current locale
+//     */
+//    public static CharSequence commaEllipsize(CharSequence text,
+//                                              TextPaint p, float avail,
+//                                              String oneMore,
+//                                              String more) {
+//        int len = text.length();
+//        char[] buf = new char[len];
+//        TextUtils.getChars(text, 0, len, buf, 0);
+//
+//        int commaCount = 0;
+//        for (int i = 0; i < len; i++) {
+//            if (buf[i] == ',') {
+//                commaCount++;
+//            }
+//        }
+//
+//        float[] wid;
+//
+//        if (text instanceof Spanned) {
+//            Spanned sp = (Spanned) text;
+//            TextPaint temppaint = new TextPaint();
+//            wid = new float[len * 2];
+//
+//            int next;
+//            for (int i = 0; i < len; i = next) {
+//                next = sp.nextSpanTransition(i, len, MetricAffectingSpan.class);
+//
+//                Styled.getTextWidths(p, temppaint, sp, i, next, wid, null);
+//                System.arraycopy(wid, 0, wid, len + i, next - i);
+//            }
+//
+//            System.arraycopy(wid, len, wid, 0, len);
+//        } else {
+//            wid = new float[len];
+//            p.getTextWidths(text, 0, len, wid);
+//        }
+//
+//        int ok = 0;
+//        int okRemaining = commaCount + 1;
+//        String okFormat = "";
+//
+//        int w = 0;
+//        int count = 0;
+//
+//        for (int i = 0; i < len; i++) {
+//            w += wid[i];
+//
+//            if (buf[i] == ',') {
+//                count++;
+//
+//                int remaining = commaCount - count + 1;
+//                float moreWid;
+//                String format;
+//
+//                if (remaining == 1) {
+//                    format = " " + oneMore;
+//                } else {
+//                    format = " " + String.format(more, remaining);
+//                }
+//
+//                moreWid = p.measureText(format);
+//
+//                if (w + moreWid <= avail) {
+//                    ok = i + 1;
+//                    okRemaining = remaining;
+//                    okFormat = format;
+//                }
+//            }
+//        }
+//
+//        if (w <= avail) {
+//            return text;
+//        } else {
+//            SpannableStringBuilder out = new SpannableStringBuilder(okFormat);
+//            out.insert(0, text, 0, ok);
+//            return out;
+//        }
+//    }
+//
+//    /* package */ static char[] obtain(int len) {
+//        char[] buf;
+//
+//        synchronized (sLock) {
+//            buf = sTemp;
+//            sTemp = null;
+//        }
+//
+//        if (buf == null || buf.length < len)
+//            buf = new char[ArrayUtils.idealCharArraySize(len)];
+//
+//        return buf;
+//    }
+//
+//    /* package */ static void recycle(char[] temp) {
+//        if (temp.length > 1000)
+//            return;
+//
+//        synchronized (sLock) {
+//            sTemp = temp;
+//        }
+//    }
+//
+//    /**
+//     * Html-encode the string.
+//     * @param s the string to be encoded
+//     * @return the encoded string
+//     */
+//    public static String htmlEncode(String s) {
+//        StringBuilder sb = new StringBuilder();
+//        char c;
+//        for (int i = 0; i < s.length(); i++) {
+//            c = s.charAt(i);
+//            switch (c) {
+//            case '<':
+//                sb.append("&lt;"); //$NON-NLS-1$
+//                break;
+//            case '>':
+//                sb.append("&gt;"); //$NON-NLS-1$
+//                break;
+//            case '&':
+//                sb.append("&amp;"); //$NON-NLS-1$
+//                break;
+//            case '\'':
+//                sb.append("&apos;"); //$NON-NLS-1$
+//                break;
+//            case '"':
+//                sb.append("&quot;"); //$NON-NLS-1$
+//                break;
+//            default:
+//                sb.append(c);
+//            }
+//        }
+//        return sb.toString();
+//    }
+//
+//    /**
+//     * Returns a CharSequence concatenating the specified CharSequences,
+//     * retaining their spans if any.
+//     */
+//    public static CharSequence concat(CharSequence... text) {
+//        if (text.length == 0) {
+//            return "";
+//        }
+//
+//        if (text.length == 1) {
+//            return text[0];
+//        }
+//
+//        boolean spanned = false;
+//        for (int i = 0; i < text.length; i++) {
+//            if (text[i] instanceof Spanned) {
+//                spanned = true;
+//                break;
+//            }
+//        }
+//
+//        StringBuilder sb = new StringBuilder();
+//        for (int i = 0; i < text.length; i++) {
+//            sb.append(text[i]);
+//        }
+//
+//        if (!spanned) {
+//            return sb.toString();
+//        }
+//
+//        SpannableString ss = new SpannableString(sb);
+//        int off = 0;
+//        for (int i = 0; i < text.length; i++) {
+//            int len = text[i].length();
+//
+//            if (text[i] instanceof Spanned) {
+//                copySpansFrom((Spanned) text[i], 0, len, Object.class, ss, off);
+//            }
+//
+//            off += len;
+//        }
+//
+//        return new SpannedString(ss);
+//    }
+//
+//    /**
+//     * Returns whether the given CharSequence contains any printable characters.
+//     */
+//    public static boolean isGraphic(CharSequence str) {
+//        final int len = str.length();
+//        for (int i=0; i<len; i++) {
+//            int gc = Character.getType(str.charAt(i));
+//            if (gc != Character.CONTROL
+//                    && gc != Character.FORMAT
+//                    && gc != Character.SURROGATE
+//                    && gc != Character.UNASSIGNED
+//                    && gc != Character.LINE_SEPARATOR
+//                    && gc != Character.PARAGRAPH_SEPARATOR
+//                    && gc != Character.SPACE_SEPARATOR) {
+//                return true;
+//            }
+//        }
+//        return false;
+//    }
+//
+//    /**
+//     * Returns whether this character is a printable character.
+//     */
+//    public static boolean isGraphic(char c) {
+//        int gc = Character.getType(c);
+//        return     gc != Character.CONTROL
+//                && gc != Character.FORMAT
+//                && gc != Character.SURROGATE
+//                && gc != Character.UNASSIGNED
+//                && gc != Character.LINE_SEPARATOR
+//                && gc != Character.PARAGRAPH_SEPARATOR
+//                && gc != Character.SPACE_SEPARATOR;
+//    }
+//
+//    /**
+//     * Returns whether the given CharSequence contains only digits.
+//     */
+//    public static boolean isDigitsOnly(CharSequence str) {
+//        final int len = str.length();
+//        for (int i = 0; i < len; i++) {
+//            if (!Character.isDigit(str.charAt(i))) {
+//                return false;
+//            }
+//        }
+//        return true;
+//    }
+//
+//    /**
+//     * Capitalization mode for {@link #getCapsMode}: capitalize all
+//     * characters.  This value is explicitly defined to be the same as
+//     * {@link InputType#TYPE_TEXT_FLAG_CAP_CHARACTERS}.
+//     */
+//    public static final int CAP_MODE_CHARACTERS
+//            = InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS;
+//
+//    /**
+//     * Capitalization mode for {@link #getCapsMode}: capitalize the first
+//     * character of all words.  This value is explicitly defined to be the same as
+//     * {@link InputType#TYPE_TEXT_FLAG_CAP_WORDS}.
+//     */
+//    public static final int CAP_MODE_WORDS
+//            = InputType.TYPE_TEXT_FLAG_CAP_WORDS;
+//
+//    /**
+//     * Capitalization mode for {@link #getCapsMode}: capitalize the first
+//     * character of each sentence.  This value is explicitly defined to be the same as
+//     * {@link InputType#TYPE_TEXT_FLAG_CAP_SENTENCES}.
+//     */
+//    public static final int CAP_MODE_SENTENCES
+//            = InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
+//
+//    /**
+//     * Determine what caps mode should be in effect at the current offset in
+//     * the text.  Only the mode bits set in <var>reqModes</var> will be
+//     * checked.  Note that the caps mode flags here are explicitly defined
+//     * to match those in {@link InputType}.
+//     *
+//     * @param cs The text that should be checked for caps modes.
+//     * @param off Location in the text at which to check.
+//     * @param reqModes The modes to be checked: may be any combination of
+//     * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and
+//     * {@link #CAP_MODE_SENTENCES}.
+//     *
+//     * @return Returns the actual capitalization modes that can be in effect
+//     * at the current position, which is any combination of
+//     * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and
+//     * {@link #CAP_MODE_SENTENCES}.
+//     */
+//    public static int getCapsMode(CharSequence cs, int off, int reqModes) {
+//        int i;
+//        char c;
+//        int mode = 0;
+//
+//        if ((reqModes&CAP_MODE_CHARACTERS) != 0) {
+//            mode |= CAP_MODE_CHARACTERS;
+//        }
+//        if ((reqModes&(CAP_MODE_WORDS|CAP_MODE_SENTENCES)) == 0) {
+//            return mode;
+//        }
+//
+//        // Back over allowed opening punctuation.
+//
+//        for (i = off; i > 0; i--) {
+//            c = cs.charAt(i - 1);
+//
+//            if (c != '"' && c != '\'' &&
+//                Character.getType(c) != Character.START_PUNCTUATION) {
+//                break;
+//            }
+//        }
+//
+//        // Start of paragraph, with optional whitespace.
+//
+//        int j = i;
+//        while (j > 0 && ((c = cs.charAt(j - 1)) == ' ' || c == '\t')) {
+//            j--;
+//        }
+//        if (j == 0 || cs.charAt(j - 1) == '\n') {
+//            return mode | CAP_MODE_WORDS;
+//        }
+//
+//        // Or start of word if we are that style.
+//
+//        if ((reqModes&CAP_MODE_SENTENCES) == 0) {
+//            if (i != j) mode |= CAP_MODE_WORDS;
+//            return mode;
+//        }
+//
+//        // There must be a space if not the start of paragraph.
+//
+//        if (i == j) {
+//            return mode;
+//        }
+//
+//        // Back over allowed closing punctuation.
+//
+//        for (; j > 0; j--) {
+//            c = cs.charAt(j - 1);
+//
+//            if (c != '"' && c != '\'' &&
+//                Character.getType(c) != Character.END_PUNCTUATION) {
+//                break;
+//            }
+//        }
+//
+//        if (j > 0) {
+//            c = cs.charAt(j - 1);
+//
+//            if (c == '.' || c == '?' || c == '!') {
+//                // Do not capitalize if the word ends with a period but
+//                // also contains a period, in which case it is an abbreviation.
+//
+//                if (c == '.') {
+//                    for (int k = j - 2; k >= 0; k--) {
+//                        c = cs.charAt(k);
+//
+//                        if (c == '.') {
+//                            return mode;
+//                        }
+//
+//                        if (!Character.isLetter(c)) {
+//                            break;
+//                        }
+//                    }
+//                }
+//
+//                return mode | CAP_MODE_SENTENCES;
+//            }
+//        }
+//
+//        return mode;
+//    }
+//
+//    private static Object sLock = new Object();
+//    private static char[] sTemp = null;
+}
diff --git a/src/com/transage/privatespace/vcard/text/TextWatcher.java b/src/com/transage/privatespace/vcard/text/TextWatcher.java
new file mode 100755
index 0000000..4ce03de
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/text/TextWatcher.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.text;
+
+/**
+ * When an object of a type is attached to an Editable, its methods will
+ * be called when the text is changed.
+ */
+public interface TextWatcher extends NoCopySpan {
+    /**
+     * This method is called to notify you that, within <code>s</code>,
+     * the <code>count</code> characters beginning at <code>start</code>
+     * are about to be replaced by new text with length <code>after</code>.
+     * It is an error to attempt to make changes to <code>s</code> from
+     * this callback.
+     */
+    public void beforeTextChanged(CharSequence s, int start,
+                                  int count, int after);
+    /**
+     * This method is called to notify you that, within <code>s</code>,
+     * the <code>count</code> characters beginning at <code>start</code>
+     * have just replaced old text that had length <code>before</code>.
+     * It is an error to attempt to make changes to <code>s</code> from
+     * this callback.
+     */
+    public void onTextChanged(CharSequence s, int start, int before, int count);
+
+    /**
+     * This method is called to notify you that, somewhere within
+     * <code>s</code>, the text has been changed.
+     * It is legitimate to make further changes to <code>s</code> from
+     * this callback, but be careful not to get yourself into an infinite
+     * loop, because any changes you make will cause this method to be
+     * called again recursively.
+     * (You are not told where the change took place because other
+     * afterTextChanged() methods may already have made other changes
+     * and invalidated the offsets.  But if you need to know here,
+     * you can use {@link Spannable#setSpan} in {@link #onTextChanged}
+     * to mark your place and then look up from here where the span
+     * ended up.
+     */
+    public void afterTextChanged(Editable s);
+}
diff --git a/src/com/transage/privatespace/vcard/util/ArrayUtils.java b/src/com/transage/privatespace/vcard/util/ArrayUtils.java
new file mode 100755
index 0000000..0ae0aed
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/util/ArrayUtils.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.util;
+
+import java.lang.reflect.Array;
+
+// XXX these should be changed to reflect the actual memory allocator we use.
+// it looks like right now objects want to be powers of 2 minus 8
+// and the array size eats another 4 bytes
+
+/**
+ * ArrayUtils contains some methods that you can call to find out
+ * the most efficient increments by which to grow arrays.
+ */
+public class ArrayUtils
+{
+    private static Object[] EMPTY = new Object[0];
+    private static final int CACHE_SIZE = 73;
+    private static Object[] sCache = new Object[CACHE_SIZE];
+
+    private ArrayUtils() { /* cannot be instantiated */ }
+
+    public static int idealByteArraySize(int need) {
+        for (int i = 4; i < 32; i++)
+            if (need <= (1 << i) - 12)
+                return (1 << i) - 12;
+
+        return need;
+    }
+
+    public static int idealBooleanArraySize(int need) {
+        return idealByteArraySize(need);
+    }
+
+    public static int idealShortArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealCharArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealIntArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealFloatArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealObjectArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealLongArraySize(int need) {
+        return idealByteArraySize(need * 8) / 8;
+    }
+
+    /**
+     * Checks if the beginnings of two byte arrays are equal.
+     *
+     * @param array1 the first byte array
+     * @param array2 the second byte array
+     * @param length the number of bytes to check
+     * @return true if they're equal, false otherwise
+     */
+    public static boolean equals(byte[] array1, byte[] array2, int length) {
+        if (array1 == array2) {
+            return true;
+        }
+        if (array1 == null || array2 == null || array1.length < length || array2.length < length) {
+            return false;
+        }
+        for (int i = 0; i < length; i++) {
+            if (array1[i] != array2[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns an empty array of the specified type.  The intent is that
+     * it will return the same empty array every time to avoid reallocation,
+     * although this is not guaranteed.
+     */
+    public static <T> T[] emptyArray(Class<T> kind) {
+        if (kind == Object.class) {
+            return (T[]) EMPTY;
+        }
+
+        int bucket = ((System.identityHashCode(kind) / 8) & 0x7FFFFFFF) % CACHE_SIZE;
+        Object cache = sCache[bucket];
+
+        if (cache == null || cache.getClass().getComponentType() != kind) {
+            cache = Array.newInstance(kind, 0);
+            sCache[bucket] = cache;
+
+            // Log.e("cache", "new empty " + kind.getName() + " at " + bucket);
+        }
+
+        return (T[]) cache;
+    }
+
+    /**
+     * Checks that value is present as at least one of the elements of the array.
+     * @param array the array to check in
+     * @param value the value to check for
+     * @return true if the value is present in the array
+     */
+    public static <T> boolean contains(T[] array, T value) {
+        for (T element : array) {
+            if (element == null) {
+                if (value == null) return true;
+            } else {
+                if (value != null && element.equals(value)) return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/com/transage/privatespace/vcard/util/Log.java b/src/com/transage/privatespace/vcard/util/Log.java
new file mode 100755
index 0000000..07bb2f4
--- /dev/null
+++ b/src/com/transage/privatespace/vcard/util/Log.java
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.transage.privatespace.vcard.util;
+
+//import com.android.internal.os.RuntimeInit;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * API for sending log output.
+ *
+ * <p>Generally, use the Log.v() Log.d() Log.i() Log.w() and Log.e()
+ * methods.
+ *
+ * <p>The order in terms of verbosity, from least to most is
+ * ERROR, WARN, INFO, DEBUG, VERBOSE.  Verbose should never be compiled
+ * into an application except during development.  Debug logs are compiled
+ * in but stripped at runtime.  Error, warning and info logs are always kept.
+ *
+ * <p><b>Tip:</b> A good convention is to declare a <code>TAG</code> constant
+ * in your class:
+ *
+ * <pre>private static final String TAG = "MyActivity";</pre>
+ *
+ * and use that in subsequent calls to the log methods.
+ * </p>
+ *
+ * <p><b>Tip:</b> Don't forget that when you make a call like
+ * <pre>Log.v(TAG, "index=" + i);</pre>
+ * that when you're building the string to pass into Log.d, the compiler uses a
+ * StringBuilder and at least three allocations occur: the StringBuilder
+ * itself, the buffer, and the String object.  Realistically, there is also
+ * another buffer allocation and copy, and even more pressure on the gc.
+ * That means that if your log message is filtered out, you might be doing
+ * significant work and incurring significant overhead.
+ */
+public final class Log {
+
+    private static final Logger logger = Logger.getLogger(Log.class.getName());
+
+    /**
+     * Priority constant for the println method; use Log.v.
+     */
+    public static final int VERBOSE = 2;
+
+    /**
+     * Priority constant for the println method; use Log.d.
+     */
+    public static final int DEBUG = 3;
+
+    /**
+     * Priority constant for the println method; use Log.i.
+     */
+    public static final int INFO = 4;
+
+    /**
+     * Priority constant for the println method; use Log.w.
+     */
+    public static final int WARN = 5;
+
+    /**
+     * Priority constant for the println method; use Log.e.
+     */
+    public static final int ERROR = 6;
+
+    /**
+     * Priority constant for the println method.
+     */
+    public static final int ASSERT = 7;
+
+    private Log() {
+    }
+
+    /**
+     * Send a {@link #VERBOSE} log message.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    public static int v(String tag, String msg) {
+        return println(VERBOSE, tag, msg);
+    }
+
+    /**
+     * Send a {@link #VERBOSE} log message and log the exception.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr An exception to log
+     */
+    public static int v(String tag, String msg, Throwable tr) {
+        return println(VERBOSE, tag, msg + '\n' + getStackTraceString(tr));
+    }
+
+    /**
+     * Send a {@link #DEBUG} log message.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    public static int d(String tag, String msg) {
+        return println(DEBUG, tag, msg);
+    }
+
+    /**
+     * Send a {@link #DEBUG} log message and log the exception.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr An exception to log
+     */
+    public static int d(String tag, String msg, Throwable tr) {
+        return println(DEBUG, tag, msg + '\n' + getStackTraceString(tr));
+    }
+
+    /**
+     * Send an {@link #INFO} log message.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    public static int i(String tag, String msg) {
+        return println(INFO, tag, msg);
+    }
+
+    /**
+     * Send a {@link #INFO} log message and log the exception.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr An exception to log
+     */
+    public static int i(String tag, String msg, Throwable tr) {
+        return println(INFO, tag, msg + '\n' + getStackTraceString(tr));
+    }
+
+    /**
+     * Send a {@link #WARN} log message.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    public static int w(String tag, String msg) {
+        return println(WARN, tag, msg);
+    }
+
+    /**
+     * Send a {@link #WARN} log message and log the exception.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr An exception to log
+     */
+    public static int w(String tag, String msg, Throwable tr) {
+        return println(WARN, tag, msg + '\n' + getStackTraceString(tr));
+    }
+
+    /**
+     * Checks to see whether or not a log for the specified tag is loggable at the specified level.
+     * 
+     *  The default level of any tag is set to INFO. This means that any level above and including
+     *  INFO will be logged. Before you make any calls to a logging method you should check to see
+     *  if your tag should be logged. You can change the default level by setting a system property:
+     *      'setprop log.tag.&lt;YOUR_LOG_TAG> &lt;LEVEL>'
+     *  Where level is either VERBOSE, DEBUG, INFO, WARN, ERROR, ASSERT, or SUPPRESS. SUPRESS will 
+     *  turn off all logging for your tag. You can also create a local.prop file that with the
+     *  following in it:
+     *      'log.tag.&lt;YOUR_LOG_TAG>=&lt;LEVEL>'
+     *  and place that in /data/local.prop.
+     *  
+     * @param tag The tag to check.
+     * @param level The level to check.
+     * @return Whether or not that this is allowed to be logged.
+     * @throws IllegalArgumentException is thrown if the tag.length() > 23.
+     */
+    public static boolean isLoggable(String tag, int level) {
+        return true;
+    }
+        
+    /*
+     * Send a {@link #WARN} log message and log the exception.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param tr An exception to log
+     */
+    public static int w(String tag, Throwable tr) {
+        return println(WARN, tag, getStackTraceString(tr));
+    }
+
+    /**
+     * Send an {@link #ERROR} log message.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    public static int e(String tag, String msg) {
+        return println(ERROR, tag, msg);
+    }
+
+    /**
+     * Send a {@link #ERROR} log message and log the exception.
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr An exception to log
+     */
+    public static int e(String tag, String msg, Throwable tr) {
+        int r = println(ERROR, tag, msg + '\n' + getStackTraceString(tr));
+//        RuntimeInit.reportException(tag, tr, false);  // asynchronous
+        return r;
+    }
+
+    /**
+     * Handy function to get a loggable stack trace from a Throwable
+     * @param tr An exception to log
+     */
+    public static String getStackTraceString(Throwable tr) {
+        if (tr == null) {
+            return "";
+        }
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        tr.printStackTrace(pw);
+        return sw.toString();
+    }
+
+    /**
+     * Low-level logging call.
+     * @param priority The priority/type of this log message
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *        the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @return The number of bytes written.
+     */
+    public static int println(int priority, String tag, String msg) {
+        logger.logp(prioToLevel(priority), tag, null, msg);
+        return 1;
+    }
+
+    private static Level prioToLevel(int priority) {
+        switch (priority) {
+            case ASSERT: return Level.ALL;
+            case DEBUG: return Level.FINEST;
+            case ERROR: return Level.SEVERE;
+            case INFO: return Level.INFO;
+            case VERBOSE: return Level.ALL;
+            case WARN: return Level.WARNING;
+        }
+        return Level.WARNING;
+    }
+}
