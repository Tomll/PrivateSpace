diff --git a/Android.mk b/Android.mk
index 122da74..203b626 100755
--- a/Android.mk
+++ b/Android.mk
@@ -8,7 +8,8 @@ LOCAL_STATIC_JAVA_LIBRARIES := \
     android-support-v7-recyclerview \
     android-support-v7-appcompat \
     android-support-design \
-    commons-codec-1.4
+    commons-codec-1.4 \
+    glide-3.7.0
 
 LOCAL_RESOURCE_DIR = $(LOCAL_PATH)/res \
     frameworks/support/v7/recyclerview/res \
@@ -31,7 +32,9 @@ include $(CLEAR_VARS)
 ###LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=supportv7appcompat:libs/android-support-v7-appcompat.jar
 ###LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=supportv7recyclerview:libs/android-support-v7-recyclerview.jar
 ###LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=supportdesign:libs/android-support-design.jar
-LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :=libs/commons-codec-1.4.jar
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :=commons-codec-1.4:libs/commons-codec-1.4.jar
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +=glide-3.7.0:libs/glide-3.7.0.jar
+
 include $(BUILD_MULTI_PREBUILT)
 include $(call all-makefiles-under,$(LOCAL_PATH))
 
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index da01bc4..44116d2 100755
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -48,6 +48,11 @@
         <activity
             android:name=".activity.AddApp"
             android:screenOrientation="portrait"/>
+        <activity android:name=".gallery.photozoom.Album"/>
+        <activity android:name=".gallery.photozoom.Folders"/>
+        <activity android:name=".gallery.photozoom.Gallery"/>
+        <activity android:name=".gallery.activity.PrivateAlbum"/>
+		<activity android:name=".gallery.activity.GalleryMainActivity"/>
         <activity
             android:name=".activity.SecurityQuestion"
             android:screenOrientation="portrait"/>
diff --git a/libs/glide-3.7.0.jar b/libs/glide-3.7.0.jar
new file mode 100755
index 0000000..9ef5cb6
Binary files /dev/null and b/libs/glide-3.7.0.jar differ
diff --git a/res/drawable/del_unfocused.png b/res/drawable/del_unfocused.png
new file mode 100755
index 0000000..367438d
Binary files /dev/null and b/res/drawable/del_unfocused.png differ
diff --git a/res/drawable/plugin_camera_album_back.png b/res/drawable/plugin_camera_album_back.png
new file mode 100755
index 0000000..c0b723d
Binary files /dev/null and b/res/drawable/plugin_camera_album_back.png differ
diff --git a/res/drawable/plugin_camera_albumbackground.xml b/res/drawable/plugin_camera_albumbackground.xml
new file mode 100755
index 0000000..a6bae06
--- /dev/null
+++ b/res/drawable/plugin_camera_albumbackground.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector
+  xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_focused="true" android:drawable="@drawable/plugin_camera_choose_back" />
+    <item android:state_pressed="true" android:drawable="@drawable/plugin_camera_choose_back" />
+    <item android:state_selected="true" android:drawable="@drawable/plugin_camera_choose_back" />
+	
+</selector>
\ No newline at end of file
diff --git a/res/drawable/plugin_camera_choose_back.png b/res/drawable/plugin_camera_choose_back.png
new file mode 100755
index 0000000..97603c4
Binary files /dev/null and b/res/drawable/plugin_camera_choose_back.png differ
diff --git a/res/drawable/plugin_camera_filenum.png b/res/drawable/plugin_camera_filenum.png
new file mode 100755
index 0000000..783355b
Binary files /dev/null and b/res/drawable/plugin_camera_filenum.png differ
diff --git a/res/drawable/plugin_camera_no_pictures.png b/res/drawable/plugin_camera_no_pictures.png
new file mode 100755
index 0000000..27d79fb
Binary files /dev/null and b/res/drawable/plugin_camera_no_pictures.png differ
diff --git a/res/drawable/plugin_camera_pic_choose_selector.xml b/res/drawable/plugin_camera_pic_choose_selector.xml
new file mode 100755
index 0000000..81d842a
--- /dev/null
+++ b/res/drawable/plugin_camera_pic_choose_selector.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:Android="http://schemas.android.com/apk/res/android">
+	
+    <item Android:drawable="@drawable/plugin_camera_choose_back" Android:state_checked="true"/>
+ <!-- focused -->
+    <item Android:drawable="@color/none_color"/>
+ <!-- default -->
+
+</selector>
\ No newline at end of file
diff --git a/res/drawable/selector0.xml b/res/drawable/selector0.xml
new file mode 100755
index 0000000..0b67ccf
--- /dev/null
+++ b/res/drawable/selector0.xml
@@ -0,0 +1 @@
+<?xml version="1.0" encoding="utf-8"?><selector xmlns:android="http://schemas.android.com/apk/res/android">    <item android:drawable="@color/lightgrey" android:state_pressed="true"/></selector>
\ No newline at end of file
diff --git a/res/drawable/take_photo.png b/res/drawable/take_photo.png
new file mode 100755
index 0000000..b1273f5
Binary files /dev/null and b/res/drawable/take_photo.png differ
diff --git a/res/layout/activity_album.xml b/res/layout/activity_album.xml
new file mode 100755
index 0000000..bcbc8c5
--- /dev/null
+++ b/res/layout/activity_album.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:background="@color/lightblack"
+              android:orientation="vertical">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="48dp"
+        android:background="@color/lightblack"
+        android:gravity="center_vertical">
+
+        <ImageButton
+            android:id="@+id/button_back"
+            android:layout_width="44dp"
+            android:layout_height="match_parent"
+            android:background="@drawable/selector0"
+            android:src="@mipmap/button_back"/>
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerInParent="true"
+            android:text="@string/select_photo"
+            android:textColor="@color/white"
+            android:textSize="20sp"/>
+        <CheckBox
+            android:id="@+id/checkbox_select_all"
+            android:layout_width="wrap_content"
+            android:layout_alignParentEnd="true"
+            android:layout_centerVertical="true"
+            android:text="@string/select_all"
+            android:clickable="true"
+            android:layout_marginEnd="15dp"
+            android:button="@null"
+            android:textColor="@color/white"
+            android:layout_height="wrap_content"/>
+    </RelativeLayout>
+
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <GridView
+            android:id="@+id/album_GridView"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:horizontalSpacing="2dp"
+            android:numColumns="4"
+            android:verticalSpacing="2dp"/>
+
+            <Button
+                android:id="@+id/button_add"
+                android:layout_width="match_parent"
+                android:layout_height="50dp"
+                android:layout_gravity="bottom"
+                android:layout_marginBottom="10dp"
+                android:layout_marginEnd="70dp"
+                android:layout_marginStart="70dp"
+                android:textSize="16sp"
+                android:text="@string/encrypt"/>
+
+    </FrameLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/res/layout/activity_folders.xml b/res/layout/activity_folders.xml
new file mode 100755
index 0000000..d007849
--- /dev/null
+++ b/res/layout/activity_folders.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:background="@color/lightblack">
+
+    <RelativeLayout
+        android:id="@+id/headview"
+        android:layout_width="match_parent"
+        android:layout_height="48dp"
+        android:background="@color/lightblack"
+        android:gravity="center_vertical">
+
+        <ImageButton
+            android:id="@+id/button_back"
+            android:layout_width="44dp"
+            android:layout_height="match_parent"
+            android:background="@drawable/selector0"
+            android:src="@mipmap/button_back"/>
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerInParent="true"
+            android:text="@string/select_album"
+            android:textColor="@color/white"
+            android:textSize="20sp"/>
+    </RelativeLayout>
+
+    <GridView
+        android:id="@+id/fileGridView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_below="@id/headview"
+        android:layout_centerInParent="true"
+        android:horizontalSpacing="10dp"
+        android:numColumns="2"
+        android:verticalSpacing="10dp"/>
+
+</RelativeLayout>
\ No newline at end of file
diff --git a/res/layout/activity_gallery.xml b/res/layout/activity_gallery.xml
new file mode 100755
index 0000000..63876f4
--- /dev/null
+++ b/res/layout/activity_gallery.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/backcolor"
+    android:orientation="vertical" >
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="48dp"
+        android:background="@color/lightblack" >
+
+        <ImageButton
+            android:id="@+id/button_back"
+            android:layout_width="44dp"
+            android:layout_height="match_parent"
+            android:background="@drawable/selector0"
+            android:onClick="onClick"
+            android:src="@mipmap/button_back" />
+
+        <ImageButton
+            android:id="@+id/button_del"
+            android:layout_width="44dp"
+            android:layout_height="match_parent"
+            android:layout_alignParentRight="true"
+            android:layout_alignParentTop="true"
+            android:background="@drawable/selector0"
+            android:onClick="onClick"
+            android:src="@drawable/del_unfocused" />
+    </RelativeLayout>
+
+    <transage.com.aes_encrypt.photozoom.ViewPagerFixed
+        android:id="@+id/gallery01"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:unselectedAlpha="1" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/res/layout/activity_private_album.xml b/res/layout/activity_private_album.xml
new file mode 100755
index 0000000..a88e76a
--- /dev/null
+++ b/res/layout/activity_private_album.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:background="@color/lightblack"
+              android:orientation="vertical">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="48dp"
+        android:background="@color/lightblack"
+        android:gravity="center_vertical">
+
+        <ImageButton
+            android:id="@+id/button_back"
+            android:layout_width="44dp"
+            android:layout_height="match_parent"
+            android:background="@drawable/selector0"
+            android:src="@mipmap/button_back"/>
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerInParent="true"
+            android:text="@string/private_album"
+            android:textColor="@color/white"
+            android:textSize="20sp"/>
+
+        <CheckBox
+            android:id="@+id/checkbox_select_all"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentEnd="true"
+            android:layout_centerVertical="true"
+            android:layout_marginEnd="15dp"
+            android:button="@null"
+            android:clickable="true"
+            android:text="@string/select_all"
+            android:textColor="@color/white"/>
+    </RelativeLayout>
+
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <GridView
+            android:id="@+id/album_GridView"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:horizontalSpacing="2dp"
+            android:numColumns="4"
+            android:verticalSpacing="2dp"/>
+
+        <Button
+            android:id="@+id/button_min"
+            android:layout_width="match_parent"
+            android:layout_height="50dp"
+            android:layout_gravity="bottom"
+            android:layout_marginBottom="10dp"
+            android:layout_marginEnd="70dp"
+            android:layout_marginStart="70dp"
+            android:textSize="16sp"
+            android:text="@string/decrypt"/>
+    </FrameLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/res/layout/gallery_activity_main.xml b/res/layout/gallery_activity_main.xml
new file mode 100755
index 0000000..3e1cda9
--- /dev/null
+++ b/res/layout/gallery_activity_main.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/activity_main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center"
+    android:orientation="vertical"
+    android:background="@color/lightblack"
+    android:padding="30dp">
+
+
+    <Button
+        android:id="@+id/button_priv_album"
+        android:layout_width="match_parent"
+        android:layout_height="60dp"
+        android:gravity="center"
+        android:text="@string/private_album"/>
+
+    <Button
+        android:id="@+id/button_add_priv_photo"
+        android:layout_width="match_parent"
+        android:layout_height="60dp"
+        android:layout_marginTop="50dp"
+        android:gravity="center"
+        android:text="@string/add_private_photo"/>
+
+
+</LinearLayout>
diff --git a/res/layout/item_album_gridview.xml b/res/layout/item_album_gridview.xml
new file mode 100755
index 0000000..8de3bef
--- /dev/null
+++ b/res/layout/item_album_gridview.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="300px" >
+
+    <ImageView
+        android:id="@+id/image_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_gravity="center"
+        android:adjustViewBounds="true"
+        android:background="@drawable/plugin_camera_no_pictures"
+        android:scaleType="centerCrop" />
+
+    <RelativeLayout
+        android:id="@+id/toggle"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" >
+
+        <ToggleButton
+            android:id="@+id/toggle_button"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:background="@drawable/plugin_camera_pic_choose_selector"
+            android:textOff="@null"
+            android:textOn="@null"
+            android:checked="false" />
+
+        <CheckBox
+            android:id="@+id/choosedbt"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentRight="true"
+            android:layout_alignParentTop="true" />
+    </RelativeLayout>
+
+</RelativeLayout>
\ No newline at end of file
diff --git a/res/layout/item_folders_gridview.xml b/res/layout/item_folders_gridview.xml
new file mode 100755
index 0000000..647616b
--- /dev/null
+++ b/res/layout/item_folders_gridview.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <FrameLayout
+        android:id="@+id/file"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" >
+
+        <ImageView
+            android:id="@+id/file_back"
+            android:layout_width="130dp"
+            android:layout_height="130dp"
+            android:layout_gravity="center"
+            android:adjustViewBounds="true"
+            android:background="@drawable/plugin_camera_album_back"
+            android:scaleType="centerCrop" />
+
+        <ImageView
+            android:id="@+id/file_image"
+            android:layout_width="100dp"
+            android:layout_height="100dp"
+            android:layout_gravity="center"
+            android:adjustViewBounds="true"
+            android:background="@drawable/plugin_camera_albumbackground"
+            android:scaleType="centerCrop" />
+
+        <ImageView
+            android:id="@+id/choose_back"
+            android:layout_width="100dp"
+            android:layout_height="100dp"
+            android:layout_gravity="center"
+            android:adjustViewBounds="true"
+            android:background="@drawable/plugin_camera_choose_back"
+            android:scaleType="centerCrop"
+            android:visibility="gone" />
+
+        <TextView
+            android:id="@+id/filenum"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom|center_horizontal"
+            android:background="@drawable/plugin_camera_filenum"
+            android:gravity="center"
+            android:textColor="#000000"
+            android:textSize="16sp" />
+    </FrameLayout>
+
+    <TextView
+        android:id="@+id/name"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:layout_marginTop="20dp"
+        android:singleLine="true"
+        android:textColor="@color/white"
+        android:textSize="15sp" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/res/layout/item_private_album_gridview.xml b/res/layout/item_private_album_gridview.xml
new file mode 100755
index 0000000..8de3bef
--- /dev/null
+++ b/res/layout/item_private_album_gridview.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="300px" >
+
+    <ImageView
+        android:id="@+id/image_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_gravity="center"
+        android:adjustViewBounds="true"
+        android:background="@drawable/plugin_camera_no_pictures"
+        android:scaleType="centerCrop" />
+
+    <RelativeLayout
+        android:id="@+id/toggle"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" >
+
+        <ToggleButton
+            android:id="@+id/toggle_button"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:background="@drawable/plugin_camera_pic_choose_selector"
+            android:textOff="@null"
+            android:textOn="@null"
+            android:checked="false" />
+
+        <CheckBox
+            android:id="@+id/choosedbt"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentRight="true"
+            android:layout_alignParentTop="true" />
+    </RelativeLayout>
+
+</RelativeLayout>
\ No newline at end of file
diff --git a/res/layout/item_published_gridview.xml b/res/layout/item_published_gridview.xml
new file mode 100755
index 0000000..e684dca
--- /dev/null
+++ b/res/layout/item_published_gridview.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical">
+
+    <ImageView
+        android:id="@+id/item_grida_image"
+        android:layout_width="79dp"
+        android:layout_height="53dp"
+        android:layout_gravity="center"
+        android:scaleType="fitXY"
+        android:src="@drawable/take_photo">
+    </ImageView>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/res/mipmap-xxhdpi/button_back.png b/res/mipmap-xxhdpi/button_back.png
new file mode 100755
index 0000000..985878e
Binary files /dev/null and b/res/mipmap-xxhdpi/button_back.png differ
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 2ce879f..21a8170 100755
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -52,5 +52,14 @@
     <string name="cancel">取消</string>
     <string name="relieve_selected_private_people">解除选中的私密联系人？</string>
     <string name="relieve_private">解除私密</string>
+    <string name="private_gallery">私密图库</string>
+    <string name="select_album">选择相册</string>
+    <string name="select_photo">选择图片</string>
+    <string name="select_all">全选</string>
+    <string name="deselect_all">取消全选</string>
+    <string name="encrypt">加密</string>
+    <string name="decrypt">解密</string>
+    <string name="private_album">私密相册</string>
+    <string name="add_private_photo">添加私密图片</string>
 
 </resources>
diff --git a/src/com/transage/privatespace/activity/Main.java b/src/com/transage/privatespace/activity/Main.java
index a8e6af7..0c018e8 100755
--- a/src/com/transage/privatespace/activity/Main.java
+++ b/src/com/transage/privatespace/activity/Main.java
@@ -17,6 +17,7 @@ import com.transage.privatespace.R;
 import com.transage.privatespace.adapter.AppRecyclerAdapter;
 import com.transage.privatespace.bean.AppInfo;
 import com.transage.privatespace.database.DatabaseAdapter;
+import com.transage.privatespace.gallery.activity.GalleryMainActivity;
 
 import java.util.ArrayList;
 
@@ -84,11 +85,16 @@ public class Main extends Activity implements View.OnClickListener, AppRecyclerA
         packageManager = getPackageManager();
         appList.clear();
         appList.addAll(mDb.getApps(packageManager));
-        // 最后的"+"
+        //添加最后的"+"
         AppInfo appInfo = new AppInfo();
         appInfo.setAppIcon(getDrawable(R.mipmap.add));
         appInfo.setAppName(getString(R.string.add_app));
         appList.add(appInfo);
+        //添加“私密图库”
+        AppInfo appInfo1 = new AppInfo();
+        appInfo1.setAppIcon(getDrawable(R.mipmap.ic_launcher));
+        appInfo1.setAppName(getString(R.string.private_gallery));
+        appList.add(0,appInfo1);
         recycleAdapter.notifyDataSetChanged();
     }
 
@@ -98,6 +104,9 @@ public class Main extends Activity implements View.OnClickListener, AppRecyclerA
         if (position == appList.size() - 1) { // add
             startActivity(new Intent(Main.this, AddApp.class));
             return;
+        }else if (position == 0){//“私密图库”
+            startActivity(new Intent(Main.this, GalleryMainActivity.class));
+            return;
         }
         if (view.getId() == R.id.iv_appIcon) {
             Intent launchIntent = packageManager.getLaunchIntentForPackage(appList.get(position).getPackageName());
diff --git a/src/com/transage/privatespace/database/DatabaseAdapter.java b/src/com/transage/privatespace/database/DatabaseAdapter.java
index 8793f8d..9e92db5 100755
--- a/src/com/transage/privatespace/database/DatabaseAdapter.java
+++ b/src/com/transage/privatespace/database/DatabaseAdapter.java
@@ -10,10 +10,12 @@ import com.transage.privatespace.bean.AppInfo;
 import com.transage.privatespace.bean.CallRecord;
 import com.transage.privatespace.bean.People;
 import com.transage.privatespace.bean.Sms;
+import com.transage.privatespace.gallery.photozoom.ImageItem;
 
 import java.util.ArrayList;
 import java.util.List;
 
+import android.graphics.Bitmap;
 import android.net.Uri;
 import android.util.Log;
 
@@ -291,6 +293,47 @@ public class DatabaseAdapter {
         insert(PsDatabaseHelper.Tables.CALLRECORD, null, contentValues);
     }
 
+
+    /**
+     * 获取数据库中图片 操作
+     */
+    public ArrayList<ImageItem> getPhoto() {
+        String sql = "SELECT * " + " FROM " + PsDatabaseHelper.Tables.FILES;
+        Log.i(TAG, "sql = " + sql);
+        ArrayList<ImageItem> list = new ArrayList<>();
+        Cursor cursor = query(sql, null);
+        try {
+            if (cursor.moveToFirst()) {
+                do {
+                    ImageItem imageItem = new ImageItem();
+                    imageItem.setImageId(cursor.getString(0));
+                    imageItem.setImagePath(cursor.getString(1));
+                    imageItem.setSize(cursor.getString(3));
+                    imageItem.setDisplayName(cursor.getString(4));
+                    imageItem.setTitle(cursor.getString(5));
+                    imageItem.setDateAdded(cursor.getString(6));
+                    imageItem.setMimeType(cursor.getString(7));
+                    imageItem.setBucketId(cursor.getString(8));
+                    imageItem.setBucket_display_name(cursor.getString(9));
+                    list.add(imageItem);
+                } while (cursor.moveToNext());
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            cursor.close();
+        }
+        return list;
+    }
+
+    public void insertPhoto(ContentValues contentValues) {
+        insert(PsDatabaseHelper.Tables.FILES, null, contentValues);
+    }
+
+    public void deletePhoto(String id) {
+        delete(PsDatabaseHelper.Tables.FILES, PsDatabaseHelper.FilesClumns._ID + "=?", new String[]{id});
+    }
+
     /**
      * 统一封装数据库接口
      */
@@ -309,4 +352,6 @@ public class DatabaseAdapter {
     private int delete(String table, String whereClause, String[] whereArgs) {
         return PsDatabaseHelper.getInstance(mContext).getDatabase(true).delete(table, whereClause, whereArgs);
     }
+
+
 }
diff --git a/src/com/transage/privatespace/database/PsDatabaseHelper.java b/src/com/transage/privatespace/database/PsDatabaseHelper.java
index 8cb00ca..3180db6 100755
--- a/src/com/transage/privatespace/database/PsDatabaseHelper.java
+++ b/src/com/transage/privatespace/database/PsDatabaseHelper.java
@@ -22,6 +22,7 @@ public class PsDatabaseHelper extends SQLiteOpenHelper {
         public static final String CONTACTS = "contacts";
         public static final String SMS = "sms";//wangmeng 20170707 add mms
         public static final String CALLRECORD = "call_record";
+        public static final String FILES = "files";//add by dongrp 20170727
     }
 
     public interface AppsColumns {
@@ -57,6 +58,20 @@ public class PsDatabaseHelper extends SQLiteOpenHelper {
         public static final String DURATION = "duration";
     }
 
+    //add FilesClumns by dongrp 20170727
+    public interface FilesClumns {
+        public static final String _ID = "_id";
+        public static final String _DATA = "_data";
+        public static final String _SOURCE_DATA = "_source_data";
+        public static final String _SIZE = "_size";
+        public static final String _DISPLAY_NAME = "_display_name";
+        public static final String TITLE = "title";
+        public static final String DATE_ADDED = "date_added";
+        public static final String MIME_TYPE = "mime_type";
+        public static final String BUCKET_ID = "bucket_id";
+        public static final String BUCKET_DISPLAY_NAME = "bucket_display_name";
+    }
+
     public PsDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
         super(context, name, factory, version);
         this.mContext = context;
@@ -125,6 +140,22 @@ public class PsDatabaseHelper extends SQLiteOpenHelper {
                 ");";
         Log.i(TAG, "sql = " + sqlCreateCallRecordTable);
         sqLiteDatabase.execSQL(sqlCreateCallRecordTable);
+
+        //执行创建私密文件表 add by dongrp for CreateFilesTable  20170727
+        String sqlCreateFilesTable = "CREATE TABLE IF NOT EXISTS " + Tables.FILES + " (" +
+                FilesClumns._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
+                FilesClumns._DATA + " TEXT, " +
+                FilesClumns._SOURCE_DATA + " TEXT, " +
+                FilesClumns._SIZE + " INTEGER, " +
+                FilesClumns._DISPLAY_NAME + " TEXT, " +
+                FilesClumns.TITLE + " TEXT, " +
+                FilesClumns.DATE_ADDED + " INTEGER, " +
+                FilesClumns.MIME_TYPE + " TEXT, " +
+                FilesClumns.BUCKET_ID + " TEXT, " +
+                FilesClumns.BUCKET_DISPLAY_NAME + " TEXT " +
+                ");";
+        Log.i(TAG, "sql = " + sqlCreateFilesTable);
+        sqLiteDatabase.execSQL(sqlCreateFilesTable);
     }
 
     @Override
diff --git a/src/com/transage/privatespace/gallery/activity/GalleryMainActivity.java b/src/com/transage/privatespace/gallery/activity/GalleryMainActivity.java
new file mode 100755
index 0000000..9077966
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/activity/GalleryMainActivity.java
@@ -0,0 +1,65 @@
+package com.transage.privatespace.gallery.activity;
+
+import android.Manifest;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.Environment;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+
+import com.transage.privatespace.R;
+import com.transage.privatespace.gallery.photozoom.Folders;
+import com.transage.privatespace.gallery.util.AESEncryptionUtil;
+
+/**
+ * Created by dongrp on 2017/7/1.
+ * 私密图库的主界面
+ */
+
+public class GalleryMainActivity extends AppCompatActivity implements View.OnClickListener {
+
+    //private final String SDcardPath = "storage/emulated/0/";
+    private final String SDcardPath = Environment.getExternalStorageDirectory().toString() + "/";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.gallery_activity_main);
+
+        //读写权限
+        int REQUEST_EXTERNAL_STORAGE = 1;
+        String[] PERMISSIONS_STORAGE = {
+                Manifest.permission.READ_EXTERNAL_STORAGE,
+                Manifest.permission.WRITE_EXTERNAL_STORAGE
+        };
+        int permission = ActivityCompat.checkSelfPermission(GalleryMainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        if (permission != PackageManager.PERMISSION_GRANTED) {
+            // We don't have permission so prompt the user
+            ActivityCompat.requestPermissions(GalleryMainActivity.this, PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE);
+        }
+
+        findViewById(R.id.button_priv_album).setOnClickListener(this);
+        findViewById(R.id.button_add_priv_photo).setOnClickListener(this);
+
+    }
+
+    @Override
+    public void onClick(View view) {
+        switch (view.getId()) {
+            case R.id.button_priv_album:
+                startActivity(new Intent(GalleryMainActivity.this, PrivateAlbum.class));
+                break;
+            case R.id.button_add_priv_photo:
+                startActivity(new Intent(GalleryMainActivity.this, Folders.class));
+                break;
+            default:
+                break;
+        }
+    }
+
+
+}
diff --git a/src/com/transage/privatespace/gallery/activity/PrivateAlbum.java b/src/com/transage/privatespace/gallery/activity/PrivateAlbum.java
new file mode 100755
index 0000000..8d8d50d
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/activity/PrivateAlbum.java
@@ -0,0 +1,330 @@
+package com.transage.privatespace.gallery.activity;
+
+import android.app.ProgressDialog;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.res.Configuration;
+import android.media.Image;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.support.annotation.Nullable;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+import android.view.View;
+import android.widget.AbsListView;
+import android.widget.CheckBox;
+import android.widget.GridView;
+import android.widget.ImageView;
+import android.widget.Toast;
+
+import com.bumptech.glide.Glide;
+import com.transage.privatespace.R;
+import com.transage.privatespace.database.DatabaseAdapter;
+import com.transage.privatespace.database.PsDatabaseHelper;
+import com.transage.privatespace.gallery.adapter.PrivateAlbumGridViewAdapter;
+import com.transage.privatespace.gallery.photozoom.ImageItem;
+import com.transage.privatespace.gallery.util.AESEncryptionUtil;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+/**
+ * Created by dongrp on 2017/7/13.
+ * 私密相册界面
+ */
+
+public class PrivateAlbum extends AppCompatActivity implements View.OnClickListener,AbsListView.OnScrollListener {
+    private GridView gridView;
+    private ArrayList<ImageItem> dateList;
+    private PrivateAlbumGridViewAdapter privateAlbumGridViewAdapter;
+    private ExecutorService executorService; //线程池
+    private int mFirstVisibleItem, mVisibleItemCount, mTotalItemCount;
+    private DatabaseAdapter databaseAdapter;
+    private ProgressDialog progressDialog;
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_private_album);
+
+        executorService = Executors.newCachedThreadPool();//创建一个缓存线程池
+        databaseAdapter = new DatabaseAdapter(PrivateAlbum.this);//数据库操作工具类
+
+        findViewById(R.id.checkbox_select_all).setOnClickListener(this);
+        findViewById(R.id.button_back).setOnClickListener(this);
+        findViewById(R.id.button_min).setOnClickListener(this);
+
+//        String PRIV_CAMERA_PATH = "/data/data/" + getPackageName() + "/files/storage/emulated/0/DCIM/Camera/";
+//        dateList = getDirectoryFiles(new File(PRIV_CAMERA_PATH));
+
+        dateList = databaseAdapter.getPhoto();//数据
+        Log.d("PrivateAlbum", "dateList.size():" + dateList.size());
+
+        gridView = (GridView) findViewById(R.id.album_GridView);//组件
+        privateAlbumGridViewAdapter = new PrivateAlbumGridViewAdapter(PrivateAlbum.this, dateList);//适配器
+        gridView.setAdapter(privateAlbumGridViewAdapter);//绑定适配器
+        gridView.setOnScrollListener(this);
+
+    }
+
+
+    public void onScrollStateChanged(AbsListView view, int scrollState) {
+
+        if (scrollState == SCROLL_STATE_IDLE){
+            Log.d("PrivateAlbum", "mScrollState == IDEL ");
+            Log.d("PrivateAlbum", "mFirstVisibleItem: " + mFirstVisibleItem +  "   mVisibleItemCount: " + mVisibleItemCount);
+
+            long l2 = System.currentTimeMillis();
+            List<ImageItem> listImageItem = dateList.subList(mFirstVisibleItem, (mFirstVisibleItem + mVisibleItemCount));
+            ArrayList<File> files = decryptFileListForCache(listImageItem);
+            long l = System.currentTimeMillis();
+            Log.d("PrivateAlbum", "解密当前屏幕图片 耗时:" + (l - l2) + " ms");
+
+            long l3 = System.currentTimeMillis();
+            for (int i=0 ; i<mVisibleItemCount;i++){
+                ImageView imageView = (ImageView) gridView.getChildAt(i).findViewById(R.id.image_view);
+                Glide.with(PrivateAlbum.this).load(files.get(i)).into(imageView);
+            }
+            long l4 = System.currentTimeMillis();
+            Log.d("PrivateAlbum", "for 循环加载耗时:" + (l4 - l3) + " ms");
+
+        }
+
+    }
+
+    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+        mFirstVisibleItem = firstVisibleItem;
+        mVisibleItemCount = visibleItemCount;
+        mTotalItemCount = totalItemCount;
+    }
+
+
+    //清空缓存文件夹
+    private void delectCacheDirectory(File file) {
+        File flist[] = file.listFiles();
+        if (flist == null || flist.length == 0) {
+            return;
+        }
+        for (File f : flist) {
+            if (f.isDirectory()) {
+                //这里将列出所有的文件夹
+                delectCacheDirectory(f);
+            } else {
+                //这里将列出所有的文件
+                //Log.d("PrivateAlbumGridViewAda", f.getAbsolutePath());
+                f.delete();//删除文件
+            }
+        }
+        return;
+    }
+
+    boolean result1 = true ;
+    //解密当前屏幕显示的文件
+    public ArrayList<File> decryptFileListForCache(final List<ImageItem> arrayList) {
+        delectCacheDirectory(new File("/data/data/" + getPackageName() + "/files/cache/"));
+
+        ArrayList<File> list = new ArrayList<>();
+        list.clear();
+        List<Future<File>> listFuture = new ArrayList<>();
+        listFuture.clear();
+
+        for (ImageItem item : arrayList) {
+            final String privImagePath = item.getImagePath();
+            String fileName = privImagePath.substring(privImagePath.lastIndexOf("/") + 1);
+            final String imagePath = "/data/data/" + getPackageName() + "/files/cache/" + fileName;
+            Future<File> future = executorService.submit(new Callable<File>() {
+                @Override
+                public File call() throws Exception {
+                    File file = AESEncryptionUtil.decryptFile2(privImagePath, imagePath);
+                    return file;
+                }
+            });
+            listFuture.add(future);
+        }
+        for (Future<File> fileFuture : listFuture) {
+            try {
+                list.add(fileFuture.get());
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            } catch (ExecutionException e) {
+                e.printStackTrace();
+            }
+        }
+        return list;
+    }
+
+
+    @Override
+    public void onClick(View view) {
+        switch (view.getId()) {
+            case R.id.button_back:
+                finish();
+                break;
+            case R.id.checkbox_select_all:
+                ((CheckBox) view).setText(((CheckBox) view).isChecked() ? "取消全选" : "全选");
+                privateAlbumGridViewAdapter.selectAll(((CheckBox) view).isChecked());
+                break;
+            case R.id.button_min:
+                if(privateAlbumGridViewAdapter.getSelectedData().size() == 0){
+                    Toast.makeText(this, "请至少选择一张图片", Toast.LENGTH_SHORT).show();
+                    break;
+                }
+                DecryptionTask decryptionTask = new DecryptionTask(privateAlbumGridViewAdapter.getSelectedData());
+                decryptionTask.execute();
+                break;
+            default:
+                break;
+
+        }
+    }
+
+
+
+
+
+    /**
+     * 批量解密异步任务
+     */
+    public class DecryptionTask extends AsyncTask<Void, Void, Boolean> {
+        private ArrayList<ImageItem> listPrivFliePath;
+
+        public DecryptionTask(ArrayList<ImageItem> listPrivFliePath) {
+            this.listPrivFliePath = listPrivFliePath;
+            progressDialog = new ProgressDialog(PrivateAlbum.this);
+            progressDialog.setCancelable(false);
+        }
+
+        @Override
+        protected void onPreExecute() {
+            super.onPreExecute();
+            progressDialog.setMessage("正在解密，请稍后...");
+            progressDialog.show();
+        }
+
+        @Override
+        protected Boolean doInBackground(Void... params) {
+            boolean result = false;
+            //Log.d("dongrp", "解密开始:" + System.currentTimeMillis());
+            result = decryptFileList(listPrivFliePath); //解密文件集合
+            //Log.d("dongrp", "解密结束:" + System.currentTimeMillis());
+            return result;
+        }
+
+        @Override
+        protected void onPostExecute(Boolean result) {
+            super.onPostExecute(result);
+            privateAlbumGridViewAdapter.refreshDataAfterDecrypt();
+            String showMessage = result ? "解密完成" : "部分文件解密失败！";
+            Toast.makeText(PrivateAlbum.this, showMessage, Toast.LENGTH_SHORT).show();
+            progressDialog.dismiss();
+        }
+    }
+
+
+    /**
+     * 解密文件集合
+     */
+    boolean result = true;
+
+    public boolean decryptFileList(final ArrayList<ImageItem> arrayList) {
+        long l2 = System.currentTimeMillis();
+        for (final ImageItem item : arrayList) {
+            final String privImagePath = item.getImagePath(); //这个私密文件的绝对路径
+            //解密后：文件原来的路径
+            final String imagePath = privImagePath.replaceFirst("/data/data/" + getPackageName() + "/files/storage/emulated/0", "/storage/emulated/0");
+            executorService.submit(new Runnable() {
+                @Override
+                public void run() {
+                    boolean b = AESEncryptionUtil.decryptFile(privImagePath, imagePath);
+                    if (b) {//解密成功，删除私密文件
+                        delete(item,imagePath);
+                    } else {//解密失败，设置结果为false
+                        result = b;
+                    }
+                }
+            });
+        }
+        long l = System.currentTimeMillis();
+        Log.d("dongrp", "jei mi 循环耗时:" + (l - l2) + " ms");
+        return result;
+    }
+
+
+    /**
+     * 密文件删除、私密数据库记录删除、还原文件条目到系统数据库
+     */
+    public void delete(ImageItem item,String imagePath) {
+        //删除密文件
+        File file = new File(item.getImagePath());
+        file.delete();
+        //删除数据库中该条文件记录
+        databaseAdapter.deletePhoto(item.getImageId());
+
+        //还原文件条目到系统数据库中
+        Uri baseUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+        ContentResolver contentResolver = getContentResolver();
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(MediaStore.Images.Media._ID,item.getImageId());
+        contentValues.put(MediaStore.Images.Media.DATA,imagePath);
+        contentValues.put(MediaStore.Images.Media.SIZE,item.getSize());
+        contentValues.put(MediaStore.Images.Media.DISPLAY_NAME,item.getDisplayName());
+        contentValues.put(MediaStore.Images.Media.TITLE,item.getTitle());
+        contentValues.put(MediaStore.Images.Media.DATE_ADDED,item.getDateAdded());
+        contentValues.put(MediaStore.Images.Media.MIME_TYPE,item.getMimeType());
+        contentValues.put(MediaStore.Images.Media.BUCKET_ID,item.getBucketId());
+        contentValues.put(MediaStore.Images.Media.BUCKET_DISPLAY_NAME,item.getBucket_display_name());
+        contentResolver.insert(baseUri,contentValues);
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /**
+     * 使用递归方法遍历文件夹中所有文件,耗时50ms左右，速度还是很快的
+     */
+/*    @Nullable
+    private ArrayList<String> getDirectoryFiles(File file) {
+        ArrayList<String> list = new ArrayList<>();
+        File flist[] = file.listFiles();
+        if (flist == null || flist.length == 0) {
+            return list;
+        }
+        for (File f : flist) {
+            if (f.isDirectory()) {
+                //这里将列出所有的文件夹
+                getDirectoryFiles(f);
+            } else {
+                //这里将列出所有的文件
+                //Log.d("PrivateAlbumGridViewAda", f.getAbsolutePath());
+                list.add(f.getAbsolutePath());
+            }
+        }
+        return list;
+    }*/
+
+
+
+}
diff --git a/src/com/transage/privatespace/gallery/adapter/PrivateAlbumGridViewAdapter.java b/src/com/transage/privatespace/gallery/adapter/PrivateAlbumGridViewAdapter.java
new file mode 100755
index 0000000..14f0e9d
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/adapter/PrivateAlbumGridViewAdapter.java
@@ -0,0 +1,184 @@
+package com.transage.privatespace.gallery.adapter;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.ToggleButton;
+
+import com.bumptech.glide.Glide;
+import com.transage.privatespace.R;
+import com.transage.privatespace.gallery.photozoom.Bimp;
+import com.transage.privatespace.gallery.photozoom.ImageItem;
+import com.transage.privatespace.gallery.util.AESEncryptionUtil;
+
+import java.util.ArrayList;
+
+/**
+ * Created by dongrp on 2017/7/13.
+ */
+
+public class PrivateAlbumGridViewAdapter extends BaseAdapter {
+
+    private final String TAG = getClass().getSimpleName();
+    private ArrayList<ImageItem> listPrivFliePath = new ArrayList<ImageItem>();
+    private ArrayList<ImageItem> selectedDataList = new ArrayList<ImageItem>();
+    private Context mContext;
+    //private BitmapCache cache;
+    //private DisplayMetrics dm;
+
+    public PrivateAlbumGridViewAdapter(Context c, ArrayList<ImageItem> list) {
+        mContext = c;
+        listPrivFliePath = list;
+        //cache = new BitmapCache();
+        //dm = new DisplayMetrics();
+        //((Activity) mContext).getWindowManager().getDefaultDisplay().getMetrics(dm);
+    }
+
+    /**
+     * 适配器 数据全选、取消全选 的方法
+     * @param isSelectedAll
+     */
+    public void selectAll(boolean isSelectedAll){
+        selectedDataList.clear();
+        if (isSelectedAll){
+            selectedDataList.addAll(listPrivFliePath);
+        }
+        notifyDataSetChanged();
+    }
+
+    /**
+     * 适配器 获取全部数据集 的方法
+     * @return
+     */
+    public ArrayList<ImageItem> getDataList(){
+        return listPrivFliePath;
+    }
+
+    /**
+     * 适配器 获取已选数据集 的方法
+     * @return
+     */
+    public ArrayList<ImageItem> getSelectedData(){
+        return selectedDataList;
+    }
+
+    /**
+     * 解密完成后，刷新适配器的方法
+     */
+    public void refreshDataAfterDecrypt(){
+        listPrivFliePath.removeAll(selectedDataList);
+        notifyDataSetChanged();
+        selectedDataList.clear();
+    }
+
+
+
+
+    public int getCount() {
+        return listPrivFliePath.size();
+    }
+
+    public ImageItem getItem(int position) {
+        return listPrivFliePath.get(position);
+    }
+
+    public long getItemId(int position) {
+        return position;
+    }
+
+
+//    BitmapCache.ImageCallback callback = new BitmapCache.ImageCallback() {
+//        @Override
+//        public void imageLoad(ImageView imageView, Bitmap bitmap, Object... params) {
+//            if (imageView != null && bitmap != null) {
+//                String url = (String) params[0];
+//                if (url != null && url.equals((String) imageView.getTag())) {
+//                    ((ImageView) imageView).setImageBitmap(bitmap);
+//                } else {
+//                    Log.e(TAG, "callback, bmp not match");
+//                }
+//            } else {
+//                Log.e(TAG, "callback, bmp null");
+//            }
+//        }
+//    };
+
+
+    public View getView(final int position, View convertView, ViewGroup parent) {
+        final PrivateAlbumGridViewAdapter.ViewHolder viewHolder;
+        if (convertView == null) {
+            viewHolder = new PrivateAlbumGridViewAdapter.ViewHolder();
+            convertView = LayoutInflater.from(mContext).inflate(R.layout.item_private_album_gridview, parent, false);
+            viewHolder.imageView = (ImageView) convertView.findViewById(R.id.image_view);
+            viewHolder.toggleButton = (ToggleButton) convertView.findViewById(R.id.toggle_button);
+            viewHolder.choosetoggle = (CheckBox) convertView.findViewById(R.id.choosedbt);
+            convertView.setTag(viewHolder);
+            //AutoLayout:对于ListView的item的适配，注意添加这一行，即可在item上使用px高度
+	        //AutoUtils.autoSize(convertView);
+        } else {
+            viewHolder = (PrivateAlbumGridViewAdapter.ViewHolder) convertView.getTag();
+        }
+
+        //decryptFileToInputStream 解密文件太耗时了，需要设计加速 解密文件优化方案
+        //加载解密输入流 Bitmap bitmap = Bimp.handleBitmap(AESEncryptionUtil.decryptFileToInputStream(listPrivFliePath.get(position)));
+        //viewHolder.imageView.setImageBitmap(bitmap);
+        //加载解密字节数组 Glide.with(mContext).load(AESEncryptionUtil.decryptFileToByteArray(((ImageItem)listPrivFliePath.get(position)).getImagePath()))
+        // .into(viewHolder.imageView);
+
+
+/*        String path;
+        if (dataList != null && dataList.size() > position)
+            path = dataList.get(position).imagePath;
+        else
+            path = "camera_default";
+        if (path.contains("camera_default")) {
+            viewHolder.imageView.setImageResource(R.drawable.plugin_camera_no_pictures);
+        } else {
+            final ImageItem item = dataList.get(position);
+            viewHolder.imageView.setTag(item.imagePath);
+            cache.displayBmp(viewHolder.imageView, item.thumbnailPath, item.imagePath,callback);
+        }*/
+
+        viewHolder.toggleButton.setTag(position);
+        viewHolder.choosetoggle.setTag(position);
+        viewHolder.toggleButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (viewHolder.toggleButton.isChecked()){
+                    viewHolder.choosetoggle.setChecked(true);
+                    selectedDataList.add(listPrivFliePath.get(position));
+                }else {
+                    viewHolder.choosetoggle.setChecked(false);
+                    selectedDataList.remove(listPrivFliePath.get(position));
+                }
+            }
+        });
+        //防止滑动的时候由于控件复用而导致数据错乱，所以控件的适配必须有数据源中的内容决定
+        if (selectedDataList.contains(listPrivFliePath.get(position))) {
+            viewHolder.toggleButton.setChecked(true);
+            viewHolder.choosetoggle.setChecked(true);
+        } else {
+            viewHolder.toggleButton.setChecked(false);
+            viewHolder.choosetoggle.setChecked(false);
+        }
+        return convertView;
+    }
+
+    /**
+     * 存放列表项控件句柄
+     */
+    public class ViewHolder {
+        public ImageView imageView;
+        public ToggleButton toggleButton;
+        public CheckBox choosetoggle;
+    }
+
+
+
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/Album.java b/src/com/transage/privatespace/gallery/photozoom/Album.java
new file mode 100755
index 0000000..fde4010
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/Album.java
@@ -0,0 +1,224 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.app.ProgressDialog;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.CheckBox;
+import android.widget.GridView;
+import android.widget.Toast;
+
+import com.transage.privatespace.R;
+import com.transage.privatespace.database.DatabaseAdapter;
+import com.transage.privatespace.database.PsDatabaseHelper;
+import com.transage.privatespace.gallery.util.AESEncryptionUtil;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+
+/**
+ * 这个类用于：将ImageFolders中选定的Folder(含图片的文件夹)中所有图片 以GridView的形式 展示出来
+ *
+ * @author Tom
+ */
+public class Album extends AppCompatActivity implements OnClickListener {
+    private GridView gridView;
+    private AlbumGridViewAdapter gridImageAdapter;
+    //这个静态 成员变量 在FolderGirdViewAdapter的item点击事件中 就已经赋值了
+    public static ArrayList<ImageItem> dataList = new ArrayList<ImageItem>();
+    private EncryptionOrDecryptionTask mTask = null;
+    private ExecutorService executorService; //线程池
+    private DatabaseAdapter databaseAdapter;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_album);
+
+        executorService = Executors.newFixedThreadPool(20);//创建一个缓存线程池
+        databaseAdapter = new DatabaseAdapter(Album.this);//数据库操作工具类
+
+        init();
+    }
+
+    /**
+     * 创建广播接收器broadcastReceiver：接收广播 刷新适配器
+     */
+/*    BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            gridImageAdapter.notifyDataSetChanged();
+        }
+    };*/
+
+    /**
+     * view初始化
+     */
+    private void init() {
+        //注册广播接收器broadcastReceiver（接收画廊 界面发送过来的广播）
+/*        IntentFilter filter = new IntentFilter("data.broadcast.action");
+        registerReceiver(broadcastReceiver, filter);*/
+        findViewById(R.id.checkbox_select_all).setOnClickListener(this);
+        findViewById(R.id.button_back).setOnClickListener(this);
+        findViewById(R.id.button_add).setOnClickListener(this);
+        //创建gridView并绑定适配器
+        gridView = (GridView) findViewById(R.id.album_GridView);
+        gridImageAdapter = new AlbumGridViewAdapter(this, dataList);
+        gridView.setAdapter(gridImageAdapter);
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+//        unregisterReceiver(broadcastReceiver);
+        Bimp.tempSelectBitmap.clear();//退出清空 Bimp.tempSelectBitmap
+        if (null != progressDialog && progressDialog.isShowing()) {
+            progressDialog.dismiss();
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public void onClick(View view) {
+        switch (view.getId()) {
+            case R.id.button_back:
+                finish();
+                break;
+            case R.id.checkbox_select_all:
+                ((CheckBox) view).setText(((CheckBox) view).isChecked() ? "取消全选" : "全选");
+                gridImageAdapter.selectAll(((CheckBox) view).isChecked());
+                break;
+            case R.id.button_add:
+                if (Bimp.tempSelectBitmap.size() == 0){
+                    Toast.makeText(this, "请至少选择一张图片", Toast.LENGTH_SHORT).show();
+                    break;
+                }
+                if (mTask != null) {
+                    mTask.cancel(true);
+                }
+                mTask = new EncryptionOrDecryptionTask(Bimp.tempSelectBitmap);
+                mTask.execute();
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    /**
+     * 加密异步任务
+     */
+    public ProgressDialog progressDialog;
+
+    public class EncryptionOrDecryptionTask extends AsyncTask<Void, Void, Boolean> {
+        private ArrayList<ImageItem> mImageArrayList;
+
+        public EncryptionOrDecryptionTask(ArrayList<ImageItem> imageArrayList) {
+            this.mImageArrayList = imageArrayList;
+            progressDialog = new ProgressDialog(Album.this);
+            progressDialog.setCancelable(false);
+        }
+
+        @Override
+        protected void onPreExecute() {
+            super.onPreExecute();
+            progressDialog.setMessage("正在加密，请稍后...");
+            progressDialog.show();
+        }
+
+        @Override
+        protected Boolean doInBackground(Void... params) {
+            boolean result = false;
+            //Log.d("dongrp", "加密开始:" + System.currentTimeMillis());
+            result = encryptFileList(mImageArrayList); //加密文件集合
+            //Log.d("dongrp", "加密结束:" + System.currentTimeMillis());
+            return result;
+        }
+
+        @Override
+        protected void onPostExecute(Boolean result) {
+            super.onPostExecute(result);
+            gridImageAdapter.refreshDataAfterEncrypt();
+            String showMessage = result ? "加密完成" : "部分文件加密失败！";
+            Toast.makeText(Album.this, showMessage, Toast.LENGTH_SHORT).show();
+            progressDialog.dismiss();
+        }
+
+    }
+
+
+    /**
+     * 加密文件集合
+     *
+     * @param arrayList
+     * @return
+     */
+    boolean result = true;//最后返回的加密结果
+
+    public boolean encryptFileList(ArrayList<ImageItem> arrayList) {
+        long l2 = System.currentTimeMillis();
+        for (final ImageItem item : arrayList) {
+            final String imagePath = item.getImagePath();
+            final String privImagePath = imagePath.replaceFirst("/storage/emulated/0", "/data/data/" + getPackageName() + "/files/storage/emulated/0");
+            executorService.submit(new Runnable() {
+                @Override
+                public void run() {
+                    boolean b = AESEncryptionUtil.encryptFile(imagePath, privImagePath);
+                    if (b) {//加密成功，删除源文件
+                        delete(item,privImagePath);
+                    } else { //加密失败，设置结果为false
+                        result = b;
+                    }
+                }
+            });
+        }
+        long l = System.currentTimeMillis();
+        Log.d("dongrp", "加密for循环耗时:" + (l - l2) + " ms");
+        return result;
+    }
+
+
+    /**
+     * 明文件删除、明文件数据库条目删除、私密数据库插入
+     * @param item
+     */
+    public void delete(ImageItem item,String privImagePath) {
+        //删除明文件
+        File file = new File(item.getImagePath());
+        file.delete();
+        //删除数据库中该条明文件记录
+        Uri baseUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+        ContentResolver contentResolver = getContentResolver();
+        contentResolver.delete(baseUri, "_id=?", new String[]{item.getImageId()});
+        //将加密后的文件条目插入私密数据库
+        Log.d("Album", item.toString());
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(PsDatabaseHelper.FilesClumns._ID,Integer.valueOf(item.getImageId()));
+        contentValues.put(PsDatabaseHelper.FilesClumns._DATA,privImagePath);
+        contentValues.put(PsDatabaseHelper.FilesClumns._SOURCE_DATA,item.getImagePath());
+        contentValues.put(PsDatabaseHelper.FilesClumns._SIZE,Integer.valueOf(item.getSize()));
+        contentValues.put(PsDatabaseHelper.FilesClumns._DISPLAY_NAME,item.getDisplayName());
+        contentValues.put(PsDatabaseHelper.FilesClumns.TITLE,item.getTitle());
+        contentValues.put(PsDatabaseHelper.FilesClumns.DATE_ADDED,Long.valueOf(item.getDateAdded()));
+        contentValues.put(PsDatabaseHelper.FilesClumns.MIME_TYPE,item.getMimeType());
+        contentValues.put(PsDatabaseHelper.FilesClumns.BUCKET_ID,item.getBucketId());
+        contentValues.put(PsDatabaseHelper.FilesClumns.BUCKET_DISPLAY_NAME,item.getBucket_display_name());
+        databaseAdapter.insertPhoto(contentValues);
+    }
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/AlbumGridViewAdapter.java b/src/com/transage/privatespace/gallery/photozoom/AlbumGridViewAdapter.java
new file mode 100755
index 0000000..2e6ad46
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/AlbumGridViewAdapter.java
@@ -0,0 +1,163 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.ToggleButton;
+
+import com.transage.privatespace.R;
+
+import java.util.ArrayList;
+
+
+/**
+ * 适配器：将某一个相册中图片，以GridView的形式进行适配
+ *
+ * @author Tom
+ */
+public class AlbumGridViewAdapter extends BaseAdapter {
+
+	private final String TAG = getClass().getSimpleName();
+    private ArrayList<ImageItem> dataList;
+    private Context context;
+    private BitmapCache cache;
+    //private DisplayMetrics dm;
+
+    public AlbumGridViewAdapter(Context context, ArrayList<ImageItem> dataList) {
+		this.context = context;
+		this.dataList = dataList;
+        cache = new BitmapCache();
+        //dm = new DisplayMetrics();
+		//((Activity) context).getWindowManager().getDefaultDisplay().getMetrics(dm);
+	}
+
+	/**
+	 * 数据全选、取消全选 的方法
+	 *
+	 * @param selectAll
+	 */
+	public void selectAll(boolean selectAll) {
+		Bimp.tempSelectBitmap.clear();
+		if (selectAll) {
+			Bimp.tempSelectBitmap.addAll(dataList);
+		}
+		notifyDataSetChanged();
+	}
+
+    /**
+     * 适配器 获取已选数据集 的方法
+     * @return
+     */
+    public ArrayList<ImageItem> getSelectedData(){
+        return Bimp.tempSelectBitmap;
+    }
+
+    /**
+     * 解密完成后，刷新适配器的方法
+     */
+    public void refreshDataAfterEncrypt(){
+        dataList.removeAll(Bimp.tempSelectBitmap);
+        notifyDataSetChanged();
+        Bimp.tempSelectBitmap.clear();
+    }
+
+	public int getCount() {
+		return dataList.size();
+	}
+
+	public Object getItem(int position) {
+		return dataList.get(position);
+	}
+
+	public long getItemId(int position) {
+		return 0;
+	}
+
+	BitmapCache.ImageCallback callback = new BitmapCache.ImageCallback() {
+        @Override
+		public void imageLoad(ImageView imageView, Bitmap bitmap, Object... params) {
+			if (imageView != null && bitmap != null) {
+				String url = (String) params[0];
+				if (url != null && url.equals((String) imageView.getTag())) {
+					((ImageView) imageView).setImageBitmap(bitmap);
+				} else {
+					Log.e(TAG, "callback, bmp not match");
+				}
+			} else {
+				Log.e(TAG, "callback, bmp null");
+			}
+		}
+	};
+
+	/**
+	 * 存放列表项控件句柄
+	 */
+	private class ViewHolder {
+		public ImageView imageView;
+		public ToggleButton toggleButton;
+		public CheckBox choosetoggle;
+	}
+
+	public View getView(final int position, View convertView, ViewGroup parent) {
+		final ViewHolder viewHolder;
+		if (convertView == null) {
+			viewHolder = new ViewHolder();
+			convertView = LayoutInflater.from(context).inflate(R.layout.item_album_gridview, parent, false);
+			viewHolder.imageView = (ImageView) convertView.findViewById(R.id.image_view);
+			viewHolder.toggleButton = (ToggleButton) convertView.findViewById(R.id.toggle_button);
+			viewHolder.choosetoggle = (CheckBox) convertView.findViewById(R.id.choosedbt);
+			convertView.setTag(viewHolder);
+	        //AutoLayout:对于ListView的item的适配，注意添加这一行，即可在item上使用px高度
+	        //AutoUtils.autoSize(convertView);
+		} else {
+			viewHolder = (ViewHolder) convertView.getTag();
+		}
+		String path;
+		if (dataList != null && dataList.size() > position)
+			path = dataList.get(position).imagePath;
+		else
+			path = "camera_default";
+		if (path.contains("camera_default")) {
+			viewHolder.imageView.setImageResource(R.drawable.plugin_camera_no_pictures);
+		} else {
+			final ImageItem item = dataList.get(position);
+			viewHolder.imageView.setTag(item.imagePath);
+			cache.displayBmp(viewHolder.imageView, item.thumbnailPath, item.imagePath,callback);
+		}
+		viewHolder.toggleButton.setTag(position);
+		viewHolder.choosetoggle.setTag(position);
+		viewHolder.toggleButton.setOnClickListener(new OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				if (viewHolder.toggleButton.isChecked()){
+					viewHolder.choosetoggle.setChecked(true);
+                    Bimp.tempSelectBitmap.add(dataList.get(position));
+				}else {
+					viewHolder.choosetoggle.setChecked(false);
+                    Bimp.tempSelectBitmap.remove(dataList.get(position));
+				}
+			}
+		});
+		//防止滑动的时候由于控件复用而导致数据错乱，所以控件的适配必须有数据源中的内容决定
+		if (Bimp.tempSelectBitmap.contains(dataList.get(position))) {
+			viewHolder.toggleButton.setChecked(true);
+			viewHolder.choosetoggle.setChecked(true);
+		} else {
+			viewHolder.toggleButton.setChecked(false);
+			viewHolder.choosetoggle.setChecked(false);
+		}
+		return convertView;
+	}
+
+/*	public int dipToPx(int dip) {
+		return (int) (dip * dm.density + 0.5f);
+	}*/
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/AlbumHelper.java b/src/com/transage/privatespace/gallery/photozoom/AlbumHelper.java
new file mode 100755
index 0000000..9855e5d
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/AlbumHelper.java
@@ -0,0 +1,249 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.provider.MediaStore.Audio.Albums;
+import android.provider.MediaStore.Images.Media;
+import android.provider.MediaStore.Images.Thumbnails;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+
+public class AlbumHelper {
+	final String TAG = getClass().getSimpleName();
+	Context context;
+	ContentResolver cr;
+	
+	HashMap<String, String> thumbnailList = new HashMap<String, String>();
+
+	List<HashMap<String, String>> albumList = new ArrayList<HashMap<String, String>>();
+	HashMap<String, ImageBucket> bucketList = new HashMap<String, ImageBucket>();
+
+	private static AlbumHelper instance;
+
+	private AlbumHelper() {
+	}
+
+	public static AlbumHelper getHelper() {
+		if (instance == null) {
+			instance = new AlbumHelper();
+		}
+		return instance;
+	}
+
+	public void init(Context context) {
+		if (this.context == null) {
+			this.context = context;
+			cr = context.getContentResolver();
+		}
+	}
+
+	private void getThumbnail() {
+		String[] projection = { Thumbnails._ID, Thumbnails.IMAGE_ID,
+				Thumbnails.DATA };
+		Cursor cursor = cr.query(Thumbnails.EXTERNAL_CONTENT_URI, projection,
+				null, null, null);
+		getThumbnailColumnData(cursor);
+	}
+
+	private void getThumbnailColumnData(Cursor cur) {
+		if (cur.moveToFirst()) {
+//			int _id;
+			int image_id;
+			String image_path;
+//			int _idColumn = cur.getColumnIndex(Thumbnails._ID);
+			int image_idColumn = cur.getColumnIndex(Thumbnails.IMAGE_ID);
+			int dataColumn = cur.getColumnIndex(Thumbnails.DATA);
+
+			do {
+				// Get the field values
+//				_id = cur.getInt(_idColumn);
+				image_id = cur.getInt(image_idColumn);
+				image_path = cur.getString(dataColumn);
+
+				// Do something with the values.
+				// Log.i(TAG, _id + " image_id:" + image_id + " path:"
+				// + image_path + "---");
+				// HashMap<String, String> hash = new HashMap<String, String>();
+				// hash.put("image_id", image_id + "");
+				// hash.put("path", image_path);
+				// thumbnailList.add(hash);
+				thumbnailList.put("" + image_id, image_path);
+			} while (cur.moveToNext());
+		}
+	}
+
+	void getAlbum() {
+		String[] projection = { Albums._ID, Albums.ALBUM, Albums.ALBUM_ART,
+				Albums.ALBUM_KEY, Albums.ARTIST, Albums.NUMBER_OF_SONGS };
+		Cursor cursor = cr.query(Albums.EXTERNAL_CONTENT_URI, projection, null,
+				null, null);
+		getAlbumColumnData(cursor);
+
+	}
+
+	private void getAlbumColumnData(Cursor cur) {
+		if (cur.moveToFirst()) {
+			int _id;
+			String album;
+			String albumArt;
+			String albumKey;
+			String artist;
+			int numOfSongs;
+
+			int _idColumn = cur.getColumnIndex(Albums._ID);
+			int albumColumn = cur.getColumnIndex(Albums.ALBUM);
+			int albumArtColumn = cur.getColumnIndex(Albums.ALBUM_ART);
+			int albumKeyColumn = cur.getColumnIndex(Albums.ALBUM_KEY);
+			int artistColumn = cur.getColumnIndex(Albums.ARTIST);
+			int numOfSongsColumn = cur.getColumnIndex(Albums.NUMBER_OF_SONGS);
+
+			do {
+				// Get the field values
+				_id = cur.getInt(_idColumn);
+				album = cur.getString(albumColumn);
+				albumArt = cur.getString(albumArtColumn);
+				albumKey = cur.getString(albumKeyColumn);
+				artist = cur.getString(artistColumn);
+				numOfSongs = cur.getInt(numOfSongsColumn);
+
+				// Do something with the values.
+				Log.i(TAG, _id + " album:" + album + " albumArt:" + albumArt
+						+ "albumKey: " + albumKey + " artist: " + artist
+						+ " numOfSongs: " + numOfSongs + "---");
+				HashMap<String, String> hash = new HashMap<String, String>();
+				hash.put("_id", _id + "");
+				hash.put("album", album);
+				hash.put("albumArt", albumArt);
+				hash.put("albumKey", albumKey);
+				hash.put("artist", artist);
+				hash.put("numOfSongs", numOfSongs + "");
+				albumList.add(hash);
+
+			} while (cur.moveToNext());
+
+		}
+	}
+
+	boolean hasBuildImagesBucketList = false;
+
+	void buildImagesBucketList() {
+		long startTime = System.currentTimeMillis();
+
+		getThumbnail();
+
+		String columns[] = new String[] { Media._ID, Media.BUCKET_ID,
+				Media.PICASA_ID, Media.DATA, Media.DISPLAY_NAME, Media.TITLE,
+				Media.SIZE, Media.BUCKET_DISPLAY_NAME ,Media.DATE_ADDED,Media.MIME_TYPE};
+		Cursor cur = cr.query(Media.EXTERNAL_CONTENT_URI, columns, null, null, Media.DATE_TAKEN+" desc");
+		bucketList.clear();//add by dongrp
+		if (cur.moveToFirst()) {
+			int photoIDIndex = cur.getColumnIndexOrThrow(Media._ID);
+			int photoPathIndex = cur.getColumnIndexOrThrow(Media.DATA);
+			int photoNameIndex = cur.getColumnIndexOrThrow(Media.DISPLAY_NAME);
+			int photoTitleIndex = cur.getColumnIndexOrThrow(Media.TITLE);
+			int photoSizeIndex = cur.getColumnIndexOrThrow(Media.SIZE);
+			int bucketDisplayNameIndex = cur
+					.getColumnIndexOrThrow(Media.BUCKET_DISPLAY_NAME);
+			int bucketIdIndex = cur.getColumnIndexOrThrow(Media.BUCKET_ID);
+			int picasaIdIndex = cur.getColumnIndexOrThrow(Media.PICASA_ID);
+			int dateAddedIdIndex = cur.getColumnIndexOrThrow(Media.DATE_ADDED);
+			int mimeTypeIdIndex = cur.getColumnIndexOrThrow(Media.MIME_TYPE);
+//			int totalNum = cur.getCount();
+
+			do {
+				String _id = cur.getString(photoIDIndex);
+				String name = cur.getString(photoNameIndex);
+				String path = cur.getString(photoPathIndex);
+				String title = cur.getString(photoTitleIndex);
+				String size = cur.getString(photoSizeIndex);
+				String bucketName = cur.getString(bucketDisplayNameIndex);
+				String bucketId = cur.getString(bucketIdIndex);
+				String picasaId = cur.getString(picasaIdIndex);
+				String dateAdded = cur.getString(dateAddedIdIndex);
+				String mimeType = cur.getString(mimeTypeIdIndex);
+
+				Log.i(TAG, _id + ", bucketId: " + bucketId + ", picasaId: "
+						+ picasaId + " name:" + name + " path:" + path
+						+ " title: " + title + " size: " + size + " bucket: "
+						+ bucketName + "---");
+
+				ImageBucket bucket = bucketList.get(bucketId);
+				if (bucket == null) {
+					bucket = new ImageBucket();
+					bucketList.put(bucketId, bucket);
+					bucket.imageList = new ArrayList<ImageItem>();
+					bucket.bucketName = bucketName;
+				}
+				bucket.count++;
+				ImageItem imageItem = new ImageItem();
+				imageItem.imageId = _id;
+				imageItem.imagePath = path;
+				imageItem.thumbnailPath = thumbnailList.get(_id);
+				imageItem.setBucket_display_name(bucketName);
+				imageItem.setBucketId(bucketId);
+				imageItem.setDisplayName(name);
+				imageItem.setDateAdded(dateAdded);
+				imageItem.setMimeType(mimeType);
+				imageItem.setSize(size);
+				imageItem.setTitle(title);
+				bucket.imageList.add(imageItem);
+
+			} while (cur.moveToNext());
+		}
+
+		Iterator<Entry<String, ImageBucket>> itr = bucketList.entrySet()
+				.iterator();
+		while (itr.hasNext()) {
+			Entry<String, ImageBucket> entry = (Entry<String, ImageBucket>) itr
+					.next();
+			ImageBucket bucket = entry.getValue();
+			Log.d(TAG, entry.getKey() + ", " + bucket.bucketName + ", "
+					+ bucket.count + " ---------- ");
+			for (int i = 0; i < bucket.imageList.size(); ++i) {
+				ImageItem image = bucket.imageList.get(i);
+				Log.d(TAG, "----- " + image.imageId + ", " + image.imagePath
+						+ ", " + image.thumbnailPath);
+			}
+		}
+		hasBuildImagesBucketList = true;
+		long endTime = System.currentTimeMillis();
+		Log.d(TAG, "use time: " + (endTime - startTime) + " ms");
+	}
+
+
+	public List<ImageBucket> getImagesBucketList(boolean refresh) {
+		if (refresh || (!refresh && !hasBuildImagesBucketList)) {
+			buildImagesBucketList();
+		}
+		List<ImageBucket> tmpList = new ArrayList<ImageBucket>();
+		Iterator<Entry<String, ImageBucket>> itr = bucketList.entrySet()
+				.iterator();
+		while (itr.hasNext()) {
+			Entry<String, ImageBucket> entry = (Entry<String, ImageBucket>) itr
+					.next();
+			tmpList.add(entry.getValue());
+		}
+		return tmpList;
+	}
+
+	String getOriginalImagePath(String image_id) {
+		String path = null;
+		Log.i(TAG, "---(^o^)----" + image_id);
+		String[] projection = { Media._ID, Media.DATA };
+		Cursor cursor = cr.query(Media.EXTERNAL_CONTENT_URI, projection,
+				Media._ID + "=" + image_id, null, null);
+		if (cursor != null) {
+			cursor.moveToFirst();
+			path = cursor.getString(cursor.getColumnIndex(Media.DATA));
+
+		}
+		return path;
+	}
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/Bimp.java b/src/com/transage/privatespace/gallery/photozoom/Bimp.java
new file mode 100755
index 0000000..f2dff06
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/Bimp.java
@@ -0,0 +1,157 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.content.ContentResolver;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.util.Base64;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import javax.crypto.CipherInputStream;
+
+/**
+ * 该类用于：存放自定义的ImageItem对象
+ */
+public class Bimp {
+	public static int max = 0;
+	/**
+	 * Bimp类中的这个ArryList用于存放自定义的ImageItem对象
+	 */
+	public static ArrayList<ImageItem> tempSelectBitmap = new ArrayList<ImageItem>();
+	
+
+	/**
+	 * 这个方法 通过循环质量压缩， 将图片的质量压缩到 一个合理的（设置好的）大小
+	 * @param bitmap ：待压缩的 bitmap
+	 * @param size ：设定的大小（单位kb），压缩后的bitmap的大小不会超过 size (kb)
+	 * @return
+	 */
+	private static Bitmap compressImage(Bitmap bitmap, int size) {
+		ByteArrayOutputStream baos = new ByteArrayOutputStream();
+		bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);// 质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中
+		int options = 100;
+		while (baos.toByteArray().length / 1024 > size) { // 循环判断如果压缩后图片是否大于 size(kb),大于继续压缩
+			baos.reset();// 重置baos即清空baos
+			options -= 10;// 每次都减少10
+			bitmap.compress(Bitmap.CompressFormat.JPEG, options, baos);// 这里压缩为options%，把压缩后的数据存放到baos中
+
+		}
+		ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());// 把压缩后的数据baos存放到ByteArrayInputStream中
+		Bitmap bitmap1 = BitmapFactory.decodeStream(isBm, null, null);// 把ByteArrayInputStream数据生成图片
+		return bitmap1;
+	}
+	
+	/**
+	 * 拍照图片的采样方法：根据图片存储path获取图片，对图片进行二次采样的方法，
+	 * 固定缩放比例为：6 ，
+	 * 且return bitmap之前 还会进行图片质量压缩
+	 * @return Bitmap
+	 */
+	public static Bitmap handleBitmap(String path) {
+		// 存储缩放比例
+		int sampleSize = 6;
+		// 创建图片处理类的对象
+		BitmapFactory.Options options = new BitmapFactory.Options();
+		// 只加载图片的边缘区域，
+		options.inJustDecodeBounds = true;
+		// 第一采样解码里面的内容bitmap值为null
+		BitmapFactory.decodeFile(path, options);
+		// 缩放为原图的1/sampleSize；
+		options.inSampleSize = sampleSize;
+		// 第二次采样解码,加载缩放之后的图片
+		options.inJustDecodeBounds = false;
+		Bitmap bitmap = BitmapFactory.decodeFile(path, options);
+		return compressImage(bitmap, 64); //ruturn之前，进行一下图片质量压缩
+	}
+	
+	/**
+	 * 相册中选定图片的采样方法：由ContentResolver解析uri中的图片，进行二次采样处理的方法
+	 * 固定缩放比例为：6 ，return bitmap之前，进行图片质量压缩
+	 * @return Bitmap
+	 */
+	public static Bitmap handleBitmap(Uri uri, ContentResolver cr) {
+		// 存储缩放比例
+		int sampleSize = 6;
+		// 创建图片处理类的对象
+		BitmapFactory.Options options = new BitmapFactory.Options();
+		// 只加载图片的边缘区域，
+		options.inJustDecodeBounds = true;
+		// 第一采样解码里面的内容bitmap值为null
+		try {
+			BitmapFactory.decodeStream(cr.openInputStream(uri), null, options);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
+		// 缩放为原图的1/sampleSize；当可以
+		options.inSampleSize = sampleSize;
+		// 第二次采样解码,加载缩放之后的图片
+		options.inJustDecodeBounds = false;
+		try {
+			return compressImage(BitmapFactory.decodeStream(cr.openInputStream(uri), null, options), 768);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+
+	/**
+	 * 图片文件输入流的采样方法：对读取的图片文件的InputStream，进行二次采样处理的方法
+	 * 固定缩放比例为：6 ，return bitmap之前，进行图片质量压缩
+	 * @return Bitmap
+	 */
+	public static Bitmap handleBitmap(CipherInputStream fis) {
+		// 存储缩放比例
+		int sampleSize = 6;
+		// 创建图片处理类的对象
+		BitmapFactory.Options options = new BitmapFactory.Options();
+		// 只加载图片的边缘区域，
+		options.inJustDecodeBounds = true;
+		// 第一采样解码里面的内容bitmap值为null
+		BitmapFactory.decodeStream(fis, null, options);
+		// 缩放为原图的1/sampleSize；当可以
+		options.inSampleSize = sampleSize;
+		// 第二次采样解码,加载缩放之后的图片
+		options.inJustDecodeBounds = false;
+		return BitmapFactory.decodeStream(fis, null, options);
+	}
+
+	/**
+	 * 此方法 用于将Bitmap转换为Base64
+	 * @param bitmap
+	 * @return Base64（String）
+	 */
+	public static String bitmapToBase64(Bitmap bitmap) {
+		String result = null;
+		ByteArrayOutputStream baos = null;
+		try {
+			if (bitmap != null) {
+				baos = new ByteArrayOutputStream();
+				bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);
+				baos.flush();
+				baos.close();
+				byte[] bitmapBytes = baos.toByteArray();
+				result = Base64.encodeToString(bitmapBytes, Base64.DEFAULT);
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				if (baos != null) {
+					baos.flush();
+					baos.close();
+				}
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		return result;
+	}
+	
+	
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/BitmapCache.java b/src/com/transage/privatespace/gallery/photozoom/BitmapCache.java
new file mode 100755
index 0000000..0e8d83f
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/BitmapCache.java
@@ -0,0 +1,129 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.app.Activity;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Handler;
+import android.text.TextUtils;
+import android.util.Log;
+import android.widget.ImageView;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.lang.ref.SoftReference;
+import java.util.HashMap;
+
+
+public class BitmapCache extends Activity {
+
+	public Handler h = new Handler();
+	public final String TAG = getClass().getSimpleName();
+	private HashMap<String, SoftReference<Bitmap>> imageCache = new HashMap<String, SoftReference<Bitmap>>();
+	
+	
+	public void put(String path, Bitmap bmp) {
+		if (!TextUtils.isEmpty(path) && bmp != null) {
+			imageCache.put(path, new SoftReference<Bitmap>(bmp));
+		}
+	}
+
+	public void displayBmp(final ImageView iv, final String thumbPath,
+						   final String sourcePath, final ImageCallback callback) {
+		if (TextUtils.isEmpty(thumbPath) && TextUtils.isEmpty(sourcePath)) {
+			Log.e(TAG, "no paths pass in");
+			return;
+		}
+
+		final String path;
+		final boolean isThumbPath;
+		if (!TextUtils.isEmpty(thumbPath)) {
+			path = thumbPath;
+			isThumbPath = true;
+		} else if (!TextUtils.isEmpty(sourcePath)) {
+			path = sourcePath;
+			isThumbPath = false;
+		} else {
+			// iv.setImageBitmap(null);
+			return;
+		}
+
+		if (imageCache.containsKey(path)) {
+			SoftReference<Bitmap> reference = imageCache.get(path);
+			Bitmap bmp = reference.get();
+			if (bmp != null) {
+				if (callback != null) {
+					callback.imageLoad(iv, bmp, sourcePath);
+				}
+				iv.setImageBitmap(bmp);
+				Log.d(TAG, "hit cache");
+				return;
+			}
+		}
+		iv.setImageBitmap(null);
+
+		new Thread() {
+			Bitmap thumb;
+
+			public void run() {
+
+				try {
+					if (isThumbPath) {
+						thumb = BitmapFactory.decodeFile(thumbPath);
+						if (thumb == null) {
+							thumb = revitionImageSize(sourcePath);						
+						}						
+					} else {
+						thumb = revitionImageSize(sourcePath);											
+					}
+				} catch (Exception e) {
+					
+				}
+				if (thumb == null) {
+					thumb = null;
+				}
+				Log.e(TAG, "-------thumb------"+thumb);
+				put(path, thumb);
+
+				if (callback != null) {
+					h.post(new Runnable() {
+						@Override
+						public void run() {
+							callback.imageLoad(iv, thumb, sourcePath);
+						}
+					});
+				}
+			}
+		}.start();
+
+	}
+
+	public Bitmap revitionImageSize(String path) throws IOException {
+		BufferedInputStream in = new BufferedInputStream(new FileInputStream(
+				new File(path)));
+		BitmapFactory.Options options = new BitmapFactory.Options();
+		options.inJustDecodeBounds = true;
+		BitmapFactory.decodeStream(in, null, options);
+		in.close();
+		int i = 0;
+		Bitmap bitmap = null;
+		while (true) {
+			if ((options.outWidth >> i <= 256)
+					&& (options.outHeight >> i <= 256)) {
+				in = new BufferedInputStream(
+						new FileInputStream(new File(path)));
+				options.inSampleSize = (int) Math.pow(2.0D, i);
+				options.inJustDecodeBounds = false;
+				bitmap = BitmapFactory.decodeStream(in, null, options);
+				break;
+			}
+			i += 1;
+		}
+		return bitmap;
+	}
+
+	public interface ImageCallback {
+		public void imageLoad(ImageView imageView, Bitmap bitmap, Object... params);
+	}
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/Compat.java b/src/com/transage/privatespace/gallery/photozoom/Compat.java
new file mode 100755
index 0000000..9de096f
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/Compat.java
@@ -0,0 +1,19 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.view.View;
+
+public class Compat {
+	
+	private static final int SIXTY_FPS_INTERVAL = 1000 / 60;
+	
+	public static void postOnAnimation(View view, Runnable runnable) {
+		if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
+			SDK16.postOnAnimation(view, runnable);
+		} else {
+			view.postDelayed(runnable, SIXTY_FPS_INTERVAL);
+		}
+	}
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/FolderGirdViewAdapter.java b/src/com/transage/privatespace/gallery/photozoom/FolderGirdViewAdapter.java
new file mode 100755
index 0000000..528b24f
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/FolderGirdViewAdapter.java
@@ -0,0 +1,166 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.transage.privatespace.R;
+
+import java.util.ArrayList;
+
+
+/**
+ * 适配器：将所有包含图片的文件夹  以GridView的形式展示
+ *
+ * @author Tom
+ */
+public class FolderGirdViewAdapter extends BaseAdapter {
+
+	private Context mContext;
+	private Intent mIntent;
+	private DisplayMetrics dm;
+	BitmapCache cache;
+	final String TAG = getClass().getSimpleName();
+	public FolderGirdViewAdapter(Context c) {
+		cache = new BitmapCache();
+		init(c);
+	}
+
+	// 初始化
+	public void init(Context c) {
+		mContext = c;
+		mIntent = ((Activity) mContext).getIntent();
+		dm = new DisplayMetrics();
+		((Activity) mContext).getWindowManager().getDefaultDisplay()
+				.getMetrics(dm);
+	}
+
+	
+
+	@Override
+	public int getCount() {
+		return Folders.contentList.size();
+	}
+
+	@Override
+	public Object getItem(int position) {
+		return position;
+	}
+
+	@Override
+	public long getItemId(int position) {
+		return position;
+	}
+	
+	BitmapCache.ImageCallback callback = new BitmapCache.ImageCallback() {
+		@Override
+		public void imageLoad(ImageView imageView, Bitmap bitmap,
+							  Object... params) {
+			if (imageView != null && bitmap != null) {
+				String url = (String) params[0];
+				if (url != null && url.equals((String) imageView.getTag())) {
+					((ImageView) imageView).setImageBitmap(bitmap);
+				} else {
+					Log.e(TAG, "callback, bmp not match");
+				}
+			} else {
+				Log.e(TAG, "callback, bmp null");
+			}
+		}
+	};
+
+	private class ViewHolder {
+		// 
+//		public ImageView backImage;
+		// 封面
+		public ImageView imageView;
+		public ImageView choose_back;
+		// 文件夹名称
+		public TextView folderName;
+		// 文件夹里面的图片数量
+		public TextView fileNum;
+	}
+	ViewHolder holder = null;
+	@Override
+	public View getView(int position, View convertView, ViewGroup parent) {
+		if (convertView == null) {
+			convertView = LayoutInflater.from(mContext).inflate(R.layout.item_folders_gridview, parent,false);
+			holder = new ViewHolder();
+//			holder.backImage = (ImageView) convertView.findViewById(R.id.file_back);
+			holder.imageView = (ImageView) convertView.findViewById(R.id.file_image);
+			holder.choose_back = (ImageView) convertView.findViewById(R.id.choose_back);
+			holder.folderName = (TextView) convertView.findViewById(R.id.name);
+			holder.fileNum = (TextView) convertView.findViewById(R.id.filenum);
+			holder.imageView.setAdjustViewBounds(true);
+			holder.imageView.setScaleType(ImageView.ScaleType.FIT_XY);
+			convertView.setTag(holder);
+			//AutoLayout:对于ListView的item的适配，注意添加这一行，即可在item上使用px高度
+//	        AutoUtils.autoSize(convertView);
+		} else
+			holder = (ViewHolder) convertView.getTag();
+		String path;
+		if (Folders.contentList.get(position).imageList != null) {
+			//path = photoAbsolutePathList.get(position);
+			//封面图片路径
+			path = Folders.contentList.get(position).imageList.get(0).imagePath;
+			// 给folderName设置值为文件夹名称
+			//holder.folderName.setText(fileNameList.get(position));
+			holder.folderName.setText(Folders.contentList.get(position).bucketName);
+			
+			// 给fileNum设置文件夹内图片数量
+			//holder.fileNum.setText("" + fileNum.get(position));
+			holder.fileNum.setText("" + Folders.contentList.get(position).count);
+			
+		} else
+			path = "android_hybrid_camera_default";
+		if (path.contains("android_hybrid_camera_default"))
+			holder.imageView.setImageResource(R.drawable.plugin_camera_no_pictures);
+		else {
+//			holder.imageView.setImageBitmap( Folders.contentList.get(position).imageList.get(0).getBitmap());
+			final ImageItem item = Folders.contentList.get(position).imageList.get(0);
+			holder.imageView.setTag(item.imagePath);
+			cache.displayBmp(holder.imageView, item.thumbnailPath, item.imagePath,callback);
+		}
+		// 为封面添加监听
+		holder.imageView.setOnClickListener(new ImageViewClickListener(
+				position, mIntent,holder.choose_back));
+		
+		return convertView;
+	}
+
+	// 为每一个文件夹（相册）构建 点击监听器
+	private class ImageViewClickListener implements OnClickListener {
+		private int position;
+		private ImageView choose_back;
+		public ImageViewClickListener(int position, Intent intent, ImageView choose_back) {
+			this.position = position;
+			this.choose_back = choose_back;
+		}
+		public void onClick(View v) {
+			//给Album中的dataList赋值
+			Album.dataList = (ArrayList<ImageItem>) Folders.contentList.get(position).imageList;
+			Intent intent = new Intent();
+			String folderName = Folders.contentList.get(position).bucketName; //点击的相册的 名字
+			intent.putExtra("folderName", folderName);
+			intent.setClass(mContext, Album.class);
+			mContext.startActivity(intent);
+			choose_back.setVisibility(View.VISIBLE);
+			((Activity)mContext).finish(); //跳转后，关闭Folders界面
+		}
+	}
+
+	public int dipToPx(int dip) {
+		return (int) (dip * dm.density + 0.5f);
+	}
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/Folders.java b/src/com/transage/privatespace/gallery/photozoom/Folders.java
new file mode 100755
index 0000000..60b9d3e
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/Folders.java
@@ -0,0 +1,52 @@
+package com.transage.privatespace.gallery.photozoom;
+
+
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.GridView;
+
+import com.transage.privatespace.R;
+
+import java.util.List;
+
+
+/**
+ * 这个类主要是用来:将所有包含图片的文件夹  以GridView的形式展示出来
+ * @author Tom
+ */
+public class Folders extends AppCompatActivity {
+
+	private AlbumHelper helper;
+	public static List<ImageBucket> contentList;
+	private FolderGirdViewAdapter folderAdapter;
+	private GridView gridView;
+	
+	
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.activity_folders);
+
+		helper = AlbumHelper.getHelper();
+		helper.init(getApplicationContext());
+		//组件和适配器
+		gridView = (GridView) findViewById(R.id.fileGridView);
+		folderAdapter = new FolderGirdViewAdapter(this);
+		//返回 按钮
+		findViewById(R.id.button_back).setOnClickListener(new OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				finish();
+			}
+		});
+	}
+
+	protected void onResume() {
+		super.onResume();
+		//初始化ImagesBucketList（所有包含图片的文件夹的集合，一个包含图片的文件夹就是一个ImagesBucket）
+		contentList = helper.getImagesBucketList(true);
+		//绑定ImagesBucket 适配器
+		gridView.setAdapter(folderAdapter);
+	}
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/Gallery.java b/src/com/transage/privatespace/gallery/photozoom/Gallery.java
new file mode 100755
index 0000000..578be2d
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/Gallery.java
@@ -0,0 +1,125 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.os.Bundle;
+import android.support.v4.view.ViewPager.OnPageChangeListener;
+import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.RelativeLayout;
+
+import com.transage.privatespace.R;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * 这个类是用于：对选定图片  进行预览
+ * @author Tom
+ */
+public class Gallery extends AppCompatActivity implements OnClickListener,OnPageChangeListener {
+	private Intent intent;
+//	private TextView positionTextView;//顶部显示预览图片位置的textview
+//	private int position;//获取前一个activity传过来的position
+	//当前的位置
+	private int location = 0;
+	//viewPager中展示的多个图片view,都存放在这个views_list中
+	private ArrayList<View> views_list = new ArrayList<View>();
+	private ViewPagerFixed pager;
+	private GalleryViewPagerAdapter adapter;
+
+	public List<Bitmap> bmp = new ArrayList<Bitmap>();
+	public List<String> drr = new ArrayList<String>();
+	public List<String> del = new ArrayList<String>();
+	
+
+	RelativeLayout photo_relativeLayout;
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.activity_gallery);
+		
+		initViewsList(); //初始化数据
+		initViewAndCtrl(); //初始化view 和 ctrl
+		
+	}
+	
+	/**
+	 * 初始化ViewPager中展示的 图片views（相当于数据的初始化）
+	 */
+	private void initViewsList() {
+		for (int i = 0; i < Bimp.tempSelectBitmap.size(); i++) {
+			Bitmap bitmap = Bimp.tempSelectBitmap.get(i).getBitmap();
+			PhotoView img = new PhotoView(this);
+			img.setBackgroundColor(0xff000000);
+			img.setImageBitmap(bitmap);
+			img.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+			views_list.add(img);
+		}
+	}
+	/**
+	 * 初始化view和适配器ctrl
+	 */
+	private void initViewAndCtrl() {
+		//get到intent
+		intent = getIntent();
+		
+		//ViewPagerFixed
+		pager = (ViewPagerFixed) findViewById(R.id.gallery01);
+		pager.setOnPageChangeListener(this); //注册滑动监听
+
+		//MyPageAdapter
+		adapter = new GalleryViewPagerAdapter(views_list);
+		pager.setAdapter(adapter); //绑定适配器
+		int id = intent.getIntExtra("ID", 0);
+		pager.setCurrentItem(id);
+	}
+	
+	//监听ViewPager滑动的三个方法
+	@Override
+	public void onPageSelected(int arg0) {
+		location = arg0;
+	}
+	@Override
+	public void onPageScrolled(int arg0, float arg1, int arg2) {
+	}
+
+	@Override
+	public void onPageScrollStateChanged(int arg0) {
+	}
+	
+	//点击监听
+	@Override
+	public void onClick(View v) {
+		switch (v.getId()) {
+		case R.id.button_back: //“返回” 按钮
+			finish();
+			break;
+		case R.id.button_del: //“删除”按钮
+			if (views_list.size() == 1) { //删除最后一张图片
+				Bimp.tempSelectBitmap.clear();
+				Bimp.max = 0;
+				Intent intent = new Intent("data.broadcast.action"); //通知相册展示页面，图片以全部删除：将已选中的图片更改为未选中
+                sendBroadcast(intent);  
+				finish();
+			} else {
+				Bimp.tempSelectBitmap.remove(location);
+				Bimp.max--;
+				pager.removeAllViews();
+				views_list.remove(location);
+				adapter.setListViews(views_list);
+				adapter.notifyDataSetChanged();
+			}
+			break;
+
+		default:
+			break;
+		}
+		
+	}
+	
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/GalleryViewPagerAdapter.java b/src/com/transage/privatespace/gallery/photozoom/GalleryViewPagerAdapter.java
new file mode 100755
index 0000000..d2f22ff
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/GalleryViewPagerAdapter.java
@@ -0,0 +1,58 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.support.v4.view.PagerAdapter;
+import android.view.View;
+
+import java.util.ArrayList;
+
+/**
+ * 自定义的PagerAdapter：用于GalleryActivity界面的ViewPagerFixed的适配
+ * 功能：已选图片在画廊进行预览
+ * @author Tom
+ *
+ */
+public class GalleryViewPagerAdapter extends PagerAdapter {
+
+	private ArrayList<View> views_list;
+	private int size;
+	//构造
+	public GalleryViewPagerAdapter(ArrayList<View> views_list) {
+		super();
+		this.views_list = views_list;
+		size = views_list == null ? 0 : views_list.size();
+	}
+	//set()方法
+	public void setListViews(ArrayList<View> listViews) {
+		this.views_list = listViews;
+		size = listViews == null ? 0 : listViews.size();
+	}
+
+	public int getCount() {
+		return size;
+	}
+
+	public int getItemPosition(Object object) {
+		return POSITION_NONE;
+	}
+
+	public void destroyItem(View arg0, int arg1, Object arg2) {
+		((ViewPagerFixed) arg0).removeView(views_list.get(arg1 % size));
+	}
+
+	public void finishUpdate(View arg0) {
+	}
+
+	public Object instantiateItem(View arg0, int arg1) {
+		try {
+			((ViewPagerFixed) arg0).addView(views_list.get(arg1 % size), 0);
+
+		} catch (Exception e) {
+		}
+		return views_list.get(arg1 % size);
+	}
+
+	public boolean isViewFromObject(View arg0, Object arg1) {
+		return arg0 == arg1;
+	}
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/GridAdapter.java b/src/com/transage/privatespace/gallery/photozoom/GridAdapter.java
new file mode 100755
index 0000000..78fb330
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/GridAdapter.java
@@ -0,0 +1,137 @@
+package com.transage.privatespace.gallery.photozoom;
+
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.BitmapFactory;
+import android.os.Handler;
+import android.os.Message;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+
+import com.transage.privatespace.R;
+
+
+/**
+ * 适配器：将选中的8张图片以GridView的形式进行适配显示
+ * @author Tom
+ *
+ */
+public class GridAdapter extends BaseAdapter {
+	private Context context;
+	private boolean shape;
+	private int selectedPosition = -1;
+
+	// 带参构造
+	public GridAdapter(Context context) {
+		super();
+		this.context = context;
+	}
+
+	// 自己添加的 get()、set()方法
+	public boolean isShape() {
+		return shape;
+	}
+
+	public void setShape(boolean shape) {
+		this.shape = shape;
+	}
+
+	public void setSelectedPosition(int position) {
+		selectedPosition = position;
+	}
+
+	public int getSelectedPosition() {
+		return selectedPosition;
+	}
+
+	// 继承BaseAdapter必须重写的四个方法
+	public int getCount() {
+		if (Bimp.tempSelectBitmap.size() == 8) {
+			return 8;
+		}
+		return (Bimp.tempSelectBitmap.size() + 1);
+	}
+
+	public Object getItem(int arg0) {
+		return null;
+	}
+
+	public long getItemId(int arg0) {
+		return 0;
+	}
+
+	public View getView(int position, View convertView, ViewGroup parent) {
+		ViewHolder holder = null;
+		if (convertView == null) {
+			convertView = LayoutInflater.from(context).inflate(R.layout.item_published_gridview, parent, false);
+			holder = new ViewHolder();
+			holder.image = (ImageView) convertView.findViewById(R.id.item_grida_image);
+			convertView.setTag(holder);
+			//集成 AutoLayout:对于ListView的item的适配，注意添加这一行，即可在item的模版布局上使用px高度
+//	        AutoUtils.autoSize(convertView);
+		} else {
+			holder = (ViewHolder) convertView.getTag();
+		}
+
+		if (position == Bimp.tempSelectBitmap.size()) {
+			holder.image.setImageBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.take_photo));
+			if (position == 8) {
+				holder.image.setVisibility(View.GONE);
+			}
+		} else {
+			holder.image.setImageBitmap(Bimp.tempSelectBitmap.get(position).getBitmap());
+		}
+
+		return convertView;
+	}
+
+	// viewHolder用于存放 gridView模板布局中的控件
+	private class ViewHolder {
+		public ImageView image;
+	}
+
+	
+	/**
+	 * 接收upDate()方法中传递过来的消息，然后刷新适配器
+	 */
+	@SuppressLint("HandlerLeak")
+	Handler handler = new Handler() {
+		public void handleMessage(Message msg) {
+			switch (msg.what) {
+			case 1:
+				notifyDataSetChanged();
+				break;
+			}
+			super.handleMessage(msg);
+		}
+	};
+	/**
+	 * 其他的类 可以通过调用此方法刷新适配器
+	 */
+	public void upDate() {
+		new Thread(new Runnable() {
+			public void run() {
+				while (true) {
+					if (Bimp.max == Bimp.tempSelectBitmap.size()) { //图片达到8张，就跳出这个死循环
+						Message message = new Message();
+						message.what = 1;
+						handler.sendMessage(message);
+						break;
+					} else { //图片未达到8张就不停的刷新适配器
+						Bimp.max += 1;
+						Message message = new Message();
+						message.what = 1;
+						handler.sendMessage(message);//通知主线程刷新适配器
+					}
+				}
+			}
+		}).start();
+	}
+	
+	
+	
+}
\ No newline at end of file
diff --git a/src/com/transage/privatespace/gallery/photozoom/IPhotoView.java b/src/com/transage/privatespace/gallery/photozoom/IPhotoView.java
new file mode 100755
index 0000000..a795513
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/IPhotoView.java
@@ -0,0 +1,128 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.graphics.RectF;
+import android.view.View;
+import android.widget.ImageView;
+
+
+public interface IPhotoView {
+    /**
+     * Returns true if the PhotoView is set to allow zooming of Photos.
+     *
+     * @return true if the PhotoView allows zooming.
+     */
+    boolean canZoom();
+
+    /**
+     * Gets the Display Rectangle of the currently displayed Drawable. The
+     * Rectangle is relative to this View and includes all scaling and
+     * translations.
+     *
+     * @return - RectF of Displayed Drawable
+     */
+    RectF getDisplayRect();
+
+    /**
+     * @return The current minimum scale level. What this value represents depends on the current {@link ImageView.ScaleType}.
+     */
+    float getMinScale();
+
+    /**
+     * @return The current middle scale level. What this value represents depends on the current {@link ImageView.ScaleType}.
+     */
+    float getMidScale();
+
+    /**
+     * @return The current maximum scale level. What this value represents depends on the current {@link ImageView.ScaleType}.
+     */
+    float getMaxScale();
+
+    /**
+     * Returns the current scale value
+     *
+     * @return float - current scale value
+     */
+    float getScale();
+
+    /**
+     * Return the current scale type in use by the ImageView.
+     */
+    ImageView.ScaleType getScaleType();
+
+    /**
+     * Whether to allow the ImageView's parent to intercept the touch event when the photo is scroll to it's horizontal edge.
+     */
+    void setAllowParentInterceptOnEdge(boolean allow);
+
+    /**
+     * Sets the minimum scale level. What this value represents depends on the current {@link ImageView.ScaleType}.
+     */
+    void setMinScale(float minScale);
+
+    /**
+     * Sets the middle scale level. What this value represents depends on the current {@link ImageView.ScaleType}.
+     */
+    void setMidScale(float midScale);
+
+    /**
+     * Sets the maximum scale level. What this value represents depends on the current {@link ImageView.ScaleType}.
+     */
+    void setMaxScale(float maxScale);
+
+    /**
+     * Register a callback to be invoked when the Photo displayed by this view is long-pressed.
+     *
+     * @param listener - Listener to be registered.
+     */
+    void setOnLongClickListener(View.OnLongClickListener listener);
+
+    /**
+     * Register a callback to be invoked when the Matrix has changed for this
+     * View. An example would be the user panning or scaling the Photo.
+     *
+     * @param listener - Listener to be registered.
+     */
+    void setOnMatrixChangeListener(PhotoViewAttacher.OnMatrixChangedListener listener);
+
+    /**
+     * Register a callback to be invoked when the Photo displayed by this View
+     * is tapped with a single tap.
+     *
+     * @param listener - Listener to be registered.
+     */
+    void setOnPhotoTapListener(PhotoViewAttacher.OnPhotoTapListener listener);
+
+    /**
+     * Register a callback to be invoked when the View is tapped with a single
+     * tap.
+     *
+     * @param listener - Listener to be registered.
+     */
+    void setOnViewTapListener(PhotoViewAttacher.OnViewTapListener listener);
+
+    /**
+     * Controls how the image should be resized or moved to match the size of
+     * the ImageView. Any scaling or panning will happen within the confines of
+     * this {@link ImageView.ScaleType}.
+     *
+     * @param scaleType - The desired scaling mode.
+     */
+    void setScaleType(ImageView.ScaleType scaleType);
+
+    /**
+     * Allows you to enable/disable the zoom functionality on the ImageView.
+     * When disable the ImageView reverts to using the FIT_CENTER matrix.
+     *
+     * @param zoomable - Whether the zoom functionality is enabled.
+     */
+    void setZoomable(boolean zoomable);
+
+    /**
+     * Zooms to the specified scale, around the focal point given.
+     *
+     * @param scale  - Scale to zoom to
+     * @param focalX - X Focus Point
+     * @param focalY - Y Focus Point
+     */
+    void zoomTo(float scale, float focalX, float focalY);
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/ImageBucket.java b/src/com/transage/privatespace/gallery/photozoom/ImageBucket.java
new file mode 100755
index 0000000..e24e166
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/ImageBucket.java
@@ -0,0 +1,10 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import java.util.List;
+
+public class ImageBucket {
+	public int count = 0;
+	public String bucketName;
+	public List<ImageItem> imageList;
+
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/ImageItem.java b/src/com/transage/privatespace/gallery/photozoom/ImageItem.java
new file mode 100755
index 0000000..18974d3
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/ImageItem.java
@@ -0,0 +1,134 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.graphics.Bitmap;
+
+import java.io.Serializable;
+
+
+public class ImageItem implements Serializable {
+	/**
+	 *  default 序列化id
+	 */
+	private static final long serialVersionUID = 1L;
+	
+	public String imageId;
+	public String thumbnailPath;
+	public String imagePath;
+	private Bitmap bitmap;
+	public boolean isSelected = false;
+	//add by dongrp
+	public String size;
+	public String displayName;
+	public String title;
+	public String dateAdded;
+	public String mimeType;
+	public String bucketId;
+	public String bucket_display_name;
+
+	
+	public String getImageId() {
+		return imageId;
+	}
+	public void setImageId(String imageId) {
+		this.imageId = imageId;
+	}
+	public String getThumbnailPath() {
+		return thumbnailPath;
+	}
+	public void setThumbnailPath(String thumbnailPath) {
+		this.thumbnailPath = thumbnailPath;
+	}
+	public String getImagePath() {
+		return imagePath;
+	}
+	public void setImagePath(String imagePath) {
+		this.imagePath = imagePath;
+	}
+	public boolean isSelected() {
+		return isSelected;
+	}
+	public void setSelected(boolean isSelected) {
+		this.isSelected = isSelected;
+	}
+	public Bitmap getBitmap() {
+		if(bitmap == null){
+			bitmap = Bimp.handleBitmap(imagePath);
+		}
+		return bitmap;
+	}
+	public void setBitmap(Bitmap bitmap) {
+		this.bitmap = bitmap;
+	}
+
+	public String getSize() {
+		return size;
+	}
+
+
+	public void setSize(String size) {
+		this.size = size;
+	}
+
+	public String getDisplayName() {
+		return displayName;
+	}
+
+	public void setDisplayName(String displayName) {
+		this.displayName = displayName;
+	}
+
+	public String getTitle() {
+		return title;
+	}
+
+	public void setTitle(String title) {
+		this.title = title;
+	}
+
+	public String getDateAdded() {
+		return dateAdded;
+	}
+
+	public void setDateAdded(String dateAdded) {
+		this.dateAdded = dateAdded;
+	}
+
+	public String getMimeType() {
+		return mimeType;
+	}
+
+	public void setMimeType(String mimeType) {
+		this.mimeType = mimeType;
+	}
+
+	public String getBucketId() {
+		return bucketId;
+	}
+
+	public void setBucketId(String bucketId) {
+		this.bucketId = bucketId;
+	}
+
+	public String getBucket_display_name() {
+		return bucket_display_name;
+	}
+
+	public void setBucket_display_name(String bucket_display_name) {
+		this.bucket_display_name = bucket_display_name;
+	}
+
+
+	public String toString() {
+		return "ImageItem{" +
+				"imageId='" + imageId + '\'' +
+				", imagePath='" + imagePath + '\'' +
+				", size='" + size + '\'' +
+				", displayName='" + displayName + '\'' +
+				", title='" + title + '\'' +
+				", dateAdded='" + dateAdded + '\'' +
+				", mimeType='" + mimeType + '\'' +
+				", bucketId='" + bucketId + '\'' +
+				", bucket_display_name='" + bucket_display_name + '\'' +
+				'}';
+	}
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/PhotoView.java b/src/com/transage/privatespace/gallery/photozoom/PhotoView.java
new file mode 100755
index 0000000..2efdc31
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/PhotoView.java
@@ -0,0 +1,161 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.content.Context;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+
+public class PhotoView extends ImageView implements IPhotoView {
+
+	private final PhotoViewAttacher mAttacher;
+
+	private ScaleType mPendingScaleType;
+
+	public PhotoView(Context context) {
+		this(context, null);
+	}
+
+	public PhotoView(Context context, AttributeSet attr) {
+		this(context, attr, 0);
+	}
+	
+	public PhotoView(Context context, AttributeSet attr, int defStyle) {
+		super(context, attr, defStyle);
+		super.setScaleType(ScaleType.MATRIX);
+		mAttacher = new PhotoViewAttacher(this);
+
+		if (null != mPendingScaleType) {
+			setScaleType(mPendingScaleType);
+			mPendingScaleType = null;
+		}
+	}
+
+	@Override
+	public boolean canZoom() {
+		return mAttacher.canZoom();
+	}
+
+	@Override
+	public RectF getDisplayRect() {
+		return mAttacher.getDisplayRect();
+	}
+
+	@Override
+	public float getMinScale() {
+		return mAttacher.getMinScale();
+	}
+
+	@Override
+	public float getMidScale() {
+		return mAttacher.getMidScale();
+	}
+
+	@Override
+	public float getMaxScale() {
+		return mAttacher.getMaxScale();
+	}
+
+	@Override
+	public float getScale() {
+		return mAttacher.getScale();
+	}
+
+	@Override
+	public ScaleType getScaleType() {
+		return mAttacher.getScaleType();
+	}
+
+    @Override
+    public void setAllowParentInterceptOnEdge(boolean allow) {
+        mAttacher.setAllowParentInterceptOnEdge(allow);
+    }
+
+    @Override
+	public void setMinScale(float minScale) {
+		mAttacher.setMinScale(minScale);
+	}
+
+	@Override
+	public void setMidScale(float midScale) {
+		mAttacher.setMidScale(midScale);
+	}
+
+	@Override
+	public void setMaxScale(float maxScale) {
+		mAttacher.setMaxScale(maxScale);
+	}
+
+	@Override
+	// setImageBitmap calls through to this method
+	public void setImageDrawable(Drawable drawable) {
+		super.setImageDrawable(drawable);
+		if (null != mAttacher) {
+			mAttacher.update();
+		}
+	}
+
+	@Override
+	public void setImageResource(int resId) {
+		super.setImageResource(resId);
+		if (null != mAttacher) {
+			mAttacher.update();
+		}
+	}
+
+	@Override
+	public void setImageURI(Uri uri) {
+		super.setImageURI(uri);
+		if (null != mAttacher) {
+			mAttacher.update();
+		}
+	}
+
+	@Override
+	public void setOnMatrixChangeListener(PhotoViewAttacher.OnMatrixChangedListener listener) {
+		mAttacher.setOnMatrixChangeListener(listener);
+	}
+
+	@Override
+	public void setOnLongClickListener(OnLongClickListener l) {
+		mAttacher.setOnLongClickListener(l);
+	}
+
+	@Override
+	public void setOnPhotoTapListener(PhotoViewAttacher.OnPhotoTapListener listener) {
+		mAttacher.setOnPhotoTapListener(listener);
+	}
+
+	@Override
+	public void setOnViewTapListener(PhotoViewAttacher.OnViewTapListener listener) {
+		mAttacher.setOnViewTapListener(listener);
+	}
+
+	@Override
+	public void setScaleType(ScaleType scaleType) {
+		if (null != mAttacher) {
+			mAttacher.setScaleType(scaleType);
+		} else {
+			mPendingScaleType = scaleType;
+		}
+	}
+
+	@Override
+	public void setZoomable(boolean zoomable) {
+		mAttacher.setZoomable(zoomable);
+	}
+
+	@Override
+	public void zoomTo(float scale, float focalX, float focalY) {
+		mAttacher.zoomTo(scale, focalX, focalY);
+	}
+
+	@Override
+	protected void onDetachedFromWindow() {
+		mAttacher.cleanup();
+		super.onDetachedFromWindow();
+	}
+
+}
\ No newline at end of file
diff --git a/src/com/transage/privatespace/gallery/photozoom/PhotoViewAttacher.java b/src/com/transage/privatespace/gallery/photozoom/PhotoViewAttacher.java
new file mode 100755
index 0000000..08aa5ea
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/PhotoViewAttacher.java
@@ -0,0 +1,987 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.Matrix;
+import android.graphics.Matrix.ScaleToFit;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnLongClickListener;
+import android.view.ViewTreeObserver;
+import android.widget.ImageView;
+import android.widget.ImageView.ScaleType;
+
+import java.lang.ref.WeakReference;
+
+public class PhotoViewAttacher implements IPhotoView, View.OnTouchListener,
+		VersionedGestureDetector.OnGestureListener,
+		GestureDetector.OnDoubleTapListener,
+		ViewTreeObserver.OnGlobalLayoutListener {
+
+	static final String LOG_TAG = "PhotoViewAttacher";
+
+	// let debug flag be dynamic, but still Proguard can be used to remove from
+	// release builds
+	static final boolean DEBUG = Log.isLoggable(LOG_TAG, Log.DEBUG);
+
+	static final int EDGE_NONE = -1;
+	static final int EDGE_LEFT = 0;
+	static final int EDGE_RIGHT = 1;
+	static final int EDGE_BOTH = 2;
+
+	public static final float DEFAULT_MAX_SCALE = 3.0f;
+	public static final float DEFAULT_MID_SCALE = 1.75f;
+	public static final float DEFAULT_MIN_SCALE = 1.0f;
+
+	private float mMinScale = DEFAULT_MIN_SCALE;
+	private float mMidScale = DEFAULT_MID_SCALE;
+	private float mMaxScale = DEFAULT_MAX_SCALE;
+
+	private boolean mAllowParentInterceptOnEdge = true;
+
+	private static void checkZoomLevels(float minZoom, float midZoom,
+			float maxZoom) {
+		if (minZoom >= midZoom) {
+			throw new IllegalArgumentException(
+					"MinZoom should be less than MidZoom");
+		} else if (midZoom >= maxZoom) {
+			throw new IllegalArgumentException(
+					"MidZoom should be less than MaxZoom");
+		}
+	}
+
+	/**
+	 * @return true if the ImageView exists, and it's Drawable existss
+	 */
+	private static boolean hasDrawable(ImageView imageView) {
+		return null != imageView && null != imageView.getDrawable();
+	}
+
+	/**
+	 * @return true if the ScaleType is supported.
+	 */
+	private static boolean isSupportedScaleType(final ScaleType scaleType) {
+		if (null == scaleType) {
+			return false;
+		}
+
+		switch (scaleType) {
+		case MATRIX:
+			throw new IllegalArgumentException(scaleType.name()
+					+ " is not supported in PhotoView");
+
+		default:
+			return true;
+		}
+	}
+
+	/**
+	 * Set's the ImageView's ScaleType to Matrix.
+	 */
+	private static void setImageViewScaleTypeMatrix(ImageView imageView) {
+		if (null != imageView) {
+			if (imageView instanceof PhotoView) {
+				/**
+				 * PhotoView sets it's own ScaleType to Matrix, then diverts all
+				 * calls setScaleType to this.setScaleType. Basically we don't
+				 * need to do anything here
+				 */
+			} else {
+				imageView.setScaleType(ScaleType.MATRIX);
+			}
+		}
+	}
+
+	private WeakReference<ImageView> mImageView;
+	private ViewTreeObserver mViewTreeObserver;
+
+	// Gesture Detectors
+	private GestureDetector mGestureDetector;
+	private VersionedGestureDetector mScaleDragDetector;
+
+	// These are set so we don't keep allocating them on the heap
+	private final Matrix mBaseMatrix = new Matrix();
+	private final Matrix mDrawMatrix = new Matrix();
+	private final Matrix mSuppMatrix = new Matrix();
+	private final RectF mDisplayRect = new RectF();
+	private final float[] mMatrixValues = new float[9];
+
+	// Listeners
+	private OnMatrixChangedListener mMatrixChangeListener;
+	private OnPhotoTapListener mPhotoTapListener;
+	private OnViewTapListener mViewTapListener;
+	private OnLongClickListener mLongClickListener;
+
+	private int mIvTop, mIvRight, mIvBottom, mIvLeft;
+	private FlingRunnable mCurrentFlingRunnable;
+	private int mScrollEdge = EDGE_BOTH;
+
+	private boolean mZoomEnabled;
+	private ScaleType mScaleType = ScaleType.FIT_CENTER;
+
+	public PhotoViewAttacher(ImageView imageView) {
+		mImageView = new WeakReference<ImageView>(imageView);
+
+		imageView.setOnTouchListener(this);
+
+		mViewTreeObserver = imageView.getViewTreeObserver();
+		mViewTreeObserver.addOnGlobalLayoutListener(this);
+
+		// Make sure we using MATRIX Scale Type
+		setImageViewScaleTypeMatrix(imageView);
+
+		if (!imageView.isInEditMode()) {
+			// Create Gesture Detectors...
+			mScaleDragDetector = VersionedGestureDetector.newInstance(
+					imageView.getContext(), this);
+
+			mGestureDetector = new GestureDetector(imageView.getContext(),
+					new GestureDetector.SimpleOnGestureListener() {
+
+						// forward long click listener
+						@Override
+						public void onLongPress(MotionEvent e) {
+							if (null != mLongClickListener) {
+								mLongClickListener.onLongClick(mImageView.get());
+							}
+						}
+					});
+
+			mGestureDetector.setOnDoubleTapListener(this);
+
+			// Finally, update the UI so that we're zoomable
+			setZoomable(true);
+		}
+	}
+
+	@Override
+	public final boolean canZoom() {
+		return mZoomEnabled;
+	}
+
+	/**
+	 * Clean-up the resources attached to this object. This needs to be called
+	 * when the ImageView is no longer used. A good example is from
+	 * {@link View#onDetachedFromWindow()} or from
+	 * {@link android.app.Activity#onDestroy()}. This is automatically called if
+	 * you are using {@link uk.co.senab.photoview.PhotoView}.
+	 */
+	@SuppressLint("NewApi")
+	// @SuppressWarnings("deprecation")
+	// public final void cleanup() {
+	// if (null != mImageView) {
+	// mImageView.get().getViewTreeObserver().removeGlobalOnLayoutListener(this);
+	// }
+	// mViewTreeObserver = null;
+	//
+	// // Clear listeners too
+	// mMatrixChangeListener = null;
+	// mPhotoTapListener = null;
+	// mViewTapListener = null;
+	//
+	// // Finally, clear ImageView
+	// mImageView = null;
+	// }
+	@SuppressWarnings("deprecation")
+	public final void cleanup() {
+		if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
+			if (null != mImageView) {
+				mImageView.get().getViewTreeObserver()
+						.removeOnGlobalLayoutListener(this);
+			}
+
+			if (null != mViewTreeObserver && mViewTreeObserver.isAlive()) {
+				mViewTreeObserver.removeOnGlobalLayoutListener(this);
+
+				mViewTreeObserver = null;
+
+				// Clear listeners too
+				mMatrixChangeListener = null;
+				mPhotoTapListener = null;
+				mViewTapListener = null;
+				// Finally, clear ImageView
+				mImageView = null;
+			}
+
+		} else {
+			if (null != mImageView) {
+				mImageView.get().getViewTreeObserver()
+						.removeGlobalOnLayoutListener(this);
+			}
+
+			if (null != mViewTreeObserver && mViewTreeObserver.isAlive()) {
+				mViewTreeObserver.removeGlobalOnLayoutListener(this);
+
+				mViewTreeObserver = null;
+
+				// Clear listeners too
+				mMatrixChangeListener = null;
+				mPhotoTapListener = null;
+				mViewTapListener = null;
+				// Finally, clear ImageView
+				mImageView = null;
+			}
+		}
+	}
+
+	@Override
+	public final RectF getDisplayRect() {
+		checkMatrixBounds();
+		return getDisplayRect(getDisplayMatrix());
+	}
+
+	public final ImageView getImageView() {
+		ImageView imageView = null;
+
+		if (null != mImageView) {
+			imageView = mImageView.get();
+		}
+
+		// If we don't have an ImageView, call cleanup()
+		if (null == imageView) {
+			cleanup();
+			throw new IllegalStateException(
+					"ImageView no longer exists. You should not use this PhotoViewAttacher any more.");
+		}
+
+		return imageView;
+	}
+
+	@Override
+	public float getMinScale() {
+		return mMinScale;
+	}
+
+	@Override
+	public float getMidScale() {
+		return mMidScale;
+	}
+
+	@Override
+	public float getMaxScale() {
+		return mMaxScale;
+	}
+
+	@Override
+	public final float getScale() {
+		return getValue(mSuppMatrix, Matrix.MSCALE_X);
+	}
+
+	@Override
+	public final ScaleType getScaleType() {
+		return mScaleType;
+	}
+
+	public final boolean onDoubleTap(MotionEvent ev) {
+		try {
+			float scale = getScale();
+			float x = ev.getX();
+			float y = ev.getY();
+
+			if (scale < mMidScale) {
+				zoomTo(mMidScale, x, y);
+			} else if (scale >= mMidScale && scale < mMaxScale) {
+				zoomTo(mMaxScale, x, y);
+			} else {
+				zoomTo(mMinScale, x, y);
+			}
+		} catch (ArrayIndexOutOfBoundsException e) {
+			// Can sometimes happen when getX() and getY() is called
+		}
+
+		return true;
+	}
+
+	public final boolean onDoubleTapEvent(MotionEvent e) {
+		// Wait for the confirmed onDoubleTap() instead
+		return false;
+	}
+
+	public final void onDrag(float dx, float dy) {
+		if (DEBUG) {
+			Log.d(LOG_TAG, String.format("onDrag: dx: %.2f. dy: %.2f", dx, dy));
+		}
+
+		ImageView imageView = getImageView();
+
+		if (null != imageView && hasDrawable(imageView)) {
+			mSuppMatrix.postTranslate(dx, dy);
+			checkAndDisplayMatrix();
+
+			/**
+			 * Here we decide whether to let the ImageView's parent to start
+			 * taking over the touch event.
+			 * 
+			 * First we check whether this function is enabled. We never want
+			 * the parent to take over if we're scaling. We then check the edge
+			 * we're on, and the direction of the scroll (i.e. if we're pulling
+			 * against the edge, aka 'overscrolling', let the parent take over).
+			 */
+			if (mAllowParentInterceptOnEdge && !mScaleDragDetector.isScaling()) {
+				if (mScrollEdge == EDGE_BOTH
+						|| (mScrollEdge == EDGE_LEFT && dx >= 1f)
+						|| (mScrollEdge == EDGE_RIGHT && dx <= -1f)) {
+					imageView.getParent().requestDisallowInterceptTouchEvent(
+							false);
+				}
+			}
+		}
+	}
+
+	@Override
+	public final void onFling(float startX, float startY, float velocityX,
+			float velocityY) {
+		if (DEBUG) {
+			Log.d(LOG_TAG, "onFling. sX: " + startX + " sY: " + startY
+					+ " Vx: " + velocityX + " Vy: " + velocityY);
+		}
+
+		ImageView imageView = getImageView();
+		if (hasDrawable(imageView)) {
+			mCurrentFlingRunnable = new FlingRunnable(imageView.getContext());
+			mCurrentFlingRunnable.fling(imageView.getWidth(),
+					imageView.getHeight(), (int) velocityX, (int) velocityY);
+			imageView.post(mCurrentFlingRunnable);
+		}
+	}
+
+	@Override
+	public final void onGlobalLayout() {
+		ImageView imageView = getImageView();
+
+		if (null != imageView && mZoomEnabled) {
+			final int top = imageView.getTop();
+			final int right = imageView.getRight();
+			final int bottom = imageView.getBottom();
+			final int left = imageView.getLeft();
+
+			/**
+			 * We need to check whether the ImageView's bounds have changed.
+			 * This would be easier if we targeted API 11+ as we could just use
+			 * View.OnLayoutChangeListener. Instead we have to replicate the
+			 * work, keeping track of the ImageView's bounds and then checking
+			 * if the values change.
+			 */
+			if (top != mIvTop || bottom != mIvBottom || left != mIvLeft
+					|| right != mIvRight) {
+				// Update our base matrix, as the bounds have changed
+				updateBaseMatrix(imageView.getDrawable());
+
+				// Update values as something has changed
+				mIvTop = top;
+				mIvRight = right;
+				mIvBottom = bottom;
+				mIvLeft = left;
+			}
+		}
+	}
+
+	public final void onScale(float scaleFactor, float focusX, float focusY) {
+		if (DEBUG) {
+			Log.d(LOG_TAG, String.format(
+					"onScale: scale: %.2f. fX: %.2f. fY: %.2f", scaleFactor,
+					focusX, focusY));
+		}
+
+		if (hasDrawable(getImageView())
+				&& (getScale() < mMaxScale || scaleFactor < 1f)) {
+			mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);
+			checkAndDisplayMatrix();
+		}
+	}
+
+	public final boolean onSingleTapConfirmed(MotionEvent e) {
+		ImageView imageView = getImageView();
+
+		if (null != imageView) {
+			if (null != mPhotoTapListener) {
+				final RectF displayRect = getDisplayRect();
+
+				if (null != displayRect) {
+					final float x = e.getX(), y = e.getY();
+
+					// Check to see if the user tapped on the photo
+					if (displayRect.contains(x, y)) {
+
+						float xResult = (x - displayRect.left)
+								/ displayRect.width();
+						float yResult = (y - displayRect.top)
+								/ displayRect.height();
+
+						mPhotoTapListener.onPhotoTap(imageView, xResult,
+								yResult);
+						return true;
+					}
+				}
+			}
+			if (null != mViewTapListener) {
+				mViewTapListener.onViewTap(imageView, e.getX(), e.getY());
+			}
+		}
+
+		return false;
+	}
+
+	@Override
+	public final boolean onTouch(View v, MotionEvent ev) {
+		boolean handled = false;
+
+		if (mZoomEnabled) {
+			switch (ev.getAction()) {
+			case MotionEvent.ACTION_DOWN:
+				// First, disable the Parent from intercepting the touch
+				// event
+				v.getParent().requestDisallowInterceptTouchEvent(true);
+
+				// If we're flinging, and the user presses down, cancel
+				// fling
+				cancelFling();
+				break;
+
+			case MotionEvent.ACTION_CANCEL:
+			case MotionEvent.ACTION_UP:
+				// If the user has zoomed less than min scale, zoom back
+				// to min scale
+				if (getScale() < mMinScale) {
+					RectF rect = getDisplayRect();
+					if (null != rect) {
+						v.post(new AnimatedZoomRunnable(getScale(), mMinScale,
+								rect.centerX(), rect.centerY()));
+						handled = true;
+					}
+				}
+				break;
+			}
+
+			// Check to see if the user double tapped
+			if (null != mGestureDetector && mGestureDetector.onTouchEvent(ev)) {
+				handled = true;
+			}
+
+			// Finally, try the Scale/Drag detector
+			if (null != mScaleDragDetector
+					&& mScaleDragDetector.onTouchEvent(ev)) {
+				handled = true;
+			}
+		}
+
+		return handled;
+	}
+
+	@Override
+	public void setAllowParentInterceptOnEdge(boolean allow) {
+		mAllowParentInterceptOnEdge = allow;
+	}
+
+	@Override
+	public void setMinScale(float minScale) {
+		checkZoomLevels(minScale, mMidScale, mMaxScale);
+		mMinScale = minScale;
+	}
+
+	@Override
+	public void setMidScale(float midScale) {
+		checkZoomLevels(mMinScale, midScale, mMaxScale);
+		mMidScale = midScale;
+	}
+
+	@Override
+	public void setMaxScale(float maxScale) {
+		checkZoomLevels(mMinScale, mMidScale, maxScale);
+		mMaxScale = maxScale;
+	}
+
+	@Override
+	public final void setOnLongClickListener(OnLongClickListener listener) {
+		mLongClickListener = listener;
+	}
+
+	@Override
+	public final void setOnMatrixChangeListener(OnMatrixChangedListener listener) {
+		mMatrixChangeListener = listener;
+	}
+
+	@Override
+	public final void setOnPhotoTapListener(OnPhotoTapListener listener) {
+		mPhotoTapListener = listener;
+	}
+
+	@Override
+	public final void setOnViewTapListener(OnViewTapListener listener) {
+		mViewTapListener = listener;
+	}
+
+	@Override
+	public final void setScaleType(ScaleType scaleType) {
+		if (isSupportedScaleType(scaleType) && scaleType != mScaleType) {
+			mScaleType = scaleType;
+
+			// Finally update
+			update();
+		}
+	}
+
+	@Override
+	public final void setZoomable(boolean zoomable) {
+		mZoomEnabled = zoomable;
+		update();
+	}
+
+	public final void update() {
+		ImageView imageView = getImageView();
+
+		if (null != imageView) {
+			if (mZoomEnabled) {
+				// Make sure we using MATRIX Scale Type
+				setImageViewScaleTypeMatrix(imageView);
+
+				// Update the base matrix using the current drawable
+				updateBaseMatrix(imageView.getDrawable());
+			} else {
+				// Reset the Matrix...
+				resetMatrix();
+			}
+		}
+	}
+
+	@Override
+	public final void zoomTo(float scale, float focalX, float focalY) {
+		ImageView imageView = getImageView();
+
+		if (null != imageView) {
+			imageView.post(new AnimatedZoomRunnable(getScale(), scale, focalX,
+					focalY));
+		}
+	}
+
+	protected Matrix getDisplayMatrix() {
+		mDrawMatrix.set(mBaseMatrix);
+		mDrawMatrix.postConcat(mSuppMatrix);
+		return mDrawMatrix;
+	}
+
+	private void cancelFling() {
+		if (null != mCurrentFlingRunnable) {
+			mCurrentFlingRunnable.cancelFling();
+			mCurrentFlingRunnable = null;
+		}
+	}
+
+	/**
+	 * Helper method that simply checks the Matrix, and then displays the result
+	 */
+	private void checkAndDisplayMatrix() {
+		checkMatrixBounds();
+		setImageViewMatrix(getDisplayMatrix());
+	}
+
+	private void checkImageViewScaleType() {
+		ImageView imageView = getImageView();
+
+		/**
+		 * PhotoView's getScaleType() will just divert to this.getScaleType() so
+		 * only call if we're not attached to a PhotoView.
+		 */
+		if (null != imageView && !(imageView instanceof PhotoView)) {
+			if (imageView.getScaleType() != ScaleType.MATRIX) {
+				throw new IllegalStateException(
+						"The ImageView's ScaleType has been changed since attaching a PhotoViewAttacher");
+			}
+		}
+	}
+
+	private void checkMatrixBounds() {
+		final ImageView imageView = getImageView();
+		if (null == imageView) {
+			return;
+		}
+
+		final RectF rect = getDisplayRect(getDisplayMatrix());
+		if (null == rect) {
+			return;
+		}
+
+		final float height = rect.height(), width = rect.width();
+		float deltaX = 0, deltaY = 0;
+
+		final int viewHeight = imageView.getHeight();
+		if (height <= viewHeight) {
+			switch (mScaleType) {
+			case FIT_START:
+				deltaY = -rect.top;
+				break;
+			case FIT_END:
+				deltaY = viewHeight - height - rect.top;
+				break;
+			default:
+				deltaY = (viewHeight - height) / 2 - rect.top;
+				break;
+			}
+		} else if (rect.top > 0) {
+			deltaY = -rect.top;
+		} else if (rect.bottom < viewHeight) {
+			deltaY = viewHeight - rect.bottom;
+		}
+
+		final int viewWidth = imageView.getWidth();
+		if (width <= viewWidth) {
+			switch (mScaleType) {
+			case FIT_START:
+				deltaX = -rect.left;
+				break;
+			case FIT_END:
+				deltaX = viewWidth - width - rect.left;
+				break;
+			default:
+				deltaX = (viewWidth - width) / 2 - rect.left;
+				break;
+			}
+			mScrollEdge = EDGE_BOTH;
+		} else if (rect.left > 0) {
+			mScrollEdge = EDGE_LEFT;
+			deltaX = -rect.left;
+		} else if (rect.right < viewWidth) {
+			deltaX = viewWidth - rect.right;
+			mScrollEdge = EDGE_RIGHT;
+		} else {
+			mScrollEdge = EDGE_NONE;
+		}
+
+		// Finally actually translate the matrix
+		mSuppMatrix.postTranslate(deltaX, deltaY);
+	}
+
+	/**
+	 * Helper method that maps the supplied Matrix to the current Drawable
+	 * 
+	 * @param matrix
+	 *            - Matrix to map Drawable against
+	 * @return RectF - Displayed Rectangle
+	 */
+	private RectF getDisplayRect(Matrix matrix) {
+		ImageView imageView = getImageView();
+
+		if (null != imageView) {
+			Drawable d = imageView.getDrawable();
+			if (null != d) {
+				mDisplayRect.set(0, 0, d.getIntrinsicWidth(),
+						d.getIntrinsicHeight());
+				matrix.mapRect(mDisplayRect);
+				return mDisplayRect;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Helper method that 'unpacks' a Matrix and returns the required value
+	 * 
+	 * @param matrix
+	 *            - Matrix to unpack
+	 * @param whichValue
+	 *            - Which value from Matrix.M* to return
+	 * @return float - returned value
+	 */
+	private float getValue(Matrix matrix, int whichValue) {
+		matrix.getValues(mMatrixValues);
+		return mMatrixValues[whichValue];
+	}
+
+	/**
+	 * Resets the Matrix back to FIT_CENTER, and then displays it.s
+	 */
+	private void resetMatrix() {
+		mSuppMatrix.reset();
+		setImageViewMatrix(getDisplayMatrix());
+		checkMatrixBounds();
+	}
+
+	private void setImageViewMatrix(Matrix matrix) {
+		ImageView imageView = getImageView();
+		if (null != imageView) {
+
+			checkImageViewScaleType();
+			imageView.setImageMatrix(matrix);
+
+			// Call MatrixChangedListener if needed
+			if (null != mMatrixChangeListener) {
+				RectF displayRect = getDisplayRect(matrix);
+				if (null != displayRect) {
+					mMatrixChangeListener.onMatrixChanged(displayRect);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Calculate Matrix for FIT_CENTER
+	 * 
+	 * @param d
+	 *            - Drawable being displayed
+	 */
+	private void updateBaseMatrix(Drawable d) {
+		ImageView imageView = getImageView();
+		if (null == imageView || null == d) {
+			return;
+		}
+
+		final float viewWidth = imageView.getWidth();
+		final float viewHeight = imageView.getHeight();
+		final int drawableWidth = d.getIntrinsicWidth();
+		final int drawableHeight = d.getIntrinsicHeight();
+
+		mBaseMatrix.reset();
+
+		final float widthScale = viewWidth / drawableWidth;
+		final float heightScale = viewHeight / drawableHeight;
+
+		if (mScaleType == ScaleType.CENTER) {
+			mBaseMatrix.postTranslate((viewWidth - drawableWidth) / 2F,
+					(viewHeight - drawableHeight) / 2F);
+
+		} else if (mScaleType == ScaleType.CENTER_CROP) {
+			float scale = Math.max(widthScale, heightScale);
+			mBaseMatrix.postScale(scale, scale);
+			mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,
+					(viewHeight - drawableHeight * scale) / 2F);
+
+		} else if (mScaleType == ScaleType.CENTER_INSIDE) {
+			float scale = Math.min(1.0f, Math.min(widthScale, heightScale));
+			mBaseMatrix.postScale(scale, scale);
+			mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,
+					(viewHeight - drawableHeight * scale) / 2F);
+
+		} else {
+			RectF mTempSrc = new RectF(0, 0, drawableWidth, drawableHeight);
+			RectF mTempDst = new RectF(0, 0, viewWidth, viewHeight);
+
+			switch (mScaleType) {
+			case FIT_CENTER:
+				mBaseMatrix
+						.setRectToRect(mTempSrc, mTempDst, ScaleToFit.CENTER);
+				break;
+
+			case FIT_START:
+				mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.START);
+				break;
+
+			case FIT_END:
+				mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.END);
+				break;
+
+			case FIT_XY:
+				mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.FILL);
+				break;
+
+			default:
+				break;
+			}
+		}
+
+		resetMatrix();
+	}
+
+	/**
+	 * Interface definition for a callback to be invoked when the internal
+	 * Matrix has changed for this View.
+	 * 
+	 * @author Chris Banes
+	 */
+	public static interface OnMatrixChangedListener {
+		/**
+		 * Callback for when the Matrix displaying the Drawable has changed.
+		 * This could be because the View's bounds have changed, or the user has
+		 * zoomed.
+		 * 
+		 * @param rect
+		 *            - Rectangle displaying the Drawable's new bounds.
+		 */
+		void onMatrixChanged(RectF rect);
+	}
+
+	/**
+	 * Interface definition for a callback to be invoked when the Photo is
+	 * tapped with a single tap.
+	 * 
+	 * @author Chris Banes
+	 */
+	public static interface OnPhotoTapListener {
+
+		/**
+		 * A callback to receive where the user taps on a photo. You will only
+		 * receive a callback if the user taps on the actual photo, tapping on
+		 * 'whitespace' will be ignored.
+		 * 
+		 * @param view
+		 *            - View the user tapped.
+		 * @param x
+		 *            - where the user tapped from the of the Drawable, as
+		 *            percentage of the Drawable width.
+		 * @param y
+		 *            - where the user tapped from the top of the Drawable, as
+		 *            percentage of the Drawable height.
+		 */
+		void onPhotoTap(View view, float x, float y);
+	}
+
+	/**
+	 * Interface definition for a callback to be invoked when the ImageView is
+	 * tapped with a single tap.
+	 * 
+	 * @author Chris Banes
+	 */
+	public static interface OnViewTapListener {
+
+		/**
+		 * A callback to receive where the user taps on a ImageView. You will
+		 * receive a callback if the user taps anywhere on the view, tapping on
+		 * 'whitespace' will not be ignored.
+		 * 
+		 * @param view
+		 *            - View the user tapped.
+		 * @param x
+		 *            - where the user tapped from the left of the View.
+		 * @param y
+		 *            - where the user tapped from the top of the View.
+		 */
+		void onViewTap(View view, float x, float y);
+	}
+
+	private class AnimatedZoomRunnable implements Runnable {
+
+		// These are 'postScale' values, means they're compounded each iteration
+		static final float ANIMATION_SCALE_PER_ITERATION_IN = 1.07f;
+		static final float ANIMATION_SCALE_PER_ITERATION_OUT = 0.93f;
+
+		private final float mFocalX, mFocalY;
+		private final float mTargetZoom;
+		private final float mDeltaScale;
+
+		public AnimatedZoomRunnable(final float currentZoom,
+				final float targetZoom, final float focalX, final float focalY) {
+			mTargetZoom = targetZoom;
+			mFocalX = focalX;
+			mFocalY = focalY;
+
+			if (currentZoom < targetZoom) {
+				mDeltaScale = ANIMATION_SCALE_PER_ITERATION_IN;
+			} else {
+				mDeltaScale = ANIMATION_SCALE_PER_ITERATION_OUT;
+			}
+		}
+
+		public void run() {
+			ImageView imageView = getImageView();
+
+			if (null != imageView) {
+				mSuppMatrix.postScale(mDeltaScale, mDeltaScale, mFocalX,
+						mFocalY);
+				checkAndDisplayMatrix();
+
+				final float currentScale = getScale();
+
+				if ((mDeltaScale > 1f && currentScale < mTargetZoom)
+						|| (mDeltaScale < 1f && mTargetZoom < currentScale)) {
+					// We haven't hit our target scale yet, so post ourselves
+					// again
+					Compat.postOnAnimation(imageView, this);
+
+				} else {
+					// We've scaled past our target zoom, so calculate the
+					// necessary scale so we're back at target zoom
+					final float delta = mTargetZoom / currentScale;
+					mSuppMatrix.postScale(delta, delta, mFocalX, mFocalY);
+					checkAndDisplayMatrix();
+				}
+			}
+		}
+	}
+
+	private class FlingRunnable implements Runnable {
+
+		private final ScrollerProxy mScroller;
+		private int mCurrentX, mCurrentY;
+
+		public FlingRunnable(Context context) {
+			mScroller = ScrollerProxy.getScroller(context);
+		}
+
+		public void cancelFling() {
+			if (DEBUG) {
+				Log.d(LOG_TAG, "Cancel Fling");
+			}
+			mScroller.forceFinished(true);
+		}
+
+		public void fling(int viewWidth, int viewHeight, int velocityX,
+				int velocityY) {
+			final RectF rect = getDisplayRect();
+			if (null == rect) {
+				return;
+			}
+
+			final int startX = Math.round(-rect.left);
+			final int minX, maxX, minY, maxY;
+
+			if (viewWidth < rect.width()) {
+				minX = 0;
+				maxX = Math.round(rect.width() - viewWidth);
+			} else {
+				minX = maxX = startX;
+			}
+
+			final int startY = Math.round(-rect.top);
+			if (viewHeight < rect.height()) {
+				minY = 0;
+				maxY = Math.round(rect.height() - viewHeight);
+			} else {
+				minY = maxY = startY;
+			}
+
+			mCurrentX = startX;
+			mCurrentY = startY;
+
+			if (DEBUG) {
+				Log.d(LOG_TAG, "fling. StartX:" + startX + " StartY:" + startY
+						+ " MaxX:" + maxX + " MaxY:" + maxY);
+			}
+
+			// If we actually can move, fling the scroller
+			if (startX != maxX || startY != maxY) {
+				mScroller.fling(startX, startY, velocityX, velocityY, minX,
+						maxX, minY, maxY, 0, 0);
+			}
+		}
+
+		@Override
+		public void run() {
+			ImageView imageView = getImageView();
+			if (null != imageView && mScroller.computeScrollOffset()) {
+
+				final int newX = mScroller.getCurrX();
+				final int newY = mScroller.getCurrY();
+
+				if (DEBUG) {
+					Log.d(LOG_TAG, "fling run(). CurrentX:" + mCurrentX
+							+ " CurrentY:" + mCurrentY + " NewX:" + newX
+							+ " NewY:" + newY);
+				}
+
+				mSuppMatrix.postTranslate(mCurrentX - newX, mCurrentY - newY);
+				setImageViewMatrix(getDisplayMatrix());
+
+				mCurrentX = newX;
+				mCurrentY = newY;
+
+				// Post On animation
+				Compat.postOnAnimation(imageView, this);
+			}
+		}
+	}
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/SDK16.java b/src/com/transage/privatespace/gallery/photozoom/SDK16.java
new file mode 100755
index 0000000..06dcc85
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/SDK16.java
@@ -0,0 +1,13 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.annotation.TargetApi;
+import android.view.View;
+
+@TargetApi(16)
+public class SDK16 {
+
+	public static void postOnAnimation(View view, Runnable r) {
+		view.postOnAnimation(r);
+	}
+	
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/ScrollerProxy.java b/src/com/transage/privatespace/gallery/photozoom/ScrollerProxy.java
new file mode 100755
index 0000000..8154889
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/ScrollerProxy.java
@@ -0,0 +1,101 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.widget.OverScroller;
+import android.widget.Scroller;
+
+public abstract class ScrollerProxy {
+
+	public static ScrollerProxy getScroller(Context context) {
+		if (VERSION.SDK_INT < VERSION_CODES.GINGERBREAD) {
+			return new PreGingerScroller(context);
+		} else {
+			return new GingerScroller(context);
+		}
+	}
+
+	public abstract boolean computeScrollOffset();
+
+	public abstract void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY,
+			int maxY, int overX, int overY);
+
+	public abstract void forceFinished(boolean finished);
+
+	public abstract int getCurrX();
+
+	public abstract int getCurrY();
+
+	@TargetApi(9)
+	private static class GingerScroller extends ScrollerProxy {
+
+		private OverScroller mScroller;
+
+		public GingerScroller(Context context) {
+			mScroller = new OverScroller(context);
+		}
+
+		@Override
+		public boolean computeScrollOffset() {
+			return mScroller.computeScrollOffset();
+		}
+
+		@Override
+		public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY,
+				int overX, int overY) {
+			mScroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
+		}
+
+		@Override
+		public void forceFinished(boolean finished) {
+			mScroller.forceFinished(finished);
+		}
+
+		@Override
+		public int getCurrX() {
+			return mScroller.getCurrX();
+		}
+
+		@Override
+		public int getCurrY() {
+			return mScroller.getCurrY();
+		}
+	}
+
+	private static class PreGingerScroller extends ScrollerProxy {
+
+		private Scroller mScroller;
+
+		public PreGingerScroller(Context context) {
+			mScroller = new Scroller(context);
+		}
+
+		@Override
+		public boolean computeScrollOffset() {
+			return mScroller.computeScrollOffset();
+		}
+
+		@Override
+		public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY,
+				int overX, int overY) {
+			mScroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY);
+		}
+
+		@Override
+		public void forceFinished(boolean finished) {
+			mScroller.forceFinished(finished);
+		}
+
+		@Override
+		public int getCurrX() {
+			return mScroller.getCurrX();
+		}
+
+		@Override
+		public int getCurrY() {
+			return mScroller.getCurrY();
+		}
+	}
+}
diff --git a/src/com/transage/privatespace/gallery/photozoom/VersionedGestureDetector.java b/src/com/transage/privatespace/gallery/photozoom/VersionedGestureDetector.java
new file mode 100755
index 0000000..f8d04c5
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/VersionedGestureDetector.java
@@ -0,0 +1,252 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build;
+import android.view.MotionEvent;
+import android.view.ScaleGestureDetector;
+import android.view.ScaleGestureDetector.OnScaleGestureListener;
+import android.view.VelocityTracker;
+import android.view.ViewConfiguration;
+
+public abstract class VersionedGestureDetector {
+	static final String LOG_TAG = "VersionedGestureDetector";
+	OnGestureListener mListener;
+
+	public static VersionedGestureDetector newInstance(Context context, OnGestureListener listener) {
+		final int sdkVersion = Build.VERSION.SDK_INT;
+		VersionedGestureDetector detector = null;
+
+		if (sdkVersion < Build.VERSION_CODES.ECLAIR) {
+			detector = new CupcakeDetector(context);
+		} else if (sdkVersion < Build.VERSION_CODES.FROYO) {
+			detector = new EclairDetector(context);
+		} else {
+			detector = new FroyoDetector(context);
+		}
+
+		detector.mListener = listener;
+
+		return detector;
+	}
+
+	public abstract boolean onTouchEvent(MotionEvent ev);
+
+	public abstract boolean isScaling();
+
+	public static interface OnGestureListener {
+		public void onDrag(float dx, float dy);
+
+		public void onFling(float startX, float startY, float velocityX, float velocityY);
+
+		public void onScale(float scaleFactor, float focusX, float focusY);
+	}
+
+	private static class CupcakeDetector extends VersionedGestureDetector {
+
+		float mLastTouchX;
+		float mLastTouchY;
+		final float mTouchSlop;
+		final float mMinimumVelocity;
+
+		public CupcakeDetector(Context context) {
+			final ViewConfiguration configuration = ViewConfiguration.get(context);
+			mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
+			mTouchSlop = configuration.getScaledTouchSlop();
+		}
+
+		private VelocityTracker mVelocityTracker;
+		private boolean mIsDragging;
+
+		float getActiveX(MotionEvent ev) {
+			return ev.getX();
+		}
+
+		float getActiveY(MotionEvent ev) {
+			return ev.getY();
+		}
+
+		public boolean isScaling() {
+			return false;
+		}
+
+		@Override
+		public boolean onTouchEvent(MotionEvent ev) {
+			switch (ev.getAction()) {
+				case MotionEvent.ACTION_DOWN: {
+					mVelocityTracker = VelocityTracker.obtain();
+					mVelocityTracker.addMovement(ev);
+
+					mLastTouchX = getActiveX(ev);
+					mLastTouchY = getActiveY(ev);
+					mIsDragging = false;
+					break;
+				}
+
+				case MotionEvent.ACTION_MOVE: {
+					final float x = getActiveX(ev);
+					final float y = getActiveY(ev);
+					final float dx = x - mLastTouchX, dy = y - mLastTouchY;
+
+					if (!mIsDragging) {
+						// Use Pythagoras to see if drag length is larger than
+						// touch slop
+						mIsDragging = Math.sqrt((dx * dx) + (dy * dy)) >= mTouchSlop;
+					}
+
+					if (mIsDragging) {
+						mListener.onDrag(dx, dy);
+						mLastTouchX = x;
+						mLastTouchY = y;
+
+						if (null != mVelocityTracker) {
+							mVelocityTracker.addMovement(ev);
+						}
+					}
+					break;
+				}
+
+				case MotionEvent.ACTION_CANCEL: {
+					// Recycle Velocity Tracker
+					if (null != mVelocityTracker) {
+						mVelocityTracker.recycle();
+						mVelocityTracker = null;
+					}
+					break;
+				}
+
+				case MotionEvent.ACTION_UP: {
+					if (mIsDragging) {
+						if (null != mVelocityTracker) {
+							mLastTouchX = getActiveX(ev);
+							mLastTouchY = getActiveY(ev);
+
+							// Compute velocity within the last 1000ms
+							mVelocityTracker.addMovement(ev);
+							mVelocityTracker.computeCurrentVelocity(1000);
+
+							final float vX = mVelocityTracker.getXVelocity(), vY = mVelocityTracker.getYVelocity();
+
+							// If the velocity is greater than minVelocity, call
+							// listener
+							if (Math.max(Math.abs(vX), Math.abs(vY)) >= mMinimumVelocity) {
+								mListener.onFling(mLastTouchX, mLastTouchY, -vX, -vY);
+							}
+						}
+					}
+
+					// Recycle Velocity Tracker
+					if (null != mVelocityTracker) {
+						mVelocityTracker.recycle();
+						mVelocityTracker = null;
+					}
+					break;
+				}
+			}
+
+			return true;
+		}
+	}
+
+	@TargetApi(5)
+	private static class EclairDetector extends CupcakeDetector {
+		private static final int INVALID_POINTER_ID = -1;
+		private int mActivePointerId = INVALID_POINTER_ID;
+		private int mActivePointerIndex = 0;
+
+		public EclairDetector(Context context) {
+			super(context);
+		}
+
+		@Override
+		float getActiveX(MotionEvent ev) {
+			try {
+				return ev.getX(mActivePointerIndex);
+			} catch (Exception e) {
+				return ev.getX();
+			}
+		}
+
+		@Override
+		float getActiveY(MotionEvent ev) {
+			try {
+				return ev.getY(mActivePointerIndex);
+			} catch (Exception e) {
+				return ev.getY();
+			}
+		}
+
+		@Override
+		public boolean onTouchEvent(MotionEvent ev) {
+			final int action = ev.getAction();
+			switch (action & MotionEvent.ACTION_MASK) {
+				case MotionEvent.ACTION_DOWN:
+					mActivePointerId = ev.getPointerId(0);
+					break;
+				case MotionEvent.ACTION_CANCEL:
+				case MotionEvent.ACTION_UP:
+					mActivePointerId = INVALID_POINTER_ID;
+					break;
+				case MotionEvent.ACTION_POINTER_UP:
+					final int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
+					final int pointerId = ev.getPointerId(pointerIndex);
+					if (pointerId == mActivePointerId) {
+						// This was our active pointer going up. Choose a new
+						// active pointer and adjust accordingly.
+						final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
+						mActivePointerId = ev.getPointerId(newPointerIndex);
+						mLastTouchX = ev.getX(newPointerIndex);
+						mLastTouchY = ev.getY(newPointerIndex);
+					}
+					break;
+			}
+
+			mActivePointerIndex = ev.findPointerIndex(mActivePointerId != INVALID_POINTER_ID ? mActivePointerId : 0);
+			return super.onTouchEvent(ev);
+		}
+	}
+
+	@TargetApi(8)
+	private static class FroyoDetector extends EclairDetector {
+
+		private final ScaleGestureDetector mDetector;
+
+		// Needs to be an inner class so that we don't hit
+		// VerifyError's on API 4.
+		private final OnScaleGestureListener mScaleListener = new OnScaleGestureListener() {
+
+			@Override
+			public boolean onScale(ScaleGestureDetector detector) {
+				mListener.onScale(detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
+				return true;
+			}
+
+			@Override
+			public boolean onScaleBegin(ScaleGestureDetector detector) {
+				return true;
+			}
+
+			@Override
+			public void onScaleEnd(ScaleGestureDetector detector) {
+				// NO-OP
+			}
+		};
+
+		public FroyoDetector(Context context) {
+			super(context);
+			mDetector = new ScaleGestureDetector(context, mScaleListener);
+		}
+
+		@Override
+		public boolean isScaling() {
+			return mDetector.isInProgress();
+		}
+
+		@Override
+		public boolean onTouchEvent(MotionEvent ev) {
+			mDetector.onTouchEvent(ev);
+			return super.onTouchEvent(ev);
+		}
+
+	}
+}
\ No newline at end of file
diff --git a/src/com/transage/privatespace/gallery/photozoom/ViewPagerFixed.java b/src/com/transage/privatespace/gallery/photozoom/ViewPagerFixed.java
new file mode 100755
index 0000000..b037982
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/photozoom/ViewPagerFixed.java
@@ -0,0 +1,36 @@
+package com.transage.privatespace.gallery.photozoom;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+public class ViewPagerFixed extends android.support.v4.view.ViewPager {
+
+    public ViewPagerFixed(Context context) {
+        super(context);
+    }
+
+    public ViewPagerFixed(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        try {
+            return super.onTouchEvent(ev);
+        } catch (IllegalArgumentException ex) {
+            ex.printStackTrace();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        try {
+            return super.onInterceptTouchEvent(ev);
+        } catch (IllegalArgumentException ex) {
+            ex.printStackTrace();
+        }
+        return false;
+    }
+}
diff --git a/src/com/transage/privatespace/gallery/util/AESEncryptionUtil.java b/src/com/transage/privatespace/gallery/util/AESEncryptionUtil.java
new file mode 100755
index 0000000..3787aa1
--- /dev/null
+++ b/src/com/transage/privatespace/gallery/util/AESEncryptionUtil.java
@@ -0,0 +1,241 @@
+package com.transage.privatespace.gallery.util;
+
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * Created by dongrp on 2017/7/10.
+ */
+
+public class AESEncryptionUtil {
+    private static final String VIPARA = "0102030405060708";
+    private static final String KEY = "qwertyuioplkjhgf";
+
+    /**
+     * 初始化 AES Cipher
+     *
+     * @param sKey 秘钥
+     * @param cipherMode 加密/解密 模式
+     * @return Cipher
+     */
+    private static Cipher initAESCipher(String sKey, int cipherMode) {
+        Cipher cipher = null;
+        try {
+            IvParameterSpec zeroIv = new IvParameterSpec(VIPARA.getBytes());
+            SecretKeySpec key = new SecretKeySpec(sKey.getBytes(), "AES");
+            cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
+            cipher.init(cipherMode, key, zeroIv);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        } catch (NoSuchPaddingException e) {
+            e.printStackTrace();
+        } catch (InvalidKeyException e) {
+            e.printStackTrace();
+        } catch (InvalidAlgorithmParameterException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return cipher;
+    }
+
+    /**
+     * 对文件进行AES加密（文件到文件）
+     *
+     * @param sourceFilePath 待加密的明文件绝对路径
+     * @param destFilePath 加密后的密文件存储绝对路径
+     * @return
+     */
+    public static boolean encryptFile(String sourceFilePath, String destFilePath) {
+        FileInputStream in;
+        FileOutputStream out;
+        File destFile;
+        File sourceFile;
+        try {
+            sourceFile = new File(sourceFilePath);
+            destFile = new File(destFilePath);
+            if (sourceFile.exists() && sourceFile.isFile()) {
+                if (!destFile.getParentFile().exists()) {
+                    destFile.getParentFile().mkdirs();
+                }
+                destFile.createNewFile();
+                in = new FileInputStream(sourceFile);
+                out = new FileOutputStream(destFile);
+                Cipher cipher = initAESCipher(KEY, Cipher.ENCRYPT_MODE);
+                //以加密流写入文件
+                CipherInputStream cipherInputStream = new CipherInputStream(in, cipher);
+                byte[] cache = new byte[1024*1024];
+                int nRead = 0;
+                while ((nRead = cipherInputStream.read(cache)) != -1) {
+                    out.write(cache, 0, nRead);
+                    out.flush();
+                }
+                in.close();
+                out.close();
+                cipherInputStream.close();
+                return true;
+            }
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        } catch (IOException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+        return false;
+    }
+
+    /**
+     * AES方式解密文件（文件到文件）
+     *
+     * @param sourceFilePath 待解密的密文件绝对路径
+     * @param destFilePath 解密后的明文件存储绝对路径
+     * @return
+     */
+    public static boolean decryptFile(String sourceFilePath, String destFilePath) {
+        FileInputStream in;
+        FileOutputStream out;
+        File destFile;
+        File sourceFile;
+        try {
+            sourceFile = new File(sourceFilePath);
+            destFile = new File(destFilePath);
+            if (sourceFile.exists() && sourceFile.isFile()) {
+                if (!destFile.getParentFile().exists()) {
+                    destFile.getParentFile().mkdirs();
+                }
+                destFile.createNewFile();
+                in = new FileInputStream(sourceFile);
+                out = new FileOutputStream(destFile);
+                Cipher cipher = initAESCipher(KEY, Cipher.DECRYPT_MODE);
+                CipherOutputStream cipherOutputStream = new CipherOutputStream(out, cipher);
+                byte[] buffer = new byte[1024*1024];
+                int r;
+                while ((r = in.read(buffer)) >= 0) {
+                    cipherOutputStream.write(buffer, 0, r);
+                }
+                in.close();
+                out.close();
+                cipherOutputStream.close();
+                return true;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+
+    /**
+     * 解密私密文件 解密为 CipherInputStream
+     * @param sourceFilePath 密文件绝对路路径
+     * @return 文件解密输出流
+     */
+    public static CipherInputStream decryptFileToInputStream(String sourceFilePath) {
+        FileInputStream in = null;
+        File sourceFile;
+        try {
+            sourceFile = new File(sourceFilePath);
+            if (sourceFile.exists() && sourceFile.isFile()) {
+                in = new FileInputStream(sourceFile);
+                Cipher cipher = initAESCipher(KEY, Cipher.DECRYPT_MODE);
+                //文件解密后的 InputStream
+                CipherInputStream cipherInputStream = new CipherInputStream(in, cipher);
+                return cipherInputStream;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }finally {
+            try {
+                in.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * 将私密文件解密为 byte[] 输出
+     * @param sourceFilePath
+     * @return
+     */
+    public static byte[] decryptFileToByteArray(String sourceFilePath) {
+        FileInputStream in = null;
+        File sourceFile;
+        try {
+            sourceFile = new File(sourceFilePath);
+            if (sourceFile.exists() && sourceFile.isFile()) {
+                in = new FileInputStream(sourceFile);
+                Cipher cipher = initAESCipher(KEY, Cipher.DECRYPT_MODE);
+                //文件解密后的 InputStream
+                CipherInputStream cipherInputStream = new CipherInputStream(in, cipher);
+                ByteArrayOutputStream out = new ByteArrayOutputStream();
+                byte[] buffer = new byte[1024 * 1024];
+                int n = 0;
+                while ((n = cipherInputStream.read(buffer)) != -1) {
+                    out.write(buffer, 0, n);
+                }
+                in.close();
+                return out.toByteArray();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+
+    public static File decryptFile2(String sourceFilePath, String destFilePath) {
+        Log.d("AESEncryptionUtil", "hahah");
+        FileInputStream in;
+        FileOutputStream out;
+        File destFile = null;
+        File sourceFile;
+        try {
+            sourceFile = new File(sourceFilePath);
+            destFile = new File(destFilePath);
+            if (sourceFile.exists() && sourceFile.isFile()) {
+                if (!destFile.getParentFile().exists()) {
+                    destFile.getParentFile().mkdirs();
+                }
+                destFile.createNewFile();
+                in = new FileInputStream(sourceFile);
+                out = new FileOutputStream(destFile);
+                Cipher cipher = initAESCipher(KEY, Cipher.DECRYPT_MODE);
+                CipherOutputStream cipherOutputStream = new CipherOutputStream(out, cipher);
+                byte[] buffer = new byte[1024*1024];
+                int r;
+                while ((r = in.read(buffer)) >= 0) {
+                    cipherOutputStream.write(buffer, 0, r);
+                }
+                in.close();
+                out.close();
+                cipherOutputStream.close();
+                return destFile;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        Log.d("AESEncryptionUtil", "destFile.exists():" + destFile.exists());
+        return destFile;
+    }
+
+
+
+
+}
